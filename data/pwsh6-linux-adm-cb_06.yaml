- en: Using Variables and Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量和对象
- en: 'In this chapter, we are discussing the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Using environment variables
  id: totrans-2
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: Storing the output of an instance of a .NET Core object
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储 .NET Core 对象实例的输出
- en: Creating custom properties to an object
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为对象创建自定义属性
- en: Creating a custom object from a returned object
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从返回的对象创建自定义对象
- en: Understanding extension of type data
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 理解类型数据的扩展
- en: Retaining object modifications across sessions
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在会话间保留对象的修改
- en: Removing custom type data
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除自定义类型数据
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Variables are important to programming since they act as containers of information
    stored during the program execution. Although piping makes PowerShell highly versatile,
    they still cannot replace variables, because objects passed through the pipeline
    must be consumed immediately, and not all scripts work that way, given our varied
    requirements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在编程中非常重要，因为它们充当在程序执行过程中存储信息的容器。尽管管道使得 PowerShell 非常灵活，但它们仍然无法替代变量，因为通过管道传递的对象必须立即被消费，而不是所有脚本都以这种方式工作，因为我们的需求各异。
- en: 'We are all aware of the various data types: `int`, `double`, `string`, `char`,
    `array`, etc. Two other important types of variables in PowerShell are *hashtables*
    and *objects*. A hashtable is a dictionary table formed with key–value pairs.
    An object, as we have seen, could be as complex and as simple as it can get in
    PowerShell, holding values of different kinds.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道各种数据类型：`int`、`double`、`string`、`char`、`array` 等。在 PowerShell 中，另外两种重要的变量类型是*哈希表*和*对象*。哈希表是由键值对构成的字典表。正如我们所看到的，PowerShell
    中的对象可以是简单的，也可以是复杂的，能够存储不同类型的值。
- en: In PowerShell, objects can be stored into variables. For instance,
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，对象可以存储到变量中。例如，
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: would store all the processes into the variable, `$Processes`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 会将所有进程存储到变量 `$Processes` 中。
- en: One more point to remember with variables is the scope. By default, variables
    have a local scope, meaning, they are valid within the function that they are
    specified in. Global variables are valid across the program. In general, it is
    a best practice to use local variables, though.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的另一个关于变量的点是作用域。默认情况下，变量具有局部作用域，这意味着它们在指定的函数内有效。全局变量在整个程序中有效。通常，最佳实践是使用局部变量。
- en: Global variables are declared and used with the `$Global:` prefix, such as `$Global:MyVariable`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量通过 `$Global:` 前缀声明和使用，例如 `$Global:MyVariable`。
- en: Using environment variables
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: In this recipe, you will learn about environment variables. When interacting
    with the system through a shell session, there are many pieces of information
    that the Shell requires in order to determine the program access, the available
    resources, default configuration, system properties, etc. Some of these settings
    are configured within the system as variables and these settings are commonly
    called the *EnvironmentVariables*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，你将了解环境变量。当通过 Shell 会话与系统交互时，Shell 需要许多信息来确定程序访问、可用资源、默认配置、系统属性等。这些设置中有一部分被配置为变量，这些设置通常被称为*环境变量*。
- en: While hard-coding this information during installation is one way to go, it
    makes the entire system a monolith that cannot be reconfigured without what is
    known as nuking-and-paving. With environment variables, another layer of flexibility
    is introduced.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在安装期间硬编码这些信息是一种做法，但它会使整个系统成为一个不可重新配置的整体，除非通过所谓的“重建并重新安装”方法来解决。通过环境变量，引入了另一层灵活性。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let us start working with an environment variable using the following steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤开始使用环境变量：
- en: To Display environment variable, type in `Get-ChildItem env:` or `Get-Item env:`
    and press enter
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示环境变量，请键入 `Get-ChildItem env:` 或 `Get-Item env:` 然后按回车键。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`Env:` is also a PowerShell provider, and works just like a file system. Therefore,
    you could also `Set-Location` at `Env:` and use `Get-ChildItem .` to list out
    the variables available in your system.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Env:` 也是 PowerShell 提供的一个提供程序，它的工作方式类似于文件系统。因此，你也可以 `Set-Location` 到 `Env:`
    并使用 `Get-ChildItem .` 来列出系统中可用的变量。'
- en: To display the value of the specific environment variable, run the following
    command.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要显示特定环境变量的值，运行以下命令。
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After typing `Get-ChildItem Env:/`,  You can use tab-completion to populate
    all environment variables.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在键入 `Get-ChildItem Env:/` 后，你可以使用 Tab 键补全来列出所有环境变量。
- en: Do a `Get-Member` on the `PATH` environment variable to find its type.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `PATH` 环境变量执行 `Get-Member` 来查找其类型。
- en: Before changing the environment variable, list the `PATH` variable using `$env:PATH
    | Get-Member`. It is a string. Save the contents someplace safe.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更改环境变量之前，使用 `$env:PATH | Get-Member` 列出 `PATH` 变量。它是一个字符串。请将内容保存在安全的地方。
- en: 'Now, update the `PATH` environment variable by adding the path of `sqlcmd`
    tool executable to $`env: PATH` variable. The operation is a simple addition of
    a string to the existing value.'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过将 `sqlcmd` 工具的可执行文件路径添加到 `$env:PATH` 变量中，更新 `PATH` 环境变量。此操作只是将一个字符串附加到现有值中。
- en: You could add any location to `PATH`. If you insist on getting `sqlcmd`, head
    over to [Microsoft docs](https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-setup-tools?view=sql-server-linux-2017) for
    SQL Server 2017 for instructions to get yourself a copy.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将任何位置添加到 `PATH`。如果你坚持获取 `sqlcmd`，请访问 [Microsoft 文档](https://docs.microsoft.com/en-us/sql/linux/sql-server-linux-setup-tools?view=sql-server-linux-2017)，了解如何获取
    SQL Server 2017 的指南。
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the preceding code block is illustrated in the following image:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上面代码块的输出如下图所示：
- en: '![](img/1e6b48cb-4403-4d84-aac1-56e43f0a78b9.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1e6b48cb-4403-4d84-aac1-56e43f0a78b9.png)'
- en: Let us exit the session, launch a new session,  check the `PATH` variable, and
    run the `sqlcmd` executable.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们退出当前会话，启动一个新会话，检查 `PATH` 变量，并运行 `sqlcmd` 可执行文件。
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As we saw in *Listing the various providers in PowerShell*, `Env` is a provider
    that contains environment-specific configuration. Most of these configuration
    options are also exposed to us as environment variables. We are able to use the
    cmdlets `Get-ChildItem` and `Get-Item` to list the values of the available environment
    variables because `Env:` is a drive within the `Env` provider. As environment
    variables do not have child items, `Get-Item` and `Get-ChildItem` return the same
    output.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们在 *列出 PowerShell 中的各种提供者* 中看到的那样，`Env` 是一个包含环境特定配置的提供者。这些配置选项大多也以环境变量的形式暴露给我们。我们可以使用
    cmdlet `Get-ChildItem` 和 `Get-Item` 列出可用环境变量的值，因为 `Env:` 是 `Env` 提供者中的一个驱动器。由于环境变量没有子项，`Get-Item`
    和 `Get-ChildItem` 返回相同的输出。
- en: Since these variables determine how your session behaves with you, changes made
    to these values are ephemeral. In other words, the value of `$env:PATH` is picked
    from the configuration on your Linux computer. The manual change made to `$env:PATH`
    made within a PowerShell session remains as long as the PowerShell session is
    alive. Changes made to $env:PATH does not change the value within the system itself.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些变量决定了你的会话如何与系统交互，因此对这些值所做的更改是暂时性的。换句话说，`$env:PATH` 的值是从你 Linux 计算机上的配置中获取的。在
    PowerShell 会话中手动更改 `$env:PATH` 的值，只要 PowerShell 会话处于活动状态，该更改就会生效。但对 `$env:PATH`
    的更改并不会改变系统本身的值。
- en: If you would like to make a certain change permanent, edit the `.bashrc` or
    the **`~/.bash_profile` **configuration files. If you would like to use PowerShell
    instead of Bash, make the change in your PowerShell profile. Instructions on how
    to do that can be found in the recipe, *Enabling automated execution of commands
    for each load*, in the chapter, *Preparing for Administration using PowerShell*.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望某些更改是永久性的，可以编辑 `.bashrc` 或 **`~/.bash_profile`** 配置文件。如果你希望使用 PowerShell
    而不是 Bash，请在 PowerShell 配置文件中进行更改。有关如何操作的说明，请参见章节 *使用 PowerShell 为管理做准备* 中的配方 *启用每次加载时自动执行命令*。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can also access environment variables using  .NET type accelerator and its
    methods.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 .NET 类型加速器及其方法来访问环境变量。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See also
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'About Environment variables: `Get-Help about_Environment_Variables`'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于环境变量：`Get-Help about_Environment_Variables`
- en: 'Recipe 1.11: Listing the various providers in PowerShell'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方 1.11：列出 PowerShell 中的各种提供者
- en: 'Recipe 3.4: Enabling automated execution of commands for each load'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方 3.4：启用每次加载时自动执行命令
- en: Storing the output of an instance of a .NET Core Object
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储 .NET Core 对象实例的输出
- en: .NET is object-oriented, and works on classes and objects. PowerShell, being
    an extension to this framework, allows you to work with the .NET framework and
    COM interfaces in order to perform many system administration tasks. This way,
    you are not limited only to the tasks that can be performed using cmdlets.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 是面向对象的，并且基于类和对象工作。PowerShell 作为该框架的扩展，允许你与 .NET 框架和 COM 接口一起工作，从而执行许多系统管理任务。这样，你不仅限于使用
    cmdlet 执行的任务。
- en: In this recipe, we will define a simple class from within PowerShell.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将在 PowerShell 中定义一个简单的类。
- en: Getting Ready
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We recommend using Visual Studio Code for this recipe. To know how to install
    and configure it, visit the recipe, *Installing Visual Studio Code* from the chapter, *Preparing
    for Administration using PowerShell*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议在这个食谱中使用 Visual Studio Code。要了解如何安装和配置它，请访问本章的食谱 *安装 Visual Studio Code*，该章节在
    *使用 PowerShell 准备管理工作* 中。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Launch Visual Studio Code and address any immediate requirements it asks for.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Visual Studio Code 并处理它要求的任何即时需求。
- en: Open a new file in Visual Studio Code and set the file type as PowerShell.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中打开一个新文件，并设置文件类型为 PowerShell。
- en: Type in the following in the script pane. The file does not have to be saved.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本窗格中输入以下内容。文件不需要保存。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To find constructors of a class, call the static method, `New`; type in the
    following at the prompt.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查找类的构造函数，请调用静态方法 `New`；在提示符下输入以下内容。
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This gives us two functions of the same name; these are overload definitions.
    Now, create a new object by passing in the parameters.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样我们就有了两个同名的函数；这些是重载定义。现在，通过传递参数来创建一个新对象。
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](img/6134d77a-3052-4d39-b0ba-c260b5982fd6.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6134d77a-3052-4d39-b0ba-c260b5982fd6.png)'
- en: Now, let us invoke the constructor the PowerShell way, which in turn calls the
    .NET constructor. This creates an instance of the Person class (which, by definition,
    is an object).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们以 PowerShell 的方式调用构造函数，这会调用 .NET 的构造函数。这样会创建一个 Person 类的实例（根据定义，它是一个对象）。
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To list the properties of the object (and by extension, the class), run the
    `Get-Member` cmdlet.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要列出对象的属性（以及类的属性），可以运行 `Get-Member` cmdlet。
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/8daf5696-50c8-40ac-b1f9-a9114d7c13b9.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8daf5696-50c8-40ac-b1f9-a9114d7c13b9.png)'
- en: Next, Let us take a look at the other samples. Let us use system-defined class
    libraries.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们看看其他示例。我们将使用系统定义的类库。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let us see another example of password encryption using `System.Management.Automation`
    class objects.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看使用 `System.Management.Automation` 类对象进行密码加密的另一个示例。
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/6cb687d1-a002-45c1-917f-d2a18d39014e.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6cb687d1-a002-45c1-917f-d2a18d39014e.png)'
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The goal of this recipe is to demonstrate how PowerShell works hand-in-hand
    with .NET, and objects that are created the *.NET way* can be called (and stored)
    easily in PowerShell. First, we declare a class with the keyword, `class`. We
    then declare its parameters, and then, create two constructors: one default and
    one parameterised.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱的目标是演示 PowerShell 如何与 .NET 紧密配合工作，并且按照 *.NET 方式* 创建的对象可以轻松在 PowerShell 中调用（并存储）。首先，我们使用
    `class` 关键字声明一个类。接着声明它的参数，然后创建两个构造函数：一个是默认构造函数，一个是带参数的构造函数。
- en: We also create a method called `sal`. We define its return type as `int32`,
    and defined two parameters. Within it, we define what needs to be returned.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个名为 `sal` 的方法。我们定义了它的返回类型为 `int32`，并定义了两个参数。在其中，我们定义了需要返回的内容。
- en: Back at the PowerShell prompt, we call the static (method of the class, not
    of an object) `New` method. The syntax is to mention the class name, followed
    by two consecutive colons (`::`) to call it in the global namespace, followed
    by the name of the method.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 PowerShell 提示符，我们调用类的静态方法（而非对象的方法）`New`。语法是先提及类名，然后是两个连续的冒号 (`::`)，在全局命名空间中调用它，接着是方法名。
- en: If you follow the steps, you'll also see an example of using the two different
    system class libraries, `System.Net.Mail.SmtpClient` and `System.Net.Mail.MailMessage`,
    and the instantiation of a method by integrating the output of mail-message with
    the SMTP-client object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照步骤操作，你还会看到使用两个不同系统类库的例子，`System.Net.Mail.SmtpClient` 和 `System.Net.Mail.MailMessage`，并通过将
    mail-message 的输出与 SMTP-client 对象结合来实例化一个方法。
- en: Next, we use the system class library `System.Management.Automation.PSCredential`.
    In this example, we send some text to `ConvertTo-SecureString` which takes input
    as plain text and converts it to a secure string. Then, we pass the encrypted
    string to the `PSCrendital` system class to store the user name and the secure
    string into the `$Credentials` variable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用系统类库 `System.Management.Automation.PSCredential`。在这个示例中，我们将一些文本发送给 `ConvertTo-SecureString`，它接受明文输入并将其转换为安全字符串。然后，我们将加密后的字符串传递给
    `PSCrendital` 系统类，将用户名和安全字符串存储到 `$Credentials` 变量中。
- en: See also
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'Recipe 3.1: Installing Visual Studio Code'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 食谱 3.1：安装 Visual Studio Code
- en: Adding custom properties to an object
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向对象添加自定义属性
- en: PowerShell cmdlets are capable of allowing the administrators to work with most
    tasks. However, there are some situations where the returned objects don't satisfy
    the administrative needs of a certain script. In such situations, we may need
    to create our own custom objects based on the available .NET classes, or at least,
    add a custom property to the object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell cmdlet 使管理员能够处理大多数任务。然而，也有一些情况，返回的对象不能满足某个脚本的管理需求。在这种情况下，我们可能需要根据现有的
    .NET 类创建自己的自定义对象，或者至少为对象添加自定义属性。
- en: While a string is an object of `System. String` type, the `Get-Process` cmdlet
    returns an object of type `System.Diagnostics.Process`, `Get-ChildItem` returns
    an object with the type `System.IO.FileInfo`, a custom-created object has the
    object type, `PSCustomObject`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字符串是`System.String`类型的对象，`Get-Process` cmdlet 返回的是 `System.Diagnostics.Process`
    类型的对象，`Get-ChildItem` 返回的是 `System.IO.FileInfo` 类型的对象，而自定义创建的对象的类型是 `PSCustomObject`。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let us now proceed to create a custom object.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续创建一个自定义对象。
- en: To create a custom object, use `New-Object` cmdlet.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建自定义对象，请使用 `New-Object` cmdlet。
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That was not of much use to us. Let us add a few properties into it, along with
    their values and store these values in a variable.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这对我们帮助不大。让我们向其中添加几个属性及其值，并将这些值存储在一个变量中。
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To add properties to an object, use the `Add-Member` cmdlet.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向对象添加属性，请使用 `Add-Member` cmdlet。
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To remove a property from an object, use the following command.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从对象中移除属性，使用以下命令。
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To access properties, you can use the member access operator (`.`).
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问属性，可以使用成员访问操作符 (`.`)。
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Creating an object is straightforward. All you have to do is tell PowerShell
    that you are creating a custom object, by calling the `[psobject]` accelerator
    and specifying the properties you would like to add to the object. After the accelerator
    is called, we specify the names of the properties, and assign values to them.
    Records are added one at a time, using the hash literal notation (`Name = 'Prashanth'`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象很简单。你所需要做的就是告诉 PowerShell 你正在创建一个自定义对象，通过调用`[psobject]`加速器并指定你想要添加到对象的属性。在调用加速器后，我们指定属性的名称，并为它们赋值。记录是逐个添加的，使用哈希文字符号表示法（`Name
    = 'Prashanth'`）。
- en: It is easy to confuse a hashtable with a PSObject at this stage, given that
    we use the hash literal notation when creating the object. Remember that they
    are very different from each other. We will get into the details of what a hashtable
    is in the chapter, *Arrays and Hashtables*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，由于我们在创建对象时使用了哈希文字符号表示法，容易将哈希表与 PSObject 混淆。请记住，它们彼此之间非常不同。我们将在 *数组与哈希表*
    这一章中深入讨论哈希表是什么。
- en: 'We mention three properties in the custom object we have created: `Name`, `Title`
    and `Publisher`. If we would like to add additional properties in the future,
    we can simply use the `Add-Member` cmdlet, where we specify the object (we pass
    the object through the pipeline), we specify the name of the property, and assign
    a value to it.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建的自定义对象中提到了三个属性：`Name`、`Title` 和 `Publisher`。如果我们以后想添加更多属性，可以简单地使用 `Add-Member`
    cmdlet，在其中我们指定对象（通过管道传递对象），指定属性的名称，并为其赋值。
- en: Removing a property is a little more complex, since we do not have a `Remove-Member`
    cmdlet, nor are the members we use in the step easily discoverable. For instance, `[PSCustomObject]
    | Get-Member` does not reveal `PsObject` being its member. We call the `Remove`
    method within the `Properties` object, which is within the `PSObject` object of
    the custom object we created. (So many objects!)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 移除属性稍微复杂一些，因为我们没有 `Remove-Member` cmdlet，也没有我们在步骤中使用的成员容易被发现。例如，`[PSCustomObject]
    | Get-Member` 并不会揭示 `PsObject` 是它的成员。我们在 `PSObject` 对象的 `Properties` 对象中调用 `Remove`
    方法，这是我们创建的自定义对象的一部分。（这么多对象！）
- en: Accessing properties in an object is as simple as using the member access operator
    with the property name.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 访问对象中的属性就像使用成员访问操作符并附上属性名称一样简单。
- en: See also
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: Recipe: Creating and initialising a simple hashtable
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方：创建并初始化一个简单的哈希表
- en: Creating a custom object from a returned object
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从返回的对象创建自定义对象
- en: We now know how to create a custom object from scratch. In this recipe, we will
    use a returned object, and modify the returned object to create a custom object.
    When we look at loops, we will extend this capability to create versatile custom
    objects; in production environments, this capability can be used to do more!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何从零创建自定义对象。在这个方法中，我们将使用一个返回的对象，并修改它来创建一个自定义对象。当我们学习循环时，我们将扩展这个功能，创建更通用的自定义对象；在生产环境中，这一功能可以用来做更多的事情！
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The first step to learning something is to simplify it. Therefore, we will select
    only one instance of an object and work with it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 学习某个事物的第一步是将其简化。因此，我们将只选择一个对象实例并与之操作。
- en: Get all the processes, select only the name, ID, working set and the start time,
    pick the 5th process in the list, and assign it to a variable.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有进程，只选择名称、ID、工作集和启动时间，选取列表中的第 5 个进程并将其分配给一个变量。
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let us say that we did not like the names of the properties in the object. Let
    us change the names.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们不喜欢对象中属性的名称。让我们来更改这些名称。
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](img/a42cf4a5-4cb5-4112-9157-fd017a8d4192.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a42cf4a5-4cb5-4112-9157-fd017a8d4192.png)'
- en: But that is not the sequence we specified. Let us get them in sequence.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但这不是我们指定的顺序。让我们按顺序获取它们。
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![](img/609d4d23-847e-4300-9453-0071a046f302.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/609d4d23-847e-4300-9453-0071a046f302.png)'
- en: Recreate the object with information on how long the process has been running
    for instead of when it was started.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新创建对象，展示进程运行了多长时间，而不是它何时启动。
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![](img/9708bd11-619f-45c9-8842-7aac2c1ac587.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9708bd11-619f-45c9-8842-7aac2c1ac587.png)'
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a custom object (`$CustomProcess`) from an output
    object (`$Process`). The properties within `$Process` can be accessed using the
    member access operator. Values from `$Process` are treated as values for the properties
    in `$CustomObject`, however, the names in `$CustomObject` are different. In this
    recipe, we also used a calculated property, `RunningMins`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们从一个输出对象（`$Process`）创建了一个自定义对象（`$CustomProcess`）。可以使用成员访问运算符访问`$Process`中的属性。来自`$Process`的值作为`$CustomObject`中的属性值，但`$CustomObject`中的名称不同。在这个方法中，我们还使用了一个计算属性`RunningMins`。
- en: An important point to note here is that the outcome of this recipe can also
    be achieved using calculated properties along with `Select-Object`. However, in
    situations where object versatility is important and the number of instances of
    the objects is significantly larger, it is simpler to use a custom object. We
    will extend this capability in future chapters, after we learn to use looping
    constructs.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要点是，这个方法的结果也可以通过使用计算属性和`Select-Object`来实现。然而，在对象的通用性很重要并且对象实例数量显著增多的情况下，使用自定义对象会更简单。我们将在未来的章节中扩展这一功能，在学习如何使用循环结构后。
- en: The other point to note is the use of the `[ordered]` accelerator. More often
    than not, the properties of custom objects do not appear in the sequence we mention
    them in. In this recipe, we separate the hash literal notation from the creation
    of the custom object. We first create an ordered hashtable with the property names
    as well as the property values, and then, specify the created hashtable for the
    `Property` parameter of the `New-Object` cmdlet to create the custom object with
    the properties showing in the sequence we want.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的点是使用`[ordered]`加速器。通常，自定义对象的属性不会按我们提到的顺序出现。在这个方法中，我们将哈希字面量表示法与自定义对象的创建分开。我们首先创建一个有序的哈希表，其中包含属性名称和属性值，然后，指定创建的哈希表作为`New-Object`
    cmdlet的`Property`参数，来创建具有我们想要顺序的属性的自定义对象。
- en: See also
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: '[Creating .NET and COM Objects](https://docs.microsoft.com/en-us/powershell/scripting/getting-started/cookbooks/creating-.net-and-com-objects--new-object-?view=powershell-6)
    (Microsoft Docs)'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[创建 .NET 和 COM 对象](https://docs.microsoft.com/en-us/powershell/scripting/getting-started/cookbooks/creating-.net-and-com-objects--new-object-?view=powershell-6)（Microsoft
    文档）'
- en: Understanding extension of Type Data
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类型数据的扩展
- en: In the recipe, *Selecting columns from the output*, we used a hashtable to set
    the name and the expression for a custom-named column. Later, we also used a small
    calculation within the `Select-Object` statement to get a calculated output. If
    you tried to select the column by the new name, that would have worked, too. Technically,
    you have already extended the object. But what is type data anyway? And why do
    we need a recipe to extend it when we can work with `Select-Object`?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在例子中，*选择输出的列*，我们使用了一个哈希表来设置自定义列的名称和表达式。后来，我们还在`Select-Object`语句中使用了一个小的计算来获取计算后的输出。如果你尝试通过新名称选择列，那也会起作用。从技术上讲，你已经扩展了对象。但是，类型数据到底是什么？为什么我们需要一个例子来扩展它，而不只是使用`Select-Object`呢？
- en: Going too deep into what type data is and how to work with them along with .NET
    classes and objects could potentially make the concept an "advanced" one. Historically,
    most of us learners have procrastinated learning "advanced" topics. Therefore,
    we will stick to the simple parts of it, and work only with PowerShell for now.
    This recipe will serve as a launchpad to help you understand what it is by making
    it simple and fun, keeping it away from anything "advanced", in the interest of
    learning.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 深入探讨类型数据是什么以及如何与.NET类和对象一起使用可能会让这个概念变得“高级”。历史上，我们大多数学习者一直拖延学习“高级”主题。因此，我们将坚持简单的部分，只与PowerShell一起工作。这个例子将作为一个启动平台，帮助你通过简化并让学习变得有趣的方式理解它，避免任何“高级”内容，以利于学习。
- en: 'There are two options to extend the type data:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以扩展类型数据：
- en: Using PowerShell cmdlets (to understand how it all works)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用PowerShell cmdlets（了解其工作原理）
- en: Using an XML file (for portability)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用XML文件（为了可移植性）
- en: Getting ready
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To understand what we are talking about, here, you need to have read the following
    recipes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解我们在说什么，这里你需要先阅读以下例子：
- en: Selecting columns from the output
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从输出中选择列
- en: Creating a custom object from a returned object
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从返回的对象创建一个自定义对象
- en: 'Let us come back to the question: Why extend type data when we can use `Select-Object`?'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到这个问题：为什么要扩展类型数据，而我们可以使用`Select-Object`呢？
- en: 'Efficiency. While you could change the name, add a calculation, and reference
    the calculated property with the new name, that change would have existed only
    in that context. If you added it to a variable,  as in the last recipe, *Creating
    a custom object from a returned object*, where we did some nifty changes to the
    names and also created a custom `NoteProperty`, that would be a long way to go
    about it. Enter: extension of type data.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 效率。虽然你可以更改名称、添加计算并使用新名称引用计算后的属性，但该更改仅会在当前上下文中存在。如果你将其添加到变量中，就像在上一个例子中*创建一个从返回对象生成的自定义对象*那样，做了些巧妙的名称更改并创建了一个自定义的`NoteProperty`，那将是一条很长的路要走。于是，进入：类型数据的扩展。
- en: 'The rule of the thumb is,  If you do something repetitively, there''s an issue:
    you haven''t considered automating it. For example,  if you run:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则是，如果你做某事很频繁，说明存在问题：你没有考虑自动化它。例如，如果你运行：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'instead of:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是：
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: and you do it fifteen times a day, you should consider extending the object
    to give you what you care about.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一天做十五次，你应该考虑扩展对象，以便获得你关心的内容。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Navigate to the location where you created files for lab usage.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到你为实验使用创建文件的位置。
- en: 'Enter the following command:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE24]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, add a property to the variable, `$FilesWithAge`; the property should be
    the age of each file, in days.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为变量`$FilesWithAge`添加一个属性；该属性应该是每个文件的年龄，单位为天。
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Add another property to it, called `ComputerName`, which is the name of your
    local host.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为它添加另一个属性，命名为`ComputerName`，即你的本地主机名。
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Add another property, as an alias to `LastWriteTime`, called `Modified`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个属性，作为`LastWriteTime`的别名，命名为`Modified`。
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To format it like a nice table, use the following:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将其格式化为一个漂亮的表格，请使用以下命令：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![](img/8be1b9ba-03be-4dd0-825e-63cb802c0205.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8be1b9ba-03be-4dd0-825e-63cb802c0205.png)'
- en: Now, delete the variable. And query the files within the current directory (because
    that is what the variable actually held).
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，删除变量，并查询当前目录中的文件（因为变量实际上保存的就是这些内容）。
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You do not see the `Age`, the `ComputerName` or the `Modified` properties. Try `Get-Member`
    if you would like.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你看不到`Age`、`ComputerName`或`Modified`属性。如果你愿意，可以尝试使用`Get-Member`。
- en: Next, we see how to extend the type data itself, so that every time you run
    `Get-ChildItem`, you also get the three properties we added to the variable.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看看如何扩展类型数据本身，以便每次运行`Get-ChildItem`时，你也能得到我们添加到变量中的三个属性。
- en: Get what object is returned when you run `Get-ChildItem`.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取运行`Get-ChildItem`时返回的对象。
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You get `System.IO.DirectoryInfo` as well as `System.IO.FileInfo`. We pick `System.IO.FileInfo`.
    Run the following commands.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会得到`System.IO.DirectoryInfo`以及`System.IO.FileInfo`。我们选择`System.IO.FileInfo`。运行以下命令。
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Query the contents of the current location and optionally, format the output
    like a table.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询当前目录的内容，并可以选择将输出格式化为表格。
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![](img/c5b3b81f-1763-4c48-8193-e924941e8b58.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5b3b81f-1763-4c48-8193-e924941e8b58.png)'
- en: Do the same for any directory in the file system, the only condition being that
    the directory should contain at least one file, and not just more directories.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对文件系统中的任何目录执行相同的操作，唯一的条件是目录应该包含至少一个文件，而不仅仅是更多的目录。
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: How it works...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: In the first section, we added members to the objects within a certain variable.
    This was a command-line-prompt-style extension to the recipe, *Creating a custom
    object from a returned object*, which was, by all means, a little more efficient
    in the context. However, the changes we made to the object remained only while
    the variable, `$FilesWithAge`, was valid. The object returned by `Get-ChildItem`
    was not modified at all.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，我们向某个变量中的对象添加了成员。这是对*创建自定义对象从返回的对象*的命令行提示样式扩展，在这种情况下，效率稍微更高一些。然而，我们对对象所做的更改仅在变量`$FilesWithAge`有效时有效。通过`Get-ChildItem`返回的对象没有被修改。
- en: There is an important point to note here: `$this`. We have come across the automatic
    variable, `$_` (or `$PSItem` after PowerShell V3) when dealing with objects passed
    through the pipeline; the variable holds the current instance of the object in
    the pipeline. However, when we have to perform an object extension, we use the
    automatic variable, `$this`. Why? Because, the property being referred to is being
    referred *within* the parent object (the object returned by `Get-ChildItem`).
    External methods would be able to use `$_`. In a way, `$_` does not even exist
    yet, when performing the member addition. Also, `$this` in fact, refers to the
    object itself, that is returned by `Get-ChildItem`, and not just an instance of
    it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个重要的要点需要注意：`$this`。我们在处理通过管道传递的对象时曾遇到过自动变量`$_`（或者在PowerShell V3之后是`$PSItem`）；该变量保存管道中当前对象的实例。然而，当我们需要执行对象扩展时，我们使用自动变量`$this`。为什么？因为，被引用的属性是*在*父对象中被引用（即通过`Get-ChildItem`返回的对象）。外部方法可以使用`$_`。从某种意义上说，`$_`在执行成员添加时甚至还不存在。而且，`$this`实际上指的是对象本身，它是由`Get-ChildItem`返回的，而不仅仅是它的一个实例。
- en: 'When we would like to get a member as part of the object itself, throughout
    the session, irrespective of the validity of a certain variable or the object
    instance, we *extend the type data itself*. Therefore, no matter what context
    you run the cmdlet in, you would get the additional members you added. Of course,
    the formatting rules in PowerShell may still not let those members appear in the
    output by default. You can always call the specific members, though, such as using
    `Select-Object` for properties, or simply using the member access operator on
    the properties: `(Get-ChildItem .).Age`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望将某个成员作为对象本身的一部分时，无论某个变量或对象实例的有效性如何，我们都会*扩展类型数据本身*。因此，无论在什么上下文中运行cmdlet，你都会得到你添加的附加成员。当然，PowerShell中的格式化规则仍然可能不会默认显示这些成员。你始终可以调用特定的成员，例如使用`Select-Object`获取属性，或者简单地使用成员访问操作符访问属性：`(Get-ChildItem
    .).Age`。
- en: For this, we use the `Update-TypeData` cmdlet. `Update-TypeData`, in this context,
    requires the `TypeName`, which as we have already seen, can be determined using
    `Get-Member` on the returned object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们使用`Update-TypeData` cmdlet。`Update-TypeData`在此上下文中需要`TypeName`，正如我们已经看到的，可以通过对返回对象使用`Get-Member`来确定。
- en: 'We mention four things in the `Update-TypeData` statements:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Update-TypeData`语句中提到四个内容：
- en: The type name
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型名称
- en: The member type
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成员类型
- en: The member name
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成员名称
- en: The member value
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成员值
- en: 'Member type accepts several values, of which we use three:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 成员类型接受多个值，我们使用三种：
- en: '`AliasProperty`, which is simply a reference to another member within the object.
    The new property is just another name to an existing property. Therefore, the
    `Value` parameter can just take the name of the existing member.'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AliasProperty`，它只是指向对象中另一个成员的引用。新属性只是现有属性的另一个名称。因此，`Value`参数可以直接使用现有成员的名称。'
- en: '`NoteProperty`, which is a static value. In our case, we can use the host name
    as the static value.'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NoteProperty`，它是一个静态值。在我们的例子中，我们可以使用主机名作为静态值。'
- en: '`ScriptProperty`, which is essentially a calculation. We calculate the time
    span between the date when it was last modified and the current date. This calculation
    is the `Value` for the member, and accepts a script block.'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ScriptProperty`，本质上是一个计算。我们计算上次修改日期和当前日期之间的时间跨度。这个计算是该成员的`Value`，并接受一个脚本块。'
- en: This modification to the object would be valid as long as the session is valid;
    the change is not persistent across sessions. That brings us to the next recipe,
    making object modifications stick across sessions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对对象的这种修改只要会话有效，就会生效；该更改在会话间不具有持久性。这将引导我们进入下一个食谱，即让对象修改在会话间保持有效。
- en: See also
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'Recipe 5.1: Selecting columns from the output'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 食谱 5.1：从输出中选择列
- en: Retaining object modifications across sessions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持对象修改在会话间有效
- en: 'In the previous recipe, Understanding extension of Type Data, we used the `Update-TypeData`
    cmdlet to add members. However, we said that the update was valid as long as the
    session was. Now, there could be two ways by which to make the type data stick
    across sessions:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个食谱中，我们了解了类型数据扩展的内容，我们使用了 `Update-TypeData` cmdlet 来添加成员。然而，我们提到过，更新在会话有效期间是有效的。现在，有两种方法可以使类型数据在会话间保持有效：
- en: Using the PowerShell profile.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 PowerShell 配置文件。
- en: Using an XML file
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 XML 文件
- en: PowerShell profile is straightforward. However, usually, the type data extension
    and formatting rules are packaged as part of PowerShell modules. And adding code
    to the profile is not particularly helpful in that case. In this recipe, we will
    write a simple XML (`.ps1xml`) file that we will load in order to extend the type
    data.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 配置文件是直接明了的。然而，通常情况下，类型数据扩展和格式化规则是作为 PowerShell 模块的一部分打包的。在这种情况下，将代码添加到配置文件并不特别有用。在这个食谱中，我们将编写一个简单的
    XML（`.ps1xml`）文件，我们将加载它以扩展类型数据。
- en: Getting Ready
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Restart your PowerShell session so that the custom data type extension is discarded.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的 PowerShell 会话，以便丢弃自定义数据类型扩展。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We need an XML file. You can either use the `New-Item` cmdlet to create one,
    or simply use your favourite text editor. We use Visual Studio Code for this recipe.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 XML 文件。你可以使用 `New-Item` cmdlet 创建一个，或者简单地使用你喜欢的文本编辑器。我们在这个食谱中使用 Visual
    Studio Code。
- en: Open your text editor and create a new empty file, and save it as `CustomTypes.ps1xml`.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文本编辑器，创建一个新的空文件，并将其保存为`CustomTypes.ps1xml`。
- en: Add the following content to the XML file. Ensure not to change the case.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 XML 文件中。确保不要更改大小写。
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Save the file at a convenient location.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存在一个方便的位置。
- en: Back at the Terminal (or the PowerShell Integrated Console), enter the following
    command to update the type data using the XML. Notice the `PrependPath` parameter.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到终端（或 PowerShell 集成控制台），输入以下命令以使用 XML 更新类型数据。注意 `PrependPath` 参数。
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, list out all the files within any directory of your choice.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，列出你选择的任何目录中的所有文件。
- en: '[PRE36]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You should see the new properties that you created.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到你创建的新属性。
- en: '![](img/fc352f31-1676-4f6f-b492-31380f2aa080.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc352f31-1676-4f6f-b492-31380f2aa080.png)'
- en: It is advised to never modify the PS1XML files in the `$PSHome` directory. They
    are digitally signed by Microsoft and could be replaced with new versions during
    upgrades or patches.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 建议不要修改 `$PSHome` 目录中的 PS1XML 文件。这些文件由 Microsoft 数字签名，并且在升级或打补丁时可能会被替换为新版本。
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Custom types and formats are mostly used while creating custom modules. Rarely
    do administrators require modifying the types or formats for stock PowerShell
    modules. And when you do require modifying custom types or formats, create a new
    PS1XML; do not modify the stock files, since they are digitally signed, and modifying
    them would break your setup.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型和格式主要在创建自定义模块时使用。管理员很少需要修改标准 PowerShell 模块的类型或格式。当你确实需要修改自定义类型或格式时，应该创建一个新的
    PS1XML 文件；不要修改标准文件，因为它们是数字签名的，修改它们会破坏你的设置。
- en: Think of this PS1XML file as a regular XML file. Here is a simpler way of showing
    the structure. Remember that each type and each of the members within, must have
    a name.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 把这个 PS1XML 文件当作一个普通的 XML 文件。这里有一种更简单的方式来展示结构。记住，每个类型以及其中的每个成员，都必须有一个名称。
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In essence, using the XML for type extension is not very different from how
    we performed type extension in the last recipe, except this uses an XML file,
    which makes the setup more portable. When we work on creating our custom modules,
    we will look at packaging the types along with the modules, and at that time,
    we will look in detail, how to work the paths. For now, we load the XML by manually
    specifying the exact path to the file. If you would like to load these custom
    types for every session of yours, you can easily call the PS1XML from your profile.
    The portability aspect here is that the XML can easily be shared or deployed;
    only the loading would be manual, or through the profile—much simpler than adding
    cmdlets to profiles.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，使用 XML 扩展类型与我们在上一个教程中执行类型扩展的方式没有太大区别，只不过这次使用了 XML 文件，使得设置更具可移植性。当我们开始创建自定义模块时，我们将会研究如何将类型与模块一起打包，到那时我们会详细探讨如何处理路径。目前，我们通过手动指定文件的确切路径来加载
    XML。如果你希望在每次会话中加载这些自定义类型，你可以轻松地从个人配置文件中调用 PS1XML。这里的可移植性在于，XML 可以轻松共享或部署；加载过程将是手动的，或者通过个人配置文件加载——比将
    cmdlet 添加到配置文件中要简单得多。
- en: When updating the type data using cmdlets, we used the parameters `Name` as
    well as `Value`, along with the `MemberType` parameter. PowerShell understood
    the context and set up the types accordingly. In case of XML, though, one must
    remember to use the correct tags for each of the member types. For instance, for
    `AliasProperty`, the tags within should be `Name` and `ReferencedMemberName` (shown
    below); for `ScriptProperty`, they should be `Name` and `GetScriptBlock`; for
    a `NoteProperty`, the tags would be `Name` and `Value`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 cmdlet 更新类型数据时，我们使用了 `Name` 和 `Value` 参数，以及 `MemberType` 参数。PowerShell 会理解上下文并相应地设置类型。然而，对于
    XML，必须记住为每个成员类型使用正确的标签。例如，对于 `AliasProperty`，标签应该是 `Name` 和 `ReferencedMemberName`（如下所示）；对于
    `ScriptProperty`，标签应该是 `Name` 和 `GetScriptBlock`；对于 `NoteProperty`，标签应该是 `Name`
    和 `Value`。
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Also, remember *not* to enclose the entire script block in braces when placing
    the statement within the `GetScriptBlock` tag:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，记住在将语句放入 `GetScriptBlock` 标签时，*不要* 用大括号将整个脚本块括起来：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'and not:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 和不是：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When loading the XML, we use the `PrependPath` parameter to load our XML *before*
    the built-in types are loaded. To load them after the built-in types, there is
    no need to use the `AppendPath` parameter, unless the situation really needs it,
    since `AppendPath` is the default. Why do the parameters matter? They determine
    the precedence of loading the types.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载 XML 时，我们使用 `PrependPath` 参数将 XML 加载到内置类型之前。如果希望在内置类型之后加载它们，则无需使用 `AppendPath`
    参数，除非实际情况需要，因为 `AppendPath` 是默认值。为什么参数很重要？它们决定了类型加载的优先级。
- en: The XML file shown may *look like* having a large number of items. Use the indent
    guide in Visual Studio Code to guide you through reading the XML. The file, in
    reality, is very simple to read. And reading it will help you understand how the
    properties are defined.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的 XML 文件可能*看起来像*有大量的项目。可以使用 Visual Studio Code 中的缩进指南帮助你阅读 XML。实际上，该文件非常易于阅读。阅读它将帮助你理解属性是如何定义的。
- en: See also
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[The Update-TypeData cmdlet](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/update-typedata?view=powershell-6)
    (Microsoft Docs)'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Update-TypeData cmdlet](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/update-typedata?view=powershell-6)（Microsoft
    文档）'
- en: '[The Types.ps1xml file](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_types.ps1xml?view=powershell-6)
    (Microsoft Docs)'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[Types.ps1xml 文件](https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.core/about/about_types.ps1xml?view=powershell-6)（Microsoft
    文档）'
- en: Removing custom type data
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除自定义类型数据
- en: Now that we know how to create and update type data, the next step for us is
    to learn to remove the type data. And removing the type data requires us to get
    the type data first. In this recipe, we learn the process to remove type data;
    whether it was updated using cmdlets or an XML.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道如何创建和更新类型数据，接下来的步骤是学习如何删除类型数据。删除类型数据需要先获取类型数据。在本教程中，我们将学习删除类型数据的过程；无论它是通过
    cmdlet 还是 XML 更新的。
- en: How to do it...
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The first step is to understand that a cmdlet can output one or more types of
    objects. For instance, in our case, `Get-ChildItem` output `System.IO.DirectoryInfo`
    as well as `System.IO.FileInfo`. Let us learn to work with these guys.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是理解一个 cmdlet 可以输出一个或多个类型的对象。例如，在我们的案例中，`Get-ChildItem` 输出了 `System.IO.DirectoryInfo`
    以及 `System.IO.FileInfo`。让我们学习如何处理这些对象。
- en: Get the type of the object returned by the cmdlet.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 cmdlet 返回的对象类型。
- en: '[PRE41]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There are two types returned. We created the custom members in the second type.
    Assign this to a variable.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回了两种类型。我们在第二种类型中创建了自定义成员。将此分配给一个变量。
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Get the type data information. Expand its members to see if the custom members
    are shown.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取类型数据信息。展开其成员，看看是否显示自定义成员。
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![](img/cebc3c44-9586-4735-8b2e-b76d90b35c56.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cebc3c44-9586-4735-8b2e-b76d90b35c56.png)'
- en: Now, remove the type data.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，移除类型数据。
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理如下……
- en: The process is straightforward. If you query the help information for the `TypeName`
    parameter of `Remove-TypeData`, you would notice that it accepts the type name
    accepts input via the pipeline by property value as well as the property name.
    Recall the recipe, *Understanding pipeline-enabled parameters*, and look at the
    object returned by `Get-TypeData`, for more insight.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 过程很简单。如果查询 `Remove-TypeData` 的 `TypeName` 参数的帮助信息，你会注意到它接受类型名称，并通过管道按属性值以及属性名接受输入。回想一下配方，*理解启用管道的参数*，并查看由
    `Get-TypeData` 返回的对象，以获取更多见解。
- en: 'The `Remove-TypeData` cmdlet removes the type data from the current session.
    This removal is as ephemeral as the type addition is. Therefore, the *default*
    types and formats are not permanently removed by the cmdlet; the reason why you
    can run this within PowerShell, without administrator privileges. Also remember
    that the underlying XML *files* are not deleted either: custom or stock.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Remove-TypeData` cmdlet 从当前会话中移除类型数据。此移除与添加类型的效果一样短暂。因此，*默认*类型和格式并未被该 cmdlet
    永久移除；这就是你可以在 PowerShell 中运行它而无需管理员权限的原因。同时，请记住底层 XML *文件* 也未被删除：无论是自定义的还是存储的。'
- en: See also
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Recipe 5.8: Understanding pipeline-enabled parameters
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配方 5.8：理解启用管道的参数
- en: 'That concludes the chapter. It is time to take a break, so it helps you assimilate
    what you learnt. Later, experiment with different data types, create variables,
    see what type of objects they contain, and what members each object contains.
    We did not explicitly talk much about variables in this chapter other than environment
    variables, but we used variables almost in every recipe in the chapter. Ponder
    over (or better yet, practically try out) these questions:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了本章。现在是时候休息一下，这样可以帮助您消化所学的知识。稍后，尝试不同的数据类型，创建变量，看看它们包含什么类型的对象以及每个对象包含哪些成员。在本章中，我们并没有明确讨论变量，除了环境变量之外，但我们几乎在每个配方中都使用了变量。思考（或更好地，实际尝试）以下问题：
- en: What can be assigned to a variable?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以分配什么给变量？
- en: What does the variable contain; the entire object?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量包含什么内容；整个对象吗？
- en: Can I refer to one single property of the object that a variable contains, if
    at all it contains the entire object?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果变量确实包含整个对象，我是否可以引用该对象的一个单一属性？
- en: Can I assign a certain member and not the entire object to a variable?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否可以将某个成员分配给变量，而不是整个对象？
- en: 'What if the member is a whole object in itself? (Hint: Use `Get-Member` on
    the variable to find out.)'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果成员本身就是一个完整的对象怎么办？（提示：对变量使用 `Get-Member` 查看。）
- en: What happens when I use `Select-Object` with `-ExpandProperty` and assign the
    value to a variable? What type is the variable then?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我使用 `Select-Object` 和 `-ExpandProperty` 并将值分配给变量时会发生什么？那时变量的类型是什么？
- en: That would help you understand more about the variables, now that you have used
    them so much.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助您更好地理解变量，因为您已经如此频繁地使用它们。
