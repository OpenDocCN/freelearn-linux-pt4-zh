- en: Chapter 4. Service Scheduling and Management Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章：服务调度和管理框架
- en: 'This chapter introduces several Mesos-based scheduling and management frameworks
    or applications that are required for the easy deployment, discovery, load balancing,
    and failure handling of long-running services. These so-called metaframeworks
    take care of the *housekeeping* activities of other frameworks and applications,
    such as **service discovery** (that is, keeping track of the instances on which
    a particular service is running) and **load balancing** (ensuring an equitable
    workload distribution among the instances), apart from **configuration management**,
    **automated** **job scheduling**, **application** **scaling**, and **failure handling**.
    The frameworks that we''ll explore here include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了几个基于 Mesos 的调度和管理框架或应用程序，这些框架或应用程序对于长期运行服务的轻松部署、发现、负载均衡和故障处理至关重要。这些所谓的元框架负责处理其他框架和应用程序的*家务工作*，例如**服务发现**（即跟踪某个特定服务运行的实例）和**负载均衡**（确保在各个实例之间公平分配工作负载），此外还包括**配置管理**、**自动化****任务调度**、**应用程序****扩展**和**故障处理**。我们将在这里探讨的框架包括：
- en: '**Marathon**: This is used to launch and manage long-running applications on
    Mesos'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Marathon**：用于在 Mesos 上启动和管理长期运行的应用程序'
- en: '**Chronos**: This is a cluster scheduler'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chronos**：这是一个集群调度器'
- en: '**Apache** Aurora: This is a framework for long-running services and cron jobs'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Aurora**：这是一个用于长期运行服务和定时任务的框架'
- en: '**Singularity**: This is a platform-as-a-service (PaaS) for running services'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Singularity**：这是一个平台即服务（PaaS），用于运行服务'
- en: '**Marathoner**: This conducts service discovery for Marathon'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Marathoner**：这是用于 Marathon 的服务发现工具'
- en: '**Consul**: This carries out service discovery and orchestration'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Consul**：执行服务发现和协调'
- en: '**HAProxy**: This is used for load balancing'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HAProxy**：用于负载均衡'
- en: '**Bamboo**: This is used to automatically configure HAProxy for Mesos and Marathon'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bamboo**：用于自动配置 Mesos 和 Marathon 的 HAProxy'
- en: In addition, we'll briefly touch upon two very recent open source frameworks,
    namely **Netflix Fenzo** (a task scheduler) and **Yelp's PaaSTA** (a PaaS for
    running services).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将简要介绍两个非常新的开源框架，即**Netflix Fenzo**（一个任务调度器）和**Yelp 的 PaaSTA**（一个运行服务的
    PaaS）。
- en: Using Marathon to launch and manage long-running applications on Mesos
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Marathon 在 Mesos 上启动和管理长期运行的应用程序
- en: Marathon is a commonly used Mesos framework for long-running applications. It
    can be considered a replacement for `init` or `upstart` in traditional systems
    or as the `init.d` of your system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Marathon 是一个常用的 Mesos 框架，用于长期运行的应用程序。它可以被视为传统系统中 `init` 或 `upstart` 的替代品，或者是您系统的
    `init.d`。
- en: Marathon has many features, such as controlling a high availability environment,
    checking the applications' health, and so on. It also comes with **Representational
    State Transfer** (**REST**), such as endpoint, which you can use to start, stop,
    and scale your applications. It can be used to scale up and down the cluster based
    on the load, which means that it should be able to start a new instance just in
    case an available one goes down. Marathon is also designed to run other frameworks
    on it, such as **Hadoop**, **Kafka**, **Storm**, **Chronos**, and so on. Marathon
    makes sure that every application that is started through it keeps running even
    if a slave node goes down.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Marathon 拥有许多功能，例如控制高可用环境、检查应用程序的健康状态等。它还支持**表现层状态转移**（**REST**），如端点，您可以使用它来启动、停止和扩展您的应用程序。它可以根据负载自动扩展和缩减集群，这意味着它应能在某个可用实例宕机时启动新的实例。Marathon
    还设计用来运行其他框架，例如**Hadoop**、**Kafka**、**Storm**、**Chronos**等。Marathon 确保通过它启动的每个应用程序即使在某个从节点宕机的情况下也能继续运行。
- en: Marathon runs in a highly available fashion, which implies that there can be
    multiple schedulers running in the cluster, but at any given point of time, there
    is only one leader. Whenever an application requests a nonleader, the request
    will be proxied to the active leader. You can also use HAProxy (explained later
    in this chapter) for service discovery and load balancing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Marathon 以高度可用的方式运行，这意味着集群中可以运行多个调度器，但在任何时候，只有一个领导者。当应用程序请求非领导者时，请求将被代理到活跃的领导者。您还可以使用
    HAProxy（本章稍后将解释）进行服务发现和负载均衡。
- en: Marathon also supports basic authentication mechanisms and uses SSL to encrypt
    connections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Marathon 还支持基本的认证机制，并使用 SSL 加密连接。
- en: Installing Marathon
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Marathon
- en: Visit [https://mesosphere.github.io/marathon/](https://mesosphere.github.io/marathon/)
    to download the latest Marathon release. At the time of writing this book, the
    latest version is 0.13.0.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://mesosphere.github.io/marathon/](https://mesosphere.github.io/marathon/)
    下载最新的 Marathon 版本。编写本书时，最新版本是 0.13.0。
- en: 'Marathon can be downloaded as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按照如下方式下载 Marathon：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After downloading, extract the files as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，按如下方式解压文件：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can see the following files once you extract Marathon:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 解压 Marathon 后，你将看到以下文件：
- en: '![Installing Marathon](img/B05186_04_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Marathon](img/B05186_04_01.jpg)'
- en: There is a development mode for Marathon in which you don't need a distributed
    Mesos setup. This is called the Marathon local mode. The local mode is for experimental
    purposes only, and it is not recommended to run it in any production environment.
    ZooKeeper is required alongside Marathon to store the state.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Marathon 有一个开发模式，在该模式下你不需要分布式 Mesos 设置。这被称为 Marathon 本地模式。本地模式仅用于实验目的，不建议在任何生产环境中运行。ZooKeeper
    和 Marathon 一起使用，用于存储状态。
- en: Installing ZooKeeper to store the state
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 ZooKeeper 以存储状态
- en: 'Marathon requires you to have an Apache ZooKeeper instance up and running for
    it to be able to save a state. Perform the following steps to install and work
    with ZooKeeper:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Marathon 要求你运行一个 Apache ZooKeeper 实例，以便它能够保存状态。按照以下步骤安装并使用 ZooKeeper：
- en: Visit [https://zookeeper.apache.org](https://zookeeper.apache.org) to download
    the latest version of ZooKeeper. At the time of writing this book, the current
    version is 3.4.7.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://zookeeper.apache.org](https://zookeeper.apache.org) 下载 ZooKeeper
    的最新版本。编写本书时，当前版本是 3.4.7。
- en: 'Download ZooKeeper as follows:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下所示下载 ZooKeeper：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After downloading, extract the archive as given here:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载后，按如下方式解压归档文件：
- en: '[PRE3]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next step is to configure ZooKeeper. This can be done as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是配置 ZooKeeper。可以按如下方式完成：
- en: 'Edit the file `conf/zoo.cfg` with the following contents:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用以下内容编辑 `conf/zoo.cfg` 文件：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, run the following command to start ZooKeeper:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行以下命令来启动 ZooKeeper：
- en: '[PRE5]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can see the following messages once you start it successfully:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 启动成功后，你可以看到以下消息：
- en: '![Installing ZooKeeper to store the state](img/B05186_04_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![安装 ZooKeeper 以存储状态](img/B05186_04_02.jpg)'
- en: Launching Marathon in local mode
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在本地模式下启动 Marathon
- en: 'The following command launches Marathon in local mode:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将启动 Marathon 本地模式：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Launching Marathon in local mode](img/B05186_04_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![在本地模式下启动 Marathon](img/B05186_04_03.jpg)'
- en: Once it is up and running, the Marathon UI can be seen by pointing your browser
    to the `8080` port on the server.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 ZooKeeper 启动并运行，你可以通过浏览器访问服务器上的 `8080` 端口来查看 Marathon UI。
- en: Multi-node Marathon cluster setup
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多节点 Marathon 集群设置
- en: To set this up, a high availability Mesos cluster needs to be set up, which
    will be explained in detail in [Chapter 5](ch05.html "Chapter 5. Mesos Cluster
    Deployment"), *Mesos Cluster Deployment*. For the time being, we assume that you
    already have a high availability Mesos cluster up and running. We'll now take
    a look at how to install Marathon on all the master machines in the cluster.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置此环境，需要配置一个高可用性的 Mesos 集群，详细内容将在[第 5 章](ch05.html "第 5 章. Mesos 集群部署")中解释，*Mesos
    集群部署*。目前我们假设你已经配置好了高可用性的 Mesos 集群。接下来，我们将看看如何在集群的所有主机上安装 Marathon。
- en: Log in to all the Mesos master machines and type in the following commands to
    set up Marathon.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到所有 Mesos 主机，并输入以下命令来设置 Marathon。
- en: 'On *Debain*/*Ubuntu* machines, run the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Debian*/*Ubuntu* 系统上，运行以下命令：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On *RedHat*/*CentOS* machines, execute the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *RedHat*/*CentOS* 系统上，执行以下命令：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can now head to any one of the master machine''s `8080` port in the browser
    and take a look at the Marathon UI:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在浏览器中访问任何一个主机的 `8080` 端口，并查看 Marathon UI：
- en: '![Multi-node Marathon cluster setup](img/B05186_04_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![多节点 Marathon 集群设置](img/B05186_04_04.jpg)'
- en: Launching a test application from the UI
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 UI 启动测试应用程序
- en: 'An application in Mesos is normally a long-running service that can be scaled
    to run on multiple instances. Now, we will look at the steps to launch a test
    application from the user interface:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mesos 中，应用程序通常是一个长时间运行的服务，可以扩展到多个实例。现在，我们将查看从用户界面启动测试应用程序的步骤：
- en: '![Launching a test application from the UI](img/B05186_04_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![从 UI 启动测试应用程序](img/B05186_04_05.jpg)'
- en: Click on the **+ Create** button in the upper-left corner.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左上角的 **+ 创建** 按钮。
- en: The **ID** can be used to identify the job. Let's name it `marathon-test`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ID** 可以用来标识任务。我们将其命名为 `marathon-test`。'
- en: Mention the number of CPUs that are required for the job—say, `1`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供作业所需的 CPU 数量——比如说，`1`。
- en: Memory is given in MBs, so we will give it `16` MB (which is also the default).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内存以 MB 为单位，因此我们将分配 `16` MB（这也是默认值）。
- en: The number of instances can be given as 1 for our test application.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实例数可以为我们的测试应用程序设置为 1。
- en: 'Write the following bash script in the text box under the command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令框下的文本框中编写以下 bash 脚本：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If everything is correct, you can see the **marathon-test** test application
    first with the **Deployed** status, which will finally change to **Running**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正确，你会首先看到 **marathon-test** 测试应用程序，状态为 **已部署**，最终会变为 **运行中**。
- en: '![Launching a test application from the UI](img/B05186_04_06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![从 UI 启动测试应用程序](img/B05186_04_06.jpg)'
- en: Scaling the application
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展应用程序
- en: At the time of creation, we gave `1` as the instance. We can modify the number
    of instances by clicking on the Scale Application button from the UI. The application
    will be scaled by launching it on the number of instances specified.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时，我们给出了 `1` 作为实例数。我们可以通过点击 UI 上的“扩展应用程序”按钮来修改实例数量。应用程序将按指定的实例数量启动。
- en: '![Scaling the application](img/B05186_04_07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![扩展应用程序](img/B05186_04_07.jpg)'
- en: Terminating the application
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终止应用程序
- en: We can now terminate our marathon-test application by clicking on the application
    name from the Applications list and then hitting the **Destroy** button.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过点击应用程序列表中的应用程序名称，然后点击 **销毁** 按钮来终止我们的 marathon-test 应用程序。
- en: '![Terminating the application](img/B05186_04_08.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![终止应用程序](img/B05186_04_08.jpg)'
- en: Destroying the application is an irreversible process and cannot be undone.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 销毁应用程序是一个不可逆的过程，无法撤销。
- en: '![Terminating the application](img/B05186_04_09.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![终止应用程序](img/B05186_04_09.jpg)'
- en: Chronos as a cluster scheduler
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chronos 作为集群调度器
- en: One can consider Chronos as a time-based job scheduler, such as **cron** in
    the typical Unix environment. Chronos is distributed and fully fault-tolerant,
    and it runs on top of Apache Mesos.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 Chronos 看作一个基于时间的作业调度器，例如典型 Unix 环境中的 **cron**。Chronos 是分布式的，完全容错，并且运行在
    Apache Mesos 之上。
- en: Just like cron, Chronos executes the shell scripts (combined with Linux commands)
    by default and also supports Mesos executors.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与 cron 类似，Chronos 默认执行 shell 脚本（结合 Linux 命令），并且支持 Mesos 执行器。
- en: Chronos can interact with systems such as Hadoop or Kafka even if the Mesos
    worker machine, on which the real execution happens, does not have the system
    installed. You can use Chronos to start a service or run a script on a remote
    machine in the background. The wrapper script can have an asynchronous callback
    to alert Chronos to the job status, such as whether it is completed or failed
    and so on. For the most part, people use Chronos to run dockerized applications.
    A detailed explanation of *dockerized applications* is provided in [Chapter 7](ch07.html
    "Chapter 7. Mesos Containerizers"), *Mesos Containerizers*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 Mesos 工作节点（实际执行作业的机器）上没有安装该系统，Chronos 也可以与像 Hadoop 或 Kafka 这样的系统进行交互。你可以使用
    Chronos 在远程机器的后台启动服务或运行脚本。包装脚本可以包含异步回调，提醒 Chronos 作业状态，如是否完成或失败等。大多数情况下，人们使用 Chronos
    来运行 Docker 化的应用程序。关于 *Docker 化应用程序* 的详细解释，请参见 [第 7 章](ch07.html "第7章。Mesos 容器化器")，*Mesos
    容器化器*。
- en: Chronos comes with a Web UI in which you can see the job status, statistics
    of the job's history, job configurations, and retries.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Chronos 附带一个 Web UI，你可以在其中查看作业状态、作业历史统计、作业配置以及重试信息。
- en: Installing Chronos
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Chronos
- en: Log in to any of the machines (let's say, one of the Mesos master machines)
    and type in the following commands to set up Chronos.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到任何一台机器（比如说其中一台 Mesos 主机），然后输入以下命令来设置 Chronos。
- en: 'On *Debain*/*Ubuntu* machines, run the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *Debian*/*Ubuntu* 机器上，运行以下命令：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'On *RedHat*/*CentOS* machines, execute the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *RedHat*/*CentOS* 机器上，执行以下代码：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once the installation is complete, you can point the browser to the machine''s
    `4400` port to see the Chronos UI, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以将浏览器指向机器的 `4400` 端口来查看 Chronos 的 UI，如下所示：
- en: '![Installing Chronos](img/B05186_04_10.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Chronos](img/B05186_04_10.jpg)'
- en: Scheduling a new job
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调度一个新作业
- en: 'Let''s follow the steps mentioned here to schedule a new job:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这里提到的步骤调度新作业：
- en: Click on the **+ New Job** button, as seen in the previous screenshot.![Scheduling
    a new job](img/B05186_04_11.jpg)
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **+ 新建作业** 按钮，如前一截图所示。![调度新作业](img/B05186_04_11.jpg)
- en: Now, fill in the **NAME** and **DESCRIPTION** fields.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，填写 **名称** 和 **描述** 字段。
- en: '**COMMAND** is the actual job that will be scheduled to run on the executors.
    For the sake of simplicity, we will simply run the `sleep` command.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**COMMAND** 是将实际调度在执行器上运行的任务。为了简化起见，我们将仅运行 `sleep` 命令。'
- en: In the **OWNER(S)** field, we can fill in the name and e-mail address to which
    Chronos will send an alert mail in the case of any job failure.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **OWNER(S)** 字段中，我们可以填写名称和电子邮件地址，以便 Chronos 在任务失败时向其发送警报邮件。
- en: Under **SCHEDULE**, we can put in the scheduling frequency at which the job
    should run. By default, it is empty and infinity. We can set it to any numeric
    value. For instance, the number of repetitions when the value is set to 0 is only
    one.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **SCHEDULE** 下，我们可以设置任务应该运行的调度频率。默认情况下，它是空的并且是无限的。我们可以将其设置为任何数字值。例如，当值设置为
    0 时，重复次数仅为一次。
- en: 'Once the job is created, we can see the summary of the job through the UI,
    as shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦任务创建成功，我们可以通过 UI 查看任务的摘要，如下图所示：
- en: '![Scheduling a new job](img/B05186_04_12.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![调度新任务](img/B05186_04_12.jpg)'
- en: 'The state of the job can also be seen as in the following screenshot. In this
    case, we can note that the **chronos-test** job is in the **running** state:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 任务的状态也可以在以下截图中查看。在这种情况下，我们可以看到 **chronos-test** 任务处于 **运行中** 状态：
- en: '![Scheduling a new job](img/B05186_04_13.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![调度新任务](img/B05186_04_13.jpg)'
- en: We can head to the Mesos UI (running on the port `5050`) and actually see the
    task being spawned by Chronos.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以前往 Mesos UI（运行在 `5050` 端口上），实际查看由 Chronos 启动的任务。
- en: '![Scheduling a new job](img/B05186_04_14.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![调度新任务](img/B05186_04_14.jpg)'
- en: Chronos plus Marathon
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chronos 加 Marathon
- en: The combination of Chronos and Marathon can be utilized as building blocks to
    create production-ready distributed applications. You already know that Chronos
    can be used to fire up tasks at scheduled intervals; cron and Marathon let your
    jobs run continuously, such as `init` or `upstart`, in typical Linux environments.
    As mentioned before, both the schedulers come with a REST endpoint that allows
    the user to manage the jobs. You can use this endpoint to start, manage, and terminate
    the running jobs. We will now take a look at how this is achieved.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Chronos 和 Marathon 的结合可以作为构建生产级分布式应用程序的基础。你已经知道 Chronos 可以在预定的时间间隔触发任务；cron
    和 Marathon 让你的任务能够持续运行，例如在典型的 Linux 环境中的 `init` 或 `upstart`。如前所述，两个调度器都提供 REST
    端点，允许用户管理任务。你可以使用这个端点来启动、管理和终止运行中的任务。接下来我们将看看这是如何实现的。
- en: The Chronos REST API endpoint
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chronos REST API 端点
- en: 'As mentioned before, you can communicate with Chronos using the REST JSON API
    over HTTP. By default, those nodes that have Chronos up and running listen at
    the `8080` port for API requests. This section covers how to perform the following
    tasks using the REST endpoint:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可以通过 HTTP 使用 REST JSON API 与 Chronos 进行通信。默认情况下，运行 Chronos 的节点会在 `8080`
    端口监听 API 请求。本节将介绍如何使用 REST 端点执行以下任务：
- en: Listing the running jobs
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出正在运行的任务
- en: Manually starting a job
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手动启动任务
- en: Adding a scheduled job
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个调度任务
- en: Deleting a job
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除任务
- en: For more information, visit [http://mesos.github.io/chronos/docs/api.html](http://mesos.github.io/chronos/docs/api.html).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多信息，请访问 [http://mesos.github.io/chronos/docs/api.html](http://mesos.github.io/chronos/docs/api.html)。
- en: Listing the running jobs
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出正在运行的任务
- en: Using the `HTTP GET` method on `/scheduler/jobs` will return a list of currently
    running jobs in the JSON format.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `HTTP GET` 方法请求 `/scheduler/jobs` 将返回当前正在运行的任务列表，格式为 JSON。
- en: 'Here''s an example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following data is present in the response:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 响应中包含以下数据：
- en: '`successCount`'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`successCount`'
- en: '`errorCount`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`errorCount`'
- en: '`lastSuccess`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastSuccess`'
- en: '`lastError`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lastError`'
- en: '`executor`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executor`'
- en: '`parents`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parents`'
- en: Manually starting a job
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动启动任务
- en: To start a job manually, send an `HTTP PUT` request to `/scheduler/job` with
    optional parameters that can be added at the end of the command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动启动任务，请向 `/scheduler/job` 发送 `HTTP PUT` 请求，并在命令的末尾添加可选参数。
- en: 'Take a look at the following example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adding a scheduled job
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个调度任务
- en: 'You can send an `HTTP POST` request to `/scheduler/iso8601` with the JSON data
    to schedule a job. The JSON data that you post to Chronos must contain the following
    fields:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向 `/scheduler/iso8601` 发送 `HTTP POST` 请求，并附带 JSON 数据来调度任务。发送给 Chronos 的 JSON
    数据必须包含以下字段：
- en: name
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称
- en: command
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: schedule
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: schedule
- en: The number of times to repeat the job;
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务的重复次数；
- en: Start time of the job in ISO 8601 format;
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务开始时间，采用 ISO 8601 格式；
- en: Standard ISO 8601 date time format
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准 ISO 8601 日期时间格式
- en: scheduleTimeZone
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: scheduleTimeZone
- en: epsilon
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: epsilon
- en: owner
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有者
- en: async
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步
- en: 'Take a look at the following example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Deleting a job
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除一个作业
- en: To delete jobs, you can use `HTTP DELETE` on `/scheduler/job/<jobName>`, where
    `jobName` can be obtained from the list of running jobs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除作业，你可以在`/scheduler/job/<jobName>`上使用`HTTP DELETE`请求，其中`jobName`可以从正在运行的作业列表中获取。
- en: 'Here''s an example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Deleting all the tasks of a job
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除作业的所有任务
- en: To delete all the tasks of a given job, you can use the `HTTP DELETE` request
    on `/scheduler/task/kill/<jobName>`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除某个作业的所有任务，你可以在`/scheduler/task/kill/<jobName>`上使用`HTTP DELETE`请求。
- en: 'Take a look at the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下示例：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Marathon REST API endpoint
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Marathon REST API 端点
- en: 'This section will cover the REST endpoint of Marathon. The following tasks
    can be performed:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将介绍 Marathon 的 REST 端点。可以执行以下任务：
- en: Listing the running applications.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出正在运行的应用程序。
- en: Adding an application.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个应用程序。
- en: Changing the configuration.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改配置。
- en: Deleting an application.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除一个应用程序。
- en: Listing the running applications
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出正在运行的应用程序
- en: You can hit the `/v2/apps` endpoint with the `HTTP GET` request to list the
    running applications that are deployed on Marathon. It also supports a filter
    that helps you limit the listing to a particular application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向`/v2/apps`端点发送`HTTP GET`请求，列出在 Marathon 上部署的正在运行的应用程序。该端点还支持一个过滤器，可以帮助你将列出内容限制到特定的应用程序。
- en: 'The following are the parameters that the endpoint takes:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是该端点所需的参数：
- en: '`cmd`: This filters the apps that contain the given command'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd`：用于过滤包含给定命令的应用程序'
- en: '`embed`: This can be used to specify multiple values multiple times, and it
    embeds the nested resources that match the supplied path'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`embed`：可以多次指定该参数，用于嵌入与提供的路径匹配的嵌套资源'
- en: 'Here''s an example:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can take a look at the response in a JSON format similar to the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看以下类似的 JSON 格式响应：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Adding an application
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个应用程序
- en: 'To create and start an application from the REST endpoint, you can use the
    `/v2/apps` endpoint with an `HTTP POST` request. It takes JSON data as the input,
    which contains information about the application. The following are the parameters
    that are required for this call:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 REST 端点创建并启动一个应用程序，你可以使用`/v2/apps`端点并发送一个`HTTP POST`请求。该请求需要传递包含应用程序信息的 JSON
    数据。以下是此调用所需的参数：
- en: '`id`: This is the name of the application'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：这是应用程序的名称'
- en: '`cmd`: This is the command to be executed'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cmd`：这是需要执行的命令'
- en: '`args`: These are optional arguments of the application'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`：这是应用程序的可选参数'
- en: '`cpus`: This is the number of CPU cores to be allocated for this application'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cpus`：这是为应用程序分配的 CPU 核心数量'
- en: '`mem`: This is the amount of memory to be allocated for the application'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mem`：这是为应用程序分配的内存大小'
- en: '`ports`: This is to be reserved for the application'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`：这是为应用程序预留的端口'
- en: '`instances`: This is the number of instances to deploy the application'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`instances`：这是部署应用程序的实例数量'
- en: 'The following example shows how to launch a simple Python HTTP server as an
    application in Marathon:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何在 Marathon 中启动一个简单的 Python HTTP 服务器作为应用程序：
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Also, note that if the given ID of the application already exists in Marathon,
    it will throw a duplication error and won't launch the application at all.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意如果给定的应用程序 ID 在 Marathon 中已经存在，将会抛出重复错误，并且应用程序根本不会启动。
- en: Changing the configuration of an application
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改应用程序的配置
- en: You can send an `HTTP PUT` request to the `/v2/apps/<appId>` endpoint to change
    the configuration of the given application. The `appId` value can be obtained
    using the previous method to list the running applications. Once the request is
    fired, the currently running tasks will be restarted with this new configuration.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以向`/v2/apps/<appId>`端点发送一个`HTTP PUT`请求，来更改给定应用程序的配置。`appId`值可以通过之前列出正在运行的应用程序的方法获取。一旦请求发送，当前运行的任务将会使用新的配置重启。
- en: It takes the `force` parameter, a Boolean value which is false by default. Making
    it true will override the current deployment if the application's state is affected.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受`force`参数，布尔值，默认为 false。将其设置为 true 会覆盖当前的部署，如果应用程序的状态受到影响的话。
- en: 'Consider the following example:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE20]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once the update succeeds, it will give us a JSON response containing the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更新成功，它将返回一个包含以下内容的 JSON 响应：
- en: '[PRE21]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Deleting the application
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除应用程序
- en: You can use the `HTTP DELETE` request in `/v2/apps/<appId>` to destroy the application
    and the data associated with it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`HTTP DELETE`请求在`/v2/apps/<appId>`端点销毁应用程序及其相关数据。
- en: 'Take a look at the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下示例：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Introduction to Apache Aurora
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache Aurora 介绍
- en: Apache Aurora is a powerful Mesos framework for long-running services, cron
    jobs, and ad hoc jobs. It was originally designed at Twitter and was later open
    sourced under the Apache license. You can turn your Mesos cluster to a private
    cloud using Aurora. Unlike Marathon, Aurora is responsible for keeping jobs running
    across a shared pool of resources over a long duration. If any of the machines
    in the pool fails, then Aurora can intelligently reschedule those jobs on other
    healthy machines in the pool.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Aurora 是一个强大的 Mesos 框架，适用于长期运行的服务、定时任务和临时任务。它最初在 Twitter 设计，后来根据 Apache
    许可证开源。你可以使用 Aurora 将 Mesos 集群转变为私人云。与 Marathon 不同，Aurora 负责在共享资源池中长时间运行任务。如果池中的任何机器出现故障，Aurora
    可以智能地将任务重新调度到其他健康的机器上。
- en: Aurora is not useful if you try to build an application with specific requirements
    for scheduling or if the job itself is a scheduler.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试构建一个具有特定调度需求的应用程序，或者如果任务本身就是一个调度器，那么 Aurora 将不适用。
- en: Managing long-running applications is one of the key features of Aurora. Apart
    from this, Aurora can be used to provide coarse-grained (that is, fixed) resources
    for your job so that at any point of time, the job always has a specified amount
    of resources. It also supports multiple users, and the configuration is templated
    with **DSL** (**Domain Specific Language**) to avoid redundancy in the configurations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 管理长期运行的应用程序是 Aurora 的关键功能之一。除此之外，Aurora 可以为你的任务提供粗粒度（即固定）的资源，以确保任务始终具有指定数量的资源。它还支持多个用户，且配置使用
    **DSL**（**领域特定语言**）模板化，以避免配置中的冗余。
- en: Installing Aurora
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Aurora
- en: 'Aurora jobs can be interacted with through the Aurora Web UI and the Aurora
    command-line utility. To install Aurora, we require the installation of `vagrant`.
    You can install `vagrant` with the following command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Aurora 任务可以通过 Aurora Web UI 和 Aurora 命令行工具进行交互。要安装 Aurora，需要安装 `vagrant`。你可以使用以下命令安装
    `vagrant`：
- en: '[PRE23]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Log in to any of the machines on the cluster and clone the Aurora repository
    with the following command:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到集群中的任何机器，使用以下命令克隆 Aurora 仓库：
- en: '[PRE24]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Change the working directory to Aurora, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 将工作目录更改为 Aurora，如下所示：
- en: '[PRE25]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, type in the following command to install Aurora on this machine:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入以下命令在此机器上安装 Aurora：
- en: '[PRE26]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `vagrant` command will use the configurations shipped with the Aurora distribution
    to install and start the Aurora services on the virtual machines. It will:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`vagrant` 命令将使用与 Aurora 分发版一起提供的配置，在虚拟机上安装并启动 Aurora 服务。它将：'
- en: Download the corresponding Linux virtual machine image
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载相应的 Linux 虚拟机镜像
- en: Configure and start the VM
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置并启动虚拟机
- en: Install Mesos and ZooKeeper on the VM along with the build tools
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚拟机上安装 Mesos 和 ZooKeeper 以及构建工具
- en: Compile the Aurora source and build it on the VM
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚拟机上编译并构建 Aurora 源代码
- en: Start the Aurora services on the VM
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在虚拟机上启动 Aurora 服务
- en: 'This process may take a couple of minutes to complete. If the command fails
    and complains about VirtualBox not being present on the machine, you can install
    it with the following command:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程可能需要几分钟才能完成。如果命令失败并提示机器上没有安装 VirtualBox，可以使用以下命令进行安装：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If everything goes well, you will see the following output on the Terminal:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将在终端看到以下输出：
- en: '![Installing Aurora](img/B05186_04_15.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Aurora](img/B05186_04_15.jpg)'
- en: Introduction to Singularity
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Singularity 介绍
- en: Singularity was originally designed at HubSpot and later open sourced under
    the Apache license. Singularity acts as an API and web application that can be
    used to launch and schedule long-running Mesos processes, scheduled jobs, and
    tasks. One can consider Singularity and the components that come with it as a
    **PaaS** (**Platform as a Service**) to the end users. A novice user can use Singularity
    to deploy tasks on Mesos without having to understand Mesos in detail.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Singularity 最初在 HubSpot 设计，后来根据 Apache 许可证开源。Singularity 作为一个 API 和 Web 应用程序，可以用于启动和调度长期运行的
    Mesos 进程、定时任务和任务。可以将 Singularity 及其组件视为一个**PaaS**（**平台即服务**）提供给最终用户。初学者可以使用 Singularity
    在 Mesos 上部署任务，而无需详细了解 Mesos。
- en: Singularity takes advantages of Apache Mesos features such as fault tolerance,
    scalability, and resource allocation, and runs as a task scheduler for Mesos frameworks.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Singularity 利用 Apache Mesos 的容错性、可扩展性和资源分配等功能，并作为 Mesos 框架的任务调度器运行。
- en: Installing Singularity
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Singularity
- en: Before installing Singularity, make sure you have Docker installed on your machine.
    If you haven't installed it yet, you can do so by following the steps mentioned
    in the official website at [https://docs.docker.com](https://docs.docker.com).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装 Singularity 之前，确保你的机器上已经安装了 Docker。如果还没有安装，你可以通过访问 [https://docs.docker.com](https://docs.docker.com)
    上的官方文档来安装。
- en: 'The first step is to clone the Singularity repository, which can be done as
    follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是克隆 Singularity 仓库，操作如下：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, change the working directory to Singularity, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将工作目录切换到 Singularity，如下所示：
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once you have Docker and Docker Compose installed successfully, you can use
    the Docker Compose `pull` and `up` commands to try Singularity. The commands will
    set up the following in the container for you:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功安装了 Docker 和 Docker Compose，你可以使用 Docker Compose 的 `pull` 和 `up` 命令来尝试 Singularity。这些命令将为你在容器中设置以下内容：
- en: The Mesos master and slave
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesos 主节点和从节点
- en: ZooKeeper
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZooKeeper
- en: Singularity
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 奇点
- en: The Baragon service and Agent
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Baragon 服务和代理
- en: 'If you wish to install singularity without Docker, the following steps can
    help you do so:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在没有 Docker 的情况下安装 Singularity，以下步骤可以帮助你完成安装：
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once this is done, you can see the Singularity jars being created under the
    `SingularityService/target` directory.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你可以看到 Singularity jars 被创建在 `SingularityService/target` 目录下。
- en: '![Installing Singularity](img/B05186_04_16.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Singularity](img/B05186_04_16.jpg)'
- en: We will use **SingularityService-0.4.6-SNAPSHOT-shaded.jar** to run Singularity.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 **SingularityService-0.4.6-SNAPSHOT-shaded.jar** 来运行 Singularity。
- en: Creating a Singularity configuration file
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Singularity 配置文件
- en: Singularity configurations are kept in a YAML file. A sample YAML configuration
    file is explained here.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Singularity 配置保存在 YAML 文件中。这里将解释一个示例的 YAML 配置文件。
- en: 'The port `7099` is used to run `SingulartiyService`, and the logs will be kept
    in `/var/log/singularity-access.log`. Take a look at the following code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 端口 `7099` 用于运行 `SingulartiyService`，日志将保存在 `/var/log/singularity-access.log`
    中。请查看以下代码：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Save the preceding configuration as `singularity_config.yaml` and use the following
    command to start Singularity:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述配置保存为 `singularity_config.yaml`，并使用以下命令启动 Singularity：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If everything goes well, you will see the Singularity framework appearing in
    the Mesos UI under the frameworks tab, as in the following screenshot:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将在 Mesos UI 的框架标签下看到 Singularity 框架，如下图所示：
- en: '![Creating a Singularity configuration file](img/B05186_04_17.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Singularity 配置文件](img/B05186_04_17.jpg)'
- en: You can point the browser to the following URL to access the Singularity UI
    to `http://ServerIPAddress:7099/singularity/`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将浏览器指向以下 URL 来访问 Singularity 的 UI：`http://ServerIPAddress:7099/singularity/`。
- en: '![Creating a Singularity configuration file](img/B05186_04_18.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Singularity 配置文件](img/B05186_04_18.jpg)'
- en: Service discovery using Marathoner
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Marathoner 的服务发现
- en: Modern distributed applications require a way to communicate with each other,
    which means that one application should know the presence of the other application
    when they are on the same network. This is called service discovery. In this section,
    we will take a look at the service discovery of web services that run on Marathon.
    One can adopt this approach for most of the stateless applications running on
    top of Marathon.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现代分布式应用程序需要一种相互通信的方式，这意味着当它们在同一网络上时，一个应用程序应该知道另一个应用程序的存在。这就是服务发现。在本节中，我们将查看在
    Marathon 上运行的 Web 服务的服务发现。你可以采用这种方法来处理大多数在 Marathon 上运行的无状态应用程序。
- en: We will use the combination of the popular HAProxy TCP/HTTP load balancer along
    with Marathon's REST API script, which was covered in the previous topics, to
    regenerate the configuration file of HAProxy for the service discovery of Marathon
    applications. When a task is spawned on one of the Mesos slaves, they are configured
    to bind the port to an arbitrary one within the default range of 31,000-32,000.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将结合流行的 HAProxy TCP/HTTP 负载均衡器和 Marathon 的 REST API 脚本（在之前的主题中已覆盖），重新生成 HAProxy
    配置文件，以实现 Marathon 应用程序的服务发现。当任务在某个 Mesos 从节点上启动时，它们会配置为将端口绑定到默认范围 31,000-32,000
    内的一个任意端口。
- en: Service discovery lets the applications running on Marathon communicate with
    others running alongside Marathon through their configured Marathon application
    port. For example, you can consider a Python web application that runs on port
    80, which can communicate with its Java backend running on port `8080` by connecting
    to `localhost:8080`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 服务发现使得在 Marathon 上运行的应用程序可以通过它们配置的 Marathon 应用程序端口与其他应用程序进行通信。例如，你可以考虑一个运行在端口
    80 上的 Python Web 应用程序，它可以通过连接到 `localhost:8080` 来与其在端口 `8080` 上运行的 Java 后端进行通信。
- en: HAProxy can route the request that it gets to the actual port and host where
    the instance of the service is running. If, for some reason, it fails to connect
    to the given host and port, it will try to connect to the next instance where
    it is configured to run the service.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: HAProxy 可以将它收到的请求路由到实际运行服务实例的端口和主机。如果由于某种原因，它未能连接到给定的主机和端口，它将尝试连接到下一个配置运行该服务的实例。
- en: We will use the HAProxy-Marathon-bridge shell script, which is provided with
    Marathon, to connect to Marathon and retrieve the hostnames, the ports that the
    running applications are bound to, and the configured application ports. This
    script is scheduled to run every 60 seconds through a cron. The script basically
    checks whether the configuration it generated in the previous run differs from
    the current configuration and reloads the new configuration in HAProxy if it detects
    a change. Note that we don't have to restart HAProxy.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 HAProxy-Marathon-bridge shell 脚本，该脚本是 Marathon 提供的，用于连接到 Marathon 并检索主机名、运行中的应用程序绑定的端口以及配置的应用程序端口。该脚本每
    60 秒通过 cron 调度运行一次。该脚本基本上检查它在上次运行中生成的配置与当前配置是否有所不同，如果检测到变化，则重新加载新的配置到 HAProxy
    中。请注意，我们不需要重新启动 HAProxy。
- en: The following is a graphical representation of two services, SVC1 and SVC2,
    running in a cluster, in which they are configured with the applications to run
    on ports 1111 and 2222, respectively. The Mesos-allocated tasks ports are `31100`
    and `31200`, respectively. Note that it is the responsibility of HAProxy to route
    the requests between the user-configured application port and the Mesos-allocated
    task ports.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个服务 SVC1 和 SVC2 在集群中运行的图示，它们分别配置了在端口 1111 和 2222 上运行的应用程序。Mesos 分配的任务端口分别是
    `31100` 和 `31200`。请注意，由 HAProxy 负责在用户配置的应用程序端口和 Mesos 分配的任务端口之间路由请求。
- en: '![Service discovery using Marathoner](img/B05186_04_19.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Marathoner 进行服务发现](img/B05186_04_19.jpg)'
- en: If, for example, SVC2 on Slave 2 tries to connect to SVC1 through `localhost:2222`,
    HAProxy will route the request to the configured SVC1 instance—that is, the one
    running on Slave1.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果从从节点 2 上的 SVC2 尝试通过 `localhost:2222` 连接到 SVC1，HAProxy 将把请求路由到配置的 SVC1 实例——即运行在从节点
    1 上的实例。
- en: '![Service discovery using Marathoner](img/B05186_04_20.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Marathoner 进行服务发现](img/B05186_04_20.jpg)'
- en: In case Slave 1 goes down, then requests to `localhost:2222` will be routed
    to Slave 2.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从节点 1 出现故障，则对 `localhost:2222` 的请求将被路由到从节点 2。
- en: '![Service discovery using Marathoner](img/B05186_04_21.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Marathoner 进行服务发现](img/B05186_04_21.jpg)'
- en: Service discovery using Consul
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Consul 进行服务发现
- en: Mesos-consul is used to register and deregister services that run as Mesos tasks.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos-consul 用于注册和注销作为 Mesos 任务运行的服务。
- en: For example, if you have a Mesos task called `myapp`, then this program will
    register the application in Consul, which will expose DNS as `myapp.service.consul`.
    Consul also does the Mesos leader discovery through the `leader.Mesos.service.consul`
    DNS, which points to the active leader.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个名为 `myapp` 的 Mesos 任务，那么该程序将会在 Consul 中注册该应用程序，并将其 DNS 暴露为 `myapp.service.consul`。Consul
    还通过 `leader.Mesos.service.consul` DNS 进行 Mesos 主节点发现，该 DNS 指向当前活动的主节点。
- en: How is this different from other service discovery software?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这与其他服务发现软件有何不同？
- en: Mesos-dns is a project similar to Consul. In Mesos-dns, it polls Mesos to get
    information about the tasks, whereas with Consul, instead of exposing this information
    via a built-in DNS server, it populates the Consul Service discovery with this
    information. The services are then exposed by Consul through DNS and its REST
    endpoint.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Mesos-dns 是一个类似于 Consul 的项目。在 Mesos-dns 中，它轮询 Mesos 以获取任务信息，而在 Consul 中，信息不是通过内置的
    DNS 服务器暴露，而是通过 Consul 服务发现填充这些信息。然后，这些服务通过 DNS 和其 REST 端点由 Consul 暴露。
- en: Running Consul
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Consul
- en: You will have to change the values of the environment if your ZooKeeper and
    Marathon services are not registered in Consul. You can dockerize Consul, and
    it can be run via Marathon as well.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 ZooKeeper 和 Marathon 服务没有在 Consul 中注册，你需要更改环境变量的值。你可以将 Consul 容器化，并通过 Marathon
    运行它。
- en: 'Consul can be run in the following manner:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Consul 可以以以下方式运行：
- en: '[PRE33]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding code is an `HTTP POST` request hitting the Consul API endpoint
    with the following JSON data in the `Mesos-consul.json` file:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个 `HTTP POST` 请求，向 Consul API 端点发送以下 JSON 数据，位于 `Mesos-consul.json` 文件中：
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Given in the following table are the options supported with the command-line
    Mesos-consul utility:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了命令行工具 Mesos-consul 支持的选项：
- en: '| Option | Description |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 选项 | 描述 |'
- en: '| --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `version` | This prints the Mesos-consul version. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `version` | 这个命令会打印出 Mesos-consul 的版本。 |'
- en: '| `refresh` | This refers to the time between the refreshes of Mesos tasks.
    |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `refresh` | 这指的是 Mesos 任务刷新之间的时间间隔。 |'
- en: '| `Mesos-ip-order` | This is a comma-separated list that controls the order
    in which [github.com/CiscoCloud/Mesos-consul](http://github.com/CiscoCloud/Mesos-consul)
    searches for a task''s IP address. The valid options are `netinfo`, `Mesos`, `Docker`,
    and `host` (the default is `netinfo,Mesos,host`). |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `Mesos-ip-order` | 这是一个以逗号分隔的列表，控制 [github.com/CiscoCloud/Mesos-consul](http://github.com/CiscoCloud/Mesos-consul)
    查找任务 IP 地址的顺序。有效选项为 `netinfo`、`Mesos`、`Docker` 和 `host`（默认值为 `netinfo,Mesos,host`）。
    |'
- en: '| `healthcheck` | This is used to enable health checks for an HTTP endpoint.
    When this flag is enabled, it serves the health status on `127.0.0.1:24476`. |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `healthcheck` | 这个选项用于启用 HTTP 端点的健康检查。当启用此标志时，它会在 `127.0.0.1:24476` 提供健康状态。
    |'
- en: '| `healthcheck-ip` | This is the IP for the Health check service interface
    (the default is `127.0.0.1`). |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `healthcheck-ip` | 这是健康检查服务接口的 IP（默认值为 `127.0.0.1`）。 |'
- en: '| `healthcheck-port` | This is a port for the Health check service (the default
    is `24476`). |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `healthcheck-port` | 这是健康检查服务的端口（默认值为 `24476`）。 |'
- en: '| `consul-auth` | This is the authentication username and password (optional)
    separated by a colon. |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `consul-auth` | 这是用于身份验证的用户名和密码（可选），由冒号分隔。 |'
- en: '| `consul-ssl` | This uses HTTPS while communicating with the registry. |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `consul-ssl` | 这会在与注册表通信时使用 HTTPS。 |'
- en: '| `consul-ssl-verify` | This verifies certificates when connecting through
    SSL. |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `consul-ssl-verify` | 在通过 SSL 连接时验证证书。 |'
- en: '| `consul-ssl-cert` | Provides the path to an SSL certificate, which it can
    use to authenticate the registry server. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `consul-ssl-cert` | 提供 SSL 证书的路径，可用于身份验证注册表服务器。 |'
- en: '| `consul-ssl-cacert` | This provides the path to a CA certificate file that
    contains one or more CA certificates, which it can use to validate the registry
    server certificate. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `consul-ssl-cacert` | 这是 CA 证书文件的路径，包含一个或多个 CA 证书，可用于验证注册表服务器证书。 |'
- en: '| `consul-token` | This is a token for registry ACL. |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `consul-token` | 这是用于注册表 ACL 的令牌。 |'
- en: '| `heartbeats-before-remove` | This is the number of times that registration
    needs to fail before the task is removed from Consul (the default is `1`). |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `heartbeats-before-remove` | 这是在任务从 Consul 中移除之前，注册失败的次数（默认值为 `1`）。 |'
- en: '| `zk*` | This refers to the Mesos path location in ZooKeeper, the default
    being `zk://127.0.0.1:2181/Mesos`. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `zk*` | 这是 ZooKeeper 中 Mesos 路径的位置，默认值为 `zk://127.0.0.1:2181/Mesos`。 |'
- en: Load balancing with HAProxy
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HAProxy 进行负载均衡
- en: The HAProxy-Marathon-bridge script is shipped with the Marathon installation.
    You can also use Marathon-lb for the same. Both of these create a configuration
    file for HAProxy and a lightweight TCP/HTTP proxy by looking up the running tasks
    from Marathon's REST API.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: HAProxy-Marathon-bridge 脚本随 Marathon 安装一起提供。你也可以使用 Marathon-lb 来实现相同的功能。这两个工具都会通过查看
    Marathon 的 REST API 中正在运行的任务，来为 HAProxy 创建一个配置文件和一个轻量级的 TCP/HTTP 代理。
- en: HAProxy-Marathon-bridge is a simple script providing a minimum set of functionalities
    and is easier to understand for novice users. The latter one, Marathon-lb, supports
    advanced features such as SSL offloading, load balancing based on the VHost, and
    sticky connections.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: HAProxy-Marathon-bridge 是一个简单的脚本，提供最小的功能集，且对新手用户更易理解。后者，Marathon-lb，支持高级功能，如
    SSL 卸载、基于 VHost 的负载均衡和粘性连接。
- en: Creating the bridge between HAProxy and Marathon
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 HAProxy 和 Marathon 之间的桥接
- en: 'First, you need to create an HAProxy configuration from the running Marathon
    instance, which, by default, runs on port `8080` of the machine. You can use the
    HAProxy-Marathon-bridge script for this through the following syntax:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要从运行中的Marathon实例创建HAProxy配置，该实例默认运行在机器的`8080`端口。你可以通过以下语法使用HAProxy-Marathon-bridge脚本来实现这一点：
- en: '[PRE35]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that here we specified `localhost:8080` because we ran the Marathon instance
    and HAProxy on the same machine.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里我们指定了`localhost:8080`，因为我们在同一台机器上运行了Marathon实例和HAProxy。
- en: 'Once you generate the HAProxy configuration, you can simply reload HAProxy
    without interrupting the existing connections by running the following command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了HAProxy配置，你可以通过运行以下命令来简单地重新加载HAProxy，而不会中断现有的连接：
- en: '[PRE36]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can automate the configuration generation and reloading process using a
    typical cron job. If, for any reason, one of the nodes goes down during the reload
    process, HAProxy's health check will detect it and stop sending further traffic
    to this particular node.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用典型的cron作业自动化配置生成和重新加载过程。如果在重新加载过程中由于某种原因，某个节点发生故障，HAProxy的健康检查将检测到并停止向该节点发送进一步的流量。
- en: You don't have to create the trigger to reload the HAProxy configuration. The
    HAProxy-Marathon-bridge script already does this for you. It has HAProxy and a
    cron job that is triggered every minute to pull the configuration from Marathon
    servers and refresh HAProxy if it detects any changes from the previous version.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 你无需创建触发器来重新加载HAProxy配置。HAProxy-Marathon-bridge脚本已经为你完成了这项工作。它包含HAProxy和一个每分钟触发的cron作业，用来从Marathon服务器拉取配置，并在检测到与上一个版本的变化时刷新HAProxy。
- en: 'You can use the following command to do so:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令来实现：
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It will add the pings to Marathon per line in the `/etc/haproxy-Marathon-bridge/Marathons`
    file and the script will be installed at `/usr/local/bin/haproxy-Marathon-bridge`.
    You can find the cron job being installed under `/etc/cron.d/haproxy-Marathon-bridge`
    which will be triggered as root.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在`/etc/haproxy-Marathon-bridge/Marathons`文件中为Marathon每一行添加ping命令，并将脚本安装在`/usr/local/bin/haproxy-Marathon-bridge`。你可以在`/etc/cron.d/haproxy-Marathon-bridge`目录下找到安装的cron作业，该作业将在根用户下触发。
- en: Bamboo - Automatically configuring HAProxy for Mesos plus Marathon
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bamboo - 自动为Mesos加Marathon配置HAProxy
- en: Bamboo runs as a web daemon and automatically configures HAProxy for the web
    services deployed on Mesos and Marathon.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Bamboo作为Web守护进程运行，并自动为部署在Mesos和Marathon上的Web服务配置HAProxy。
- en: 'Bamboo comes with the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Bamboo包含以下内容：
- en: A Web UI to configure HAProxy **Access Control Limit** (**ACL**) rules for each
    of the Marathon applications
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Web UI，用于为每个Marathon应用程序配置HAProxy **访问控制限制**（**ACL**）规则。
- en: A REST endpoint to do the same
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个REST端点来实现相同功能
- en: A preconfigured HAProxy configuration file based on your template, with which
    you can customize your own template to enable SSL and interface for HAProxy stats
    or configure strategies for load balancing
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于你的模板的预配置HAProxy配置文件，你可以自定义自己的模板来启用SSL并设置HAProxy统计信息接口，或配置负载均衡策略。
- en: A Healthcheck endpoint if the Marathon application is configured with Healthchecks
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Marathon应用配置了健康检查，则会有一个健康检查端点。
- en: A stateless daemon, which enables scalability and horizontal replication
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态守护进程，支持可扩展性和水平复制
- en: No additional dependencies (as it is developed in Golang)
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无额外依赖（因为它是用Golang开发的）
- en: Integration with StatsD to monitor configuration reload events
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与StatsD集成，监控配置重新加载事件
- en: Bamboo can be deployed on each of the Mesos slaves with HAProxy. As Bamboo is
    primarily used for web services deployed on Mesos, the service discovery is as
    simple as connecting to the localhost or domain you assigned with the ACL rules.
    However, you can also deploy HAProxy and Bamboo on different machines, which means
    that you will have to load balance the HAProxy cluster.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Bamboo可以在每个Mesos从节点上与HAProxy一起部署。由于Bamboo主要用于部署在Mesos上的Web服务，因此服务发现就像连接到你为其分配了ACL规则的本地主机或域名一样简单。然而，你也可以将HAProxy和Bamboo部署在不同的机器上，这意味着你需要对HAProxy集群进行负载均衡。
- en: 'The following screenshot shows Bamboo and HAProxy interacting with the Mesos
    cluster through Marathon:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Bamboo和HAProxy通过Marathon与Mesos集群的交互：
- en: '![Bamboo - Automatically configuring HAProxy for Mesos plus Marathon](img/B05186_04_22.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![Bamboo - 自动为Mesos加Marathon配置HAProxy](img/B05186_04_22.jpg)'
- en: 'You can install Bamboo with the following commands:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令安装Bamboo：
- en: '[PRE38]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once you are done with the installation, point your browser to any of the machines
    where you installed Bamboo on the port `8000`, and you will be able see the Web
    UI as shown in the following screenshot:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，打开浏览器并访问你安装了 Bamboo 的任意一台机器上的端口 `8000`，你将看到如下截图所示的 Web UI：
- en: '![Bamboo - Automatically configuring HAProxy for Mesos plus Marathon](img/B05186_04_23.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![Bamboo - 自动配置 HAProxy 以支持 Mesos 和 Marathon](img/B05186_04_23.jpg)'
- en: You can configure the ACLs by clicking on the edit icon at the right-hand side
    end of your Marathon application.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击 Marathon 应用程序右侧的编辑图标来配置 ACLs。
- en: '![Bamboo - Automatically configuring HAProxy for Mesos plus Marathon](img/B05186_04_24.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![Bamboo - 自动配置 HAProxy 以支持 Mesos 和 Marathon](img/B05186_04_24.jpg)'
- en: 'The Bamboo command line accepts a `--config` switch to specify the JSON application
    configuration file''s location. You can find example configuration file templates
    under the config directory; `config/production.example.json` and `config/haproxy_template.cfg`
    are two of these. Now, take a look at the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Bamboo 命令行接受一个 `--config` 选项，用于指定 JSON 应用配置文件的位置。你可以在 config 目录下找到示例配置文件模板；`config/production.example.json`
    和 `config/haproxy_template.cfg` 就是其中的两个。现在，来看一下下面的代码：
- en: '[PRE39]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Bamboo maps the following environment variables to the corresponding Bamboo
    configurations. You can use these in the `production.json` file:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Bamboo 将以下环境变量映射到相应的 Bamboo 配置。你可以在 `production.json` 文件中使用这些配置：
- en: '| Environment Variable | Corresponds To |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 环境变量 | 对应的配置项 |'
- en: '| `MARATHON_ENDPOINT` | Marathon.Endpoint |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `MARATHON_ENDPOINT` | Marathon.Endpoint |'
- en: '| `MARATHON_USER` | Marathon.User |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `MARATHON_USER` | Marathon.User |'
- en: '| `MARATHON_PASSWORD` | Marathon.Password |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `MARATHON_PASSWORD` | Marathon.Password |'
- en: '| `BAMBOO_ENDPOINT` | Bamboo.Endpoint |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `BAMBOO_ENDPOINT` | Bamboo.Endpoint |'
- en: '| `BAMBOO_ZK_HOST` | Bamboo.Zookeeper.Host |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `BAMBOO_ZK_HOST` | Bamboo.Zookeeper.Host |'
- en: '| `BAMBOO_ZK_PATH` | Bamboo.Zookeeper.Path |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `BAMBOO_ZK_PATH` | Bamboo.Zookeeper.Path |'
- en: '| `HAPROXY_TEMPLATE_PATH` | HAProxy.TemplatePath |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| `HAPROXY_TEMPLATE_PATH` | HAProxy.TemplatePath |'
- en: '| `HAPROXY_OUTPUT_PATH` | HAProxy.OutputPath |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| `HAPROXY_OUTPUT_PATH` | HAProxy.OutputPath |'
- en: '| `HAPROXY_RELOAD_CMD` | HAProxy.ReloadCommand |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `HAPROXY_RELOAD_CMD` | HAProxy.ReloadCommand |'
- en: '| `BAMBOO_DOCKER_AUTO_HOST` | This sets the `BAMBOO_ENDPOINT` to `$HOST` when
    Bamboo container starts and can be any value |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `BAMBOO_DOCKER_AUTO_HOST` | 当 Bamboo 容器启动时，这将把 `BAMBOO_ENDPOINT` 设置为 `$HOST`，并且可以是任何值
    |'
- en: '| `STATSD_ENABLED` | StatsD.Enabled |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `STATSD_ENABLED` | StatsD.Enabled |'
- en: '| `STATSD_PREFIX` | StatsD.Prefix |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `STATSD_PREFIX` | StatsD.Prefix |'
- en: '| `STATSD_HOST` | StatsD.Host |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `STATSD_HOST` | StatsD.Host |'
- en: Introduction to Netflix Fenzo
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix Fenzo 介绍
- en: 'Netflix recently open sourced their scheduler library written in Java for Apache
    Mesos frameworks that supports scheduling optimizations and cluster autoscaling.
    At the time of writing the book, Fenzo is open sourced and is available in the
    official Netflix OSS suite repository, which can be found at the following URL:
    [https://github.com/Netflix/Fenzo](https://github.com/Netflix/Fenzo)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix 最近开源了他们为 Apache Mesos 框架编写的调度器库，该库使用 Java 编写，支持调度优化和集群自动扩展。在写书时，Fenzo
    已经开源，并且可以在官方的 Netflix OSS 套件仓库中找到，网址为：[https://github.com/Netflix/Fenzo](https://github.com/Netflix/Fenzo)
- en: There are basically two motivations for developing a framework such as Fenzo.
    Unlike other schedulers and frameworks discussed earlier, the reasons for building
    Fenzo are scheduling optimizations and autoscaling the cluster based on the usage.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 开发像 Fenzo 这样的框架基本上有两个动机。与前面讨论的其他调度器和框架不同，构建 Fenzo 的原因是为了调度优化和根据使用情况自动扩展集群。
- en: When there is a huge variation in the amount of data that your cluster handles
    from time to time, provisioning the cluster for peak usage seems wasteful as most
    of the time, the resources will be idle. This is the main reason behind autoscaling
    the application depending on the load—that is, providing more machines to increase
    the cluster resources when there is peak usage and shutting down these machines
    when they are idle.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的集群处理的数据量时常变化时，预配置集群以应对峰值使用看起来很浪费，因为大部分时间资源会处于闲置状态。这正是根据负载自动扩展应用程序的主要原因——即，在集群资源达到峰值时提供更多机器，并在机器闲置时关闭这些机器。
- en: Scaling the cluster up is an easier task. You can have monitoring tools to watch
    the resource utilization, and when it crosses a threshold, you can go ahead and
    add more resources to the cluster. On the other hand, while scaling down the cluster,
    you need to identify whether there are long-running tasks on the machines that
    you are about to terminate and also whether it will have any impact on the running
    tasks if you terminate the machine.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展集群是一个较为简单的任务。您可以使用监控工具来观察资源利用率，当它超过阈值时，可以继续增加集群资源。另一方面，在缩减集群时，您需要识别您将要终止的机器上是否有长期运行的任务，以及终止这些机器是否会影响正在运行的任务。
- en: 'Currently, autoscaling in Fenzo is based on the following two strategies:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Fenzo中的自动扩展基于以下两种策略：
- en: The threshold
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阈值
- en: Resource shortfall analysis
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源短缺分析
- en: In threshold-based autoscaling, users can specify rules as per the host group,
    such as EC2 Auto Scaling, GCE Auto Scaling, and so on. These can be considered
    as creating host groups to compute intensive, network-intensive, and other workloads.
    These rules let the new jobs be launched quickly on the preconfigured number of
    idle hosts.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于阈值的自动扩展中，用户可以根据主机组指定规则，如EC2自动扩展、GCE自动扩展等。这些可以视为为计算密集型、网络密集型及其他工作负载创建主机组。这些规则使得新的任务可以迅速启动在预配置的空闲主机上。
- en: In the case of resource shortfall analysis, it first calculates the number of
    hosts that are required to complete the pending workloads. One can also consider
    this as a predictive autoscaling system that can analyze the workload and spawn
    up new hosts to satisfy pending workloads. An example of such a system is the
    Netflix website's Scryer.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在资源短缺分析的情况下，它首先计算完成待处理工作负载所需的主机数量。也可以将其视为一种预测性自动扩展系统，可以分析工作负载并启动新的主机以满足待处理的工作负载。这样的系统的一个例子是Netflix网站的Scryer。
- en: The following is a diagram showing how Fenzo can be used by an Apache Mesos
    framework. Fenzo itself contains a task scheduler that provides the scheduling
    core without really interacting with Mesos. The framework interfaces with Mesos
    to get new resource offers and pull task status updates.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个图示，展示了Fenzo如何被Apache Mesos框架使用。Fenzo本身包含一个任务调度器，提供调度核心，但并不直接与Mesos交互。该框架与Mesos交互，以获取新的资源报价并拉取任务状态更新。
- en: '![Introduction to Netflix Fenzo](img/B05186_04_25.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![Netflix Fenzo介绍](img/B05186_04_25.jpg)'
- en: Introduction to PaaSTA
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PaaSTA简介
- en: 'The Yelp''s Platform-as-a-service distributed system PaaSTA is highly available
    and used to build, deploy, and run services using containers such as Docker and
    Apache Mesos. PaaSTA is designed and developed by Yelp and has been recently open
    sourced. You can take a look at the open sourced repository at the following URL:
    [https://github.com/yelp/paasta](https://github.com/yelp/paasta)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Yelp的PaaSTA（平台即服务）分布式系统具有高可用性，用于构建、部署和运行使用容器（如Docker和Apache Mesos）的服务。PaaSTA由Yelp设计和开发，并且最近已开源。您可以通过以下网址查看开源仓库：[https://github.com/yelp/paasta](https://github.com/yelp/paasta)
- en: This is a suite for developers to specify how they want their code from their
    Git repository to be built, deployed, routed, and monitored. Yelp has used PaaSTA
    for more than a year to power its production-level services. PaaSTA is best suited
    if you have a strict production environment, such as Yelp, which requires many
    tiny microservices and where rolling out a new piece of code should be seamless
    and not disturb production systems. PaaSTA helps automate this entire process.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个供开发人员指定如何从Git仓库构建、部署、路由和监控代码的工具集。Yelp已使用PaaSTA超过一年，以支持其生产级别的服务。如果您有严格的生产环境，例如Yelp，要求许多小型微服务，并且在推出新代码时应无缝进行且不打扰生产系统，PaaSTA最为适用。PaaSTA帮助自动化整个过程。
- en: 'It comprises the following existing open source components:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括以下现有的开源组件：
- en: '**Docker**: This is used to containerize the code'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：用于容器化代码'
- en: '**Apache Mesos**: This is used for execution and scheduling'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Mesos**：用于执行和调度'
- en: '**Marathon**: This is used to manage long-running applications'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Marathon**：用于管理长期运行的应用程序'
- en: '**Chronos**: This is used for scheduling purposes'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chronos**：用于调度目的'
- en: '**SmartStack**: This is used for service discovery and registration'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SmartStack**：用于服务发现和注册'
- en: '**Sensu**: This is used to monitor and alert'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sensu**：用于监控和警报'
- en: '**Jenkins**: This is used for continuous build and deployment (this is optional)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins**：用于持续构建和部署（这是可选的）'
- en: One of the many reasons to have all these components in one place is reusability.
    You can reuse any of these components to solve different problems in your distributed
    environment.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些组件集中在一起的原因之一是可重用性。你可以重用这些组件中的任何一个来解决分布式环境中的不同问题。
- en: A comparative analysis of different Scheduling/Management frameworks
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同调度/管理框架的比较分析
- en: This section will give you a brief comparison and use cases for the different
    scheduling frameworks that we discussed in this chapter.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要比较和介绍我们在本章中讨论的不同调度框架及其应用场景。
- en: Marathon is a PaaS built on Mesos to make sure the job will run forever even
    if few machines in the cluster go down. It can seamlessly handle the hardware
    and software failures and ensure the application is always running. These types
    of frameworks are useful in production environments where your application should
    always be running and available all the time—for example, a web server hosting
    a website. In such cases, you can deploy it as a Marathon application that will
    take care of all these aspects.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Marathon 是一个构建在 Mesos 上的 PaaS，确保即使集群中的部分机器出现故障，作业仍然能够永远运行。它可以无缝处理硬件和软件故障，确保应用程序始终在运行。这类框架在生产环境中非常有用，特别是当你的应用程序需要
    24/7 全天候运行并始终可用时——例如，托管网站的 Web 服务器。在这种情况下，你可以将其作为 Marathon 应用程序进行部署，后者会处理所有这些方面。
- en: Chronos can be considered as a distributed fault-tolerant replacement of the
    typical Linux cron jobs that are used to fire up scheduled jobs, take periodic
    backups, check the health of the system, and so on. Both Chronos and Marathon
    come with a Web UI and a REST endpoint for the management of jobs. We can write
    wrapper scripts around this and automate the application deployment and job scheduling
    rather than just using the Web UI.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Chronos 可以被视为典型 Linux cron 作业的分布式容错替代品，cron 作业通常用于启动定时任务、定期备份、检查系统健康状况等。Chronos
    和 Marathon 都提供了 Web UI 和 REST 端点来管理作业。我们可以围绕这些工具编写包装脚本，自动化应用程序部署和作业调度，而不仅仅依赖 Web
    UI。
- en: Aurora and Marathon are very similar in nature in the sense that both are service
    schedulers. All you have to do is tell Aurora or Marathon how to deploy the application,
    and they will keep them up and running without failures. Aurora, on the other
    hand, is a bit difficult to install and work with for a beginner. Unlike Marathon,
    it doesn't officially support a REST endpoint, which will be available soon. At
    this time, Aurora exposes a thrift API to make the communication, which means
    that there is an additional overhead of having to install thrift libraries on
    the server.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Aurora 和 Marathon 本质上非常相似，它们都是服务调度器。你所需要做的就是告诉 Aurora 或 Marathon 如何部署应用程序，它们会保持应用程序持续运行，不会出现故障。另一方面，Aurora
    对于初学者来说有点难以安装和使用。与 Marathon 不同，Aurora 并不正式支持 REST 端点，但很快会推出。在此之前，Aurora 通过暴露 Thrift
    API 来进行通信，这意味着你需要在服务器上额外安装 Thrift 库。
- en: Apache Aurora is designed to handle large-scale infrastructure, such as a datacenter.
    A typical example is the clusters running on Twitter that consist of thousands
    of machines and hundreds of engineers accessing and using them for development
    and production purposes.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Aurora 旨在处理大规模的基础设施，如数据中心。一个典型的例子是 Twitter 上运行的集群，这些集群由成千上万的机器组成，成百上千的工程师用来进行开发和生产。
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we dived deep into some of the most important frameworks for
    Mesos that make job scheduling and load balancing much easier and efficient. Frameworks
    such as Marathon and Chronos and their REST endpoints along with some other tools,
    such as HAProxy, Consul, Marathoner, Bamboo, Fenzo, and PaaSTA, were explained.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了一些 Mesos 的重要框架，这些框架使得作业调度和负载均衡变得更加容易和高效。我们介绍了如 Marathon 和 Chronos
    等框架，它们的 REST 端点，以及其他一些工具，如 HAProxy、Consul、Marathoner、Bamboo、Fenzo 和 PaaSTA。
- en: In the next chapter, we'll discuss how system administrators and DevOps professionals
    can deploy a Mesos cluster using standard tools such as Ansible, Chef, Puppet,
    Salt, Terraform, and Cloud formation along with monitoring it using Nagios and
    Satellite.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论系统管理员和 DevOps 专业人员如何使用 Ansible、Chef、Puppet、Salt、Terraform 和 CloudFormation
    等标准工具来部署 Mesos 集群，并利用 Nagios 和 Satellite 进行监控。
