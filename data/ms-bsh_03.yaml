- en: Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: We have stressed so far the importance of giving a structure to our scripts,
    to make them flexible, and to have them react to some conditions and situations
    so that they will help us automate some routine tasks making decisions and performing
    actions on our behalf. What we saw in the previous chapters enables us to assign
    variables, change their values in different ways, and also to preserve them; but
    from the examples shown, it is clear that we need some more and this is what this
    new chapter is all about. We will see how to test, make comparisons, and get to
    react accordingly to the results, and we will give our first structure to a script
    having to make a decision if something happens.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们强调了给脚本提供结构的重要性，使它们更具灵活性，并让它们响应一些条件和情况，以便帮助我们自动化某些日常任务，做出决策并代表我们执行操作。我们在前几章中所看到的使我们能够赋值变量，以不同的方式更改它们的值，并且还能够保存它们；但从展示的例子来看，我们需要更多的功能，而这正是本章的主题。我们将学习如何进行测试，做比较，并根据结果做出响应，我们将为脚本赋予第一个结构，当某些事情发生时做出决策。
- en: What if...else
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如果...否则
- en: 'Let''s take one of our previous examples and examine it in more detail:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以之前的一个例子为例，详细分析：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As an exercise to ease its comprehension, let''s try to write it in natural
    language:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个练习，帮助理解，让我们尝试将其写成自然语言：
- en: Print a greeting asking for a number between 10 and 20
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印一个问候语，要求输入一个 10 到 20 之间的数字
- en: Read the user input and save it in the `user_input` variable
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取用户输入并将其保存在 `user_input` 变量中
- en: If the value of `user_input` is greater or equal to `10` and the value of `user_input`
    is less or equal to `2`, then print an OK message to the user
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `user_input` 的值大于或等于 `10` 且 `user_input` 的值小于或等于 `2`，则打印一条 OK 消息给用户
- en: Otherwise (else), if the conditions are not met, print a not OK message
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则（else），如果条件不满足，打印一条不 OK 的消息
- en: '`Fi`, end of condition'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Fi` 条件结束'
- en: 'These are the basics of a conditional statement and it lets you explore on
    condition: if it succeeds, an instruction is executed, if it fails, another block
    of instructions is invoked. We can also make it a bit more flexible, introducing
    an alternative condition to check in case the first fails (`elif`):'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是条件语句的基础，它让你根据条件进行探索：如果成功，执行一条指令；如果失败，则调用另一块指令。我们还可以使它更灵活，介绍一个备用条件，在第一个条件失败时进行检查（`elif`）：
- en: '`if` the exit code of the condition tested is 0'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if` 测试条件的退出代码是 0'
- en: then
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后
- en: do something
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行某个操作
- en: '`elif` the exit code of this other condition tested is 0'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elif` 这个其他测试条件的退出代码是 0'
- en: do something
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行某个操作
- en: '`else if` any of the previous conditions returned 0'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`else if` 之前的任何条件返回 0'
- en: do something
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行某个操作
- en: '`fi` we exit from the conditional statement'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fi` 我们退出条件语句'
- en: 'So in this more articulated shape, the condition offers more flexibility and
    keep in mind that you can have as many `elif` blocks as you want and even nest
    `if` into `if`, even though it is not recommended for clarity''s sake. Now, let
    us make a real-life example with return codes, starting with the creation of three
    `test` files:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在这种更复杂的形式下，条件提供了更多的灵活性，记住，你可以有尽可能多的 `elif` 块，甚至将 `if` 嵌套在 `if` 中，尽管为了清晰起见不推荐这么做。现在，让我们通过返回代码来举一个实际生活中的例子，从创建三个
    `test` 文件开始：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, let us create a small script that will check for the existence of these
    three files:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个小脚本，检查这三个文件是否存在：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s run it and have a look at what happens:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行它并看看发生了什么：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What happened? The first `ls` on `test1` returned `0,` so it was successful
    and the conditional did not proceed testing the other options end exited the statement
    executing the next instruction outside the conditional and this was:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？第一次对 `test1` 执行 `ls` 返回了 `0`，所以它成功了，条件语句没有继续测试其他选项，而是退出了语句，执行了条件外的下一条指令，这就是：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now it is time to see what happens if the first condition encountered fails,
    so we are going to delete the `test1` file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看如果遇到第一个条件失败时会发生什么，因此我们将删除 `test1` 文件：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And execute the script again:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后再次执行脚本：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Again, what happened? The first instruction, `ls test1`, failed since there
    is no `test1` file left to show with `ls` and so the instruction returned `1`.
    The script then proceeded further into the conditional statement to the second
    condition, executing `ls test2`. In this case, since `file2` exists, the command
    returned `0` and the script exited the statement, executing the first instruction
    outside the conditional, again:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 还是发生了什么？第一条指令`ls test1`失败，因为没有`test1`文件可以用`ls`显示，因此该指令返回`1`。脚本然后进入条件语句的第二个条件，执行`ls
    test2`。在这种情况下，由于`file2`存在，命令返回`0`，脚本跳出了条件语句，执行了条件语句外的第一条指令：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let us go on, deleting `test2`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续，删除`test2`：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And now invoke the script:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用脚本：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since `test1` and `test2` do not exist, the first two `ls` fail and so the
    first two conditions with them, but not the third `ls` since `test3` still exists.
    The third `ls` then is successful and returns `0`, the script exits the conditional
    and executes the first instruction outside of it, again:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`test1`和`test2`不存在，前两个`ls`失败，因此前两个条件也失败，但第三个`ls`没有失败，因为`test3`仍然存在。第三个`ls`成功返回`0`，脚本退出条件语句，重新执行了条件语句外的第一条指令：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Final test, time to remove `test3`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次测试，是时候删除`test3`了：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And execute the script:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 并执行脚本：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It should be clear now what is going on. All the `if...then` conditions failed
    and so the last resort is the else sections, which report the exit code of the
    `lstest3`. Once this is done, the script exits the conditional and executes the
    first instruction outside of it, which is:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该清楚发生了什么。所有的`if...then`条件都失败了，因此最后的手段是`else`部分，它报告`lstest3`的退出代码。完成后，脚本退出条件语句，执行了条件语句外的第一条指令，重复如下：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Be aware that the overall exit status of a conditional statement is the one
    belonging to the last instruction executed and the overall exit code of the script
    is the one of the last instruction executed by the script itself:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，条件语句的总体退出状态是最后执行的指令的退出状态，而脚本的总体退出代码是脚本本身执行的最后一条指令的退出状态：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What we see here is the script returning a value of `0`, and this is correct
    since the last instruction executed `echo End of the script` was successful. Let''s
    now change the last instruction of the script with the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到这里脚本返回了`0`，这是正确的，因为最后执行的指令`echo End of the script`成功了。现在让我们将脚本的最后一条指令更改为：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The colon actually means *do nothing,* so let''s see:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号实际上意味着*什么也不做*，让我们看看：
- en: '[PRE16]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Again, `0`. Now, let's do an inverse check, modifying the third condition adding
    an `!`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 还是`0`。现在，让我们进行一次逆向检查，修改第三个条件，添加一个`!`。
- en: '[PRE17]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So, the check is successful if `ls test3` returns `1`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果`ls test3`返回`1`，则检查成功：
- en: '[PRE18]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Well, the message printed is a red herring since the execution of `ls test3`
    is not successful and cannot return `0`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，打印的消息其实是一个迷惑性信息，因为`ls test3`的执行不成功，不能返回`0`：
- en: '[PRE19]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What returns `0` is actually the check we made on the inverted condition:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上返回`0`的是我们对反向条件所做的检查：
- en: '[PRE20]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It can be read as the `if` condition is verified if `ls file3` is not verified.
    So, since for us verified is successful and successful is represented by a return
    value of `0`, the condition is verified (`0`) only if the `if ls file3` is not
    verified (`-ne 0`). So, be careful when using such conditions because you could
    incur in some unexpected results.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以理解为，只有当`ls file3`没有通过时，`if`条件才会被验证。因此，对于我们来说，验证是成功的，成功由返回值`0`表示，条件只有在`if
    ls file3`未通过时才会验证（`-ne 0`）。因此，在使用这样的条件时要小心，因为你可能会遇到一些意想不到的结果。
- en: 'We just saw how to check a condition one at a time, but we can combine operators
    in a single case check so that we can achieve more interesting results. Have a
    look at the following script:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到如何逐一检查条件，但我们可以在单个检查中结合运算符，以便获得更有趣的结果。看看下面的脚本：
- en: '[PRE21]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What we are doing here is testing three different conditions at the same time
    so the `if` will be verified only when the user inputs a number between `10` and
    `20` and it must be even. In other words, it must be divisible by 2 and we test
    it checking that the modulo of the value is `0`. Let''s try some values:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是同时测试三个不同的条件，因此只有当用户输入一个`10`到`20`之间的数字且必须是偶数时，`if`才会被验证。换句话说，它必须能被2整除，我们通过检查该值的模数是否为`0`来测试它。让我们尝试一些值：
- en: '[PRE22]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This number satisfied both the third and second conditions since it is even
    and lower than 20 but it fails the first since it is not equal to or above 10\.
    So, the `if` condition is not verified and `else` action is triggered:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字满足第三个和第二个条件，因为它是偶数且小于 `20`，但是不满足第一个条件，因为它不等于或大于 `10`。因此，`if` 条件不成立，触发了 `else`
    操作：
- en: '[PRE23]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now the number fails the first and third conditions and satisfies the first,
    it is not equal or above `10`, it is not even but it is less than `20`, so the
    else action is triggered.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个数字不满足第一个和第三个条件，但满足第二个条件，它不等于或大于 `10`，它不是偶数，但小于 `20`，因此触发了 `else` 块的操作。
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Number `10` is good. It satisfies the first and second conditions because it
    is equal to 10 and less than 20, and it satisfied the third condition because
    it is even, so the action in the `then` block is triggered.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 数字 `10` 是合适的。它满足第一个和第二个条件，因为它等于 `10` 且小于 `20`，并且满足第三个条件，因为它是偶数，因此触发了 `then`
    块的操作。
- en: '[PRE25]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this case, the first and second conditions are verified, but the third is
    not. `15` is not even, so the `else` block action is triggered:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第一个和第二个条件被验证，但第三个条件没有。`15` 不是偶数，因此触发了 `else` 块的操作：
- en: '[PRE26]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`20` is good, it is above `10`, equal to `20`, and we can divide it by `2`,
    so all  three conditions are verified and the `if` block action is triggered:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`20` 是合适的，它大于 `10`，等于 `20`，并且可以被 `2` 整除，因此所有三个条件都被验证，触发了 `if` 块的操作：'
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This number satisfies the first condition, being above `10`, but fails the
    other two since it is not equal to or below `20` and it is not even. So the else
    block action is triggered:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数字满足第一个条件，即大于 `10`，但不满足其他两个条件，因为它不是等于或小于 `20`，也不是偶数。因此触发了 `else` 块的操作：
- en: '[PRE28]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Not even this number is good. It satisfies the first condition, being above
    `10`, but fails the second since it is not equal to or below `20`. The third condition
    is satisfied, but this is not enough. So the else block action is triggered.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至这个数字也不合适。它满足第一个条件，即大于 `10`，但不满足第二个条件，因为它不是等于或小于 `20`。第三个条件满足，但这还不够。所以触发了 `else`
    块的操作。
- en: 'As we can see, when dealing with multiple conditions, we have to be really
    careful about what we write and think about the outcome since sometimes we could
    get something we did not actually want. A rule of thumb, try to keep your conditions
    as simple as you can or take your time to check them thoroughly. Did we say simple?
    Look at this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当处理多个条件时，我们必须非常小心我们写的内容并考虑结果，因为有时我们可能会得到我们实际上并不想要的结果。一个经验法则是，尽量保持条件的简单，或者花时间彻底检查它们。我们说简单吗？看看这个：
- en: '[PRE29]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We are using an arithmetic evaluation compound command and negate it to check
    whether a number is even: if it is not true that the modulo operation fails, then
    the condition is verified. But, look, we have no `else` block, we just evaluate
    the `if` condition and exit the conditional because we are not interested in reacting
    to any other cases. This is typical, for instance, counter exit conditions, as
    we saw before: we want to exit the loop if the counter reaches a specific value,
    otherwise we let the cycle run. Let''s have a look at the results:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个算术评估复合命令，并对其进行否定以检查一个数字是否为偶数：如果模运算不失败，那么条件就成立。但看， 我们没有 `else` 块，我们只是评估了
    `if` 条件并退出了条件语句，因为我们不关心对其他情况作出反应。这是典型的例子，比如计数器退出条件，就像我们之前看到的：我们希望当计数器达到特定值时退出循环，否则就让循环继续运行。让我们看看结果：
- en: '[PRE30]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The modulo operation does not give a result. Have a look at the return code
    of this operation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算没有给出结果。看看这个操作的返回代码：
- en: '[PRE31]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And here we are, the return code is `1`, which means it is not OK for us. So
    if a number passed through a modulo operation and gives `0`, the return code is
    failure and this means that dividing the number by two has no reminder. All this
    means that if a number is divisible for `2`; for example, it does not give us
    any reminder from the division, and it is even. Now, let us try an odd number:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 结果就是这样，返回代码是 `1`，这意味着对我们来说不合适。所以，如果一个数字通过模运算并得到 `0`，返回代码就是失败，这意味着将该数字除以二没有余数。这一切意味着，如果一个数字能被
    `2` 整除；例如，它不会给我们除法的余数，而且它是偶数。现在，让我们试试一个奇数：
- en: '[PRE32]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'No `then` block action is triggered, since this is an odd number. Let us verify
    it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 没有触发 `then` 块的操作，因为这是一个奇数。让我们验证一下：
- en: '[PRE33]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The operation is successful so we have to get some remainder. Double check:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 操作成功，所以我们必须得到一些余数。再检查一下：
- en: '[PRE34]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have `12` as a remainder of the division of `25` by `2`. So now the condition
    we saw in the previous script is clearer:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有 `12` 作为 `25` 除以 `2` 的余数。所以现在我们在之前的脚本中看到的条件更加清晰了：
- en: '[PRE35]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `if` statement is fulfilled if the modulo by two arithmetic operation fails.
    So, if a number is not divisible by `2` it is even, simple. Now it is time to
    take a look at how we can test our conditions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句会在模除二的算术操作失败时被满足。所以，如果一个数不能被 `2` 整除，它就是偶数，简单明了。现在是时候看看我们如何测试我们的条件了。'
- en: Test command recap
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试命令回顾
- en: 'As we have seen in some of our previous examples, we used the shell `built-in`
    test to perform some checks on variables and files along with the conditional
    `if...then` so that we could make our script react to conditions: if the test
    is successful it returns `0`, if it is not, `1`, and these are the values that
    triggered our reactions so far.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的一些例子中所看到的，我们使用了 shell 的 `built-in` 测试来对变量和文件进行一些检查，并结合条件语句 `if...then`
    使脚本能对条件作出反应：如果测试成功，它返回 `0`，如果失败，返回 `1`，这些值触发了我们到目前为止的反应。
- en: 'We can use a couple of different notations to execute a test and we already
    saw them:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用几种不同的符号来执行测试，我们已经看过这些：
- en: '[PRE36]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: or
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE37]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We already spoke about the differences between the two, but let us quickly
    recap them before proceeding:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了这两者之间的区别，但在继续之前，让我们快速回顾一下：
- en: The single bracket implements the standard POSIX compliant `test` command and
    it is available in all POSIX shells. `[` is actually a command whose argument
    is `],` and this prevents the single brackets from receiving further arguments.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单括号实现了标准的符合 POSIX 的 `test` 命令，并且在所有 POSIX shell 中都可用。`[` 实际上是一个命令，它的参数是 `]`，这会防止单括号接收更多的参数。
- en: Some Linux versions still have a `/bin/[` command, but the `built-in` version
    has the precedence in execution.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 Linux 版本仍然有 `/bin/[` 命令，但 `built-in` 版本在执行时具有优先权。
- en: The double brackets is only available in Bash, `zsh`, and `korn` shells.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双括号只在 Bash、`zsh` 和 `korn` shell 中可用。
- en: 'The double brackets is a keyword, not a program, available from the 2.02 version
    of the Bash and offers some great features, as follows:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双括号是一个关键字，不是一个程序，从 Bash 的 2.02 版本开始提供，并且具有一些很棒的功能，如下所示：
- en: The `=~` operator for regular expression matching
  id: totrans-104
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于正则表达式匹配的 `=~` 操作符
- en: The `=` or `==` are available for pattern matching
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=` 或 `==` 可以用于模式匹配。'
- en: You can use `<>` without having to escape the `\> \<`
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `<>` 而无需转义 `\> \<`。
- en: You can use `&&` instead of `-a` and `||` instead of `-o`
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 `&&` 替代 `-a`，使用 `||` 替代 `-o`。
- en: You do not need to escape the parenthesis `\( \)` to group expressions
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要转义括号 `\( \)` 来分组表达式。
- en: Glob expansion so a `*`can expand to everything, and this comes handy in pattern
    matching
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配符扩展，所以 `*` 可以扩展为任何内容，这在模式匹配中非常有用。
- en: You do not have to quote variables to keep safe spaces inside them
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不必引用变量以确保变量内部的空格安全。
- en: So, it seems that the double brackets gives us a bit of flexibility more than
    the old command, but before using it widely think about the audience of your scripts.
    If you want them available across different shells and, inside the same Bash,
    across different versions try to avoid using commands or built-ins that are only
    available in some of them. Sticking with the POSIX standard will make your scripts
    widely shareable, but as a drawback, they will lack the advanced features that
    some keywords such as double brackets have to offer. So, wisely balance your writing
    style and adopt the strategy that best matches your goals. We, when possible,
    will use the single bracket notation just to be as compatible as we can.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，看起来双括号给我们比旧命令多了一些灵活性，但在广泛使用之前，请考虑脚本的受众。如果你希望它们在不同的 shell 之间共享，并且在同一个 Bash
    中在不同版本之间共享，尽量避免使用只有部分版本可用的命令或内建命令。遵循 POSIX 标准会让你的脚本更加可共享，但作为缺点，它们缺乏一些关键字（如双括号）所提供的高级功能。因此，要明智地平衡你的写作风格，并采用最适合你目标的策略。我们在可能的情况下，会使用单括号符号，以确保尽可能的兼容性。
- en: Testing files
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试文件
- en: 'There is quite a lot to say about testing and one of the most common tasks
    is checking files on the filesystem or if a directory is available or has some
    rights. So, imagine a script that has to write some data in a file inside a directory:
    first, we should check whether the directory exists, then if we can write into
    it, and finally if there is no name collision between the file we are going to
    open for writing and an already existing file. So let''s have a look at which
    operators we use to execute some tests on files and devices and remember that
    they return `true` if the condition is met:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试有很多要说的，其中最常见的任务之一是检查文件系统中的文件或目录是否可用或具有某些权限。因此，想象一下一个需要在目录中写入一些数据的脚本：首先，我们应该检查目录是否存在，然后是否可以向其写入，最后检查我们将要打开以写入的文件与已存在的文件之间是否存在名称冲突。让我们看看我们用来执行一些文件和设备上测试的操作符，并记住它们在条件满足时返回
    `true`：
- en: '`-e`: Returns true if a file exists:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`: 如果文件存在，则返回 true：'
- en: '[PRE38]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We just verified that the file `test-files.sh` exists since `ls` shows it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚验证了文件 `test-files.sh` 的存在，因为 `ls` 显示了它：
- en: '[PRE39]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Our test confirms it with a nice message.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试确认了这一点，并显示了一个良好的消息。
- en: 'Let''s verify now that a file named `aaaaa` is not present in our current directory:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们验证一下，我们当前目录中没有名为 `aaaaa` 的文件：
- en: '[PRE40]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'OK, there is no file with such a name; let us do a test:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，没有这样名称的文件；让我们进行测试：
- en: '[PRE41]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Well, as you can see, we used a semicolon to divide the different parts of
    the statement. In a script, we would have seen the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，正如您所见，我们使用分号来分隔语句的不同部分。在脚本中，我们会看到以下内容：
- en: '[PRE42]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Each single command must be properly terminated either by a new line or a `;`.
    Each chunk of code delimited by a `;` will be executed before the following without
    the need for a new line.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的命令必须适当地以新行或 `;` 终止。在 `;` 分隔的代码块之前执行每个命令，而无需新行。
- en: '`-a`: This has the same purpose of `-e`, but it is deprecated.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`: 具有与 `-e` 相同的目的，但已弃用。'
- en: '`-b`: This checks whether the file is actually a block device, like a disk,
    a CD-ROM, or a tape device:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-b`: 这检查文件是否实际上是块设备，例如磁盘、CD-ROM 或磁带设备：'
- en: '[PRE43]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`-d`: This checks whether a file is actually a directory or not:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`: 这检查文件是否实际上是一个目录：'
- en: '[PRE44]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '`-f`: This checks whether a file is a regular file and does not represent something
    like a character device or a directory or a block device:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`: 检查文件是否为常规文件，而不是类似字符设备、目录或块设备的东西：'
- en: '[PRE45]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Well, this is a file that represents a terminal, so it is clearly not a regular
    file as `test.file` could be:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这是一个代表终端的文件，所以显然不是像 `test.file` 可能是的常规文件：
- en: '[PRE46]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`-c`: This tests if the argument is a character file:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-c`: 测试参数是否为字符文件：'
- en: '[PRE47]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`-s`: This is true if the file is not of `0` size:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`: 如果文件不为 `0` 大小，则为 true：'
- en: '[PRE48]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Well, we just *touched* the file, so we created it with `0` byte size. Let''s
    fill it with a character:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们刚刚 *touch* 了这个文件，所以创建了一个大小为 `0` 字节的文件。让我们用一个字符填充它：
- en: '[PRE49]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And now, let''s repeat the test:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重复测试：
- en: '[PRE50]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`-g`: This is true if the directory has a `sgid` flag set. As we saw, the set
    group ID imposed on a directory forces the files newly created into it to be owned
    by the group who owns the directory itself:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-g`: 如果目录设置了 `sgid` 标志，则为 true。正如我们所见，设置组 ID 在目录上强制新创建的文件归属于拥有该目录的组：'
- en: '[PRE51]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And now:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在：
- en: '[PRE52]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`-G`: This is true if the group ID is the same as that of yours. Let''s test
    on a file first:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-G`: 如果组 ID 与您的相同，则为 true。先在文件上进行测试：'
- en: '[PRE53]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And now on a directory:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在针对目录：
- en: '[PRE54]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s double-check changing the group owner of `test.file`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次验证更改 `test.file` 的组所有者：
- en: '[PRE55]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`-O`: This is true if you are the owner:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O`: 如果您是所有者，则为 true：'
- en: '[PRE56]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`-N`: This is true if the file was modified since the last read. This can become
    handy when you want to backup a file or just see if new information has been added.
    A typical scenario would be a log file or a data file being fed by a process,
    a service: if in a certain amount of time, the file has not been modified it probably
    means that the process is not running or not working properly so we can probably
    do something like restart it. So, let''s have a look at one of our previous scripts:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-N`: 如果文件自上次读取以来已修改，则为 true。当您想要备份文件或仅查看是否添加了新信息时，这可能会非常有用。典型的场景可能是一个由进程或服务馈送的日志文件或数据文件：如果在一定的时间内文件未被修改，则可能意味着该进程未运行或未正常工作，因此我们可以做一些像重新启动它的操作。让我们看看我们之前的某个脚本：'
- en: '[PRE57]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'OK, the files seems to have not been modified lately, so it is time to modify
    it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，看起来文件似乎最近没有修改过，所以现在是修改它的时候了：
- en: '[PRE58]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: That's it. Remember that in all the tests when we say that the test is true
    when the condition is verified, we imply a second condition that is the file must
    exist. So in this case, we would say, it is verified if the file exists and has
    not been modified from last read. Also remember that in Unix everything is a file,
    so a directory.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。请记住，在所有测试中，当我们说条件验证时测试为真时，我们暗示了第二个条件，即文件必须存在。所以在这种情况下，我们会说，如果文件存在且自上次读取后没有被修改，则验证通过。另外，请记住，在Unix中一切皆文件，包括目录。
- en: '`-u`: This is true if the `suid` bit is flagged. This kind of test can become
    quite useful for different reasons related to the fact that when you run an executable
    it usually runs with the privileges of the user who invoked it. With the `suid`
    bit flagged the executable is run with the privileges of the owner of that executable
    file not with the ones of the invoker also not with those of the one who invoked
    it. So, a program owned by root with the `suid` bit flagged can be a real harm
    to the security of a system since whoever invokes it has the root rights over
    the system itself. On the other side of the medal some programs, especially those
    that must have root rights to access a device, need to have the `suid` bit flagged
    because this allows a normal user to access the devices as root without having
    to access the full root environment:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-u`：如果设置了`suid`位，则为真。这种测试可以非常有用，原因有很多，尤其是因为当你运行一个可执行文件时，它通常会以调用它的用户的权限运行。而如果设置了`suid`位，该可执行文件将以该文件所有者的权限运行，而不是以调用者的权限运行。因此，带有`suid`位的root拥有的程序可能会对系统安全构成严重威胁，因为调用它的任何人都将获得root权限。另一方面，一些程序，尤其是那些必须拥有root权限才能访问设备的程序，必须设置`suid`位，因为这可以允许普通用户像root一样访问设备，而无需访问完整的root环境：'
- en: '[PRE59]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`-k`: This is true if the `sticky` bit is flagged. This kind of privilege is
    really interesting because if imposed on a file, it will have the file held in
    memory resulting in faster access, but applied to a directory it restricts the
    user rights: only the directory owner of the owner of the file inside a directory
    with a sticky bit set will be able to delete the file itself. This comes really
    handy in a collaborative environment where several users have their working file
    in the same directory, and applying the sticky bit on it will give the file owners
    the right to delete their files only:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-k`：如果设置了`sticky`位，则为真。这种权限非常有趣，因为如果它应用于文件，它会使文件保持在内存中，从而加速访问；但如果应用于目录，则限制用户权限：只有目录所有者或目录内文件的所有者，才能删除该文件。这在协作环境中非常有用，因为多个用户可以将工作文件放在同一目录中，并且对该目录应用sticky位后，只有文件所有者才能删除他们自己的文件：'
- en: '[PRE60]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`-r`: This is true if the read permission is set for the user executing the
    test:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`：如果为执行测试的用户设置了读取权限，则为真：'
- en: '[PRE61]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'So, the user can read the file, let''s check the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，用户可以读取文件，让我们检查接下来的内容：
- en: '[PRE62]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Oh, well, the file is owned by root and root has read access, so why was the
    test successful if the read is granted to root? Simple:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，文件由root拥有，并且root有读取权限，那么为什么测试在root有读取权限的情况下成功呢？很简单：
- en: '[PRE63]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: What happened? The first time we tried the test the owner was root, but the
    user `zarrelli` was still able to read the file through group permission and other
    permission. So, clearing those bits made the file readable only by the root user,
    no one else.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？第一次我们尝试测试时，所有者是root，但用户`zarrelli`仍然通过组权限和其他权限能够读取文件。因此，清除这些位使得文件只能由root用户读取，其他人无法访问。
- en: '`-w`: This is true if the write bit is set:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`：如果写入位被设置，则为真：'
- en: '[PRE64]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Interesting, let''s have a look at the file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣，让我们看看文件：
- en: '[PRE65]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Indeed, only the root user can write to it. Would you like to try and fix the
    issue then run the test again?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，只有root用户可以写入它。你想尝试修复问题然后再次运行测试吗？
- en: '`-x`: This is true if the execution bit is set:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x`：如果执行位被设置，则为真：'
- en: '[PRE66]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Let''s see what the access permissions on the file are:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看文件的访问权限：
- en: '[PRE67]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'So no execute bit for the user. Now, let''s test a directory:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所以没有给用户执行位。现在，我们来测试一个目录：
- en: '[PRE68]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Interesting, time to see the permissions on the directory:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣，是时候看看目录的权限了：
- en: '[PRE69]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'What are those dots and double dots? Let''s have a closer look:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 那些点和双点是什么？让我们仔细看看：
- en: '[PRE70]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Keep in mind the first column. These are the **inode** numbers related to `.`.
    and`..`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住第一列。这些是与` .`和`..`相关的**inode**编号：
- en: '[PRE71]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The inode of `.` inside the `test` directory has the value of `5900830`, so
    now we go up one directory, and we can see that the test directory has an inode
    value of `5900830`. So, we can safely say that `.`points to the directory we are
    in. And what about `..`? Look at the value of `.`in the parent directory, it is
    `5899440`. Now look inside the `test` directory to the value of `..`, it is `5899440,`
    and so we can safely say that`..`points to the parent directory since both point
    to the same inode.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`test` 目录中的 `.` 的 inode 值是 `5900830`，现在我们向上移动一层目录，我们可以看到 `test` 目录的 inode 值是
    `5900830`。所以我们可以安全地说，`.` 指向我们所在的目录。那么 `..` 呢？看看父目录中 `.` 的值，它是 `5899440`。现在看看 `test`
    目录中 `..` 的值，它是 `5899440`，因此我们可以安全地说，`..` 指向父目录，因为两者都指向相同的 inode。'
- en: 'Briefly, to understand what relates an inode to a file, we can say that in
    a Unix style file system, an inode is a metadata structure describing file and
    directories attributes, such as type timestamp, size, access rights, links count,
    and pointers to the disk block holding the data that make up a file or directory
    content. Each inode number is practically an index that allows the kernel to access
    a file or directory, its content and attributes, such as an index in an array.
    And actually, you can know quite a bit of a file if you know how to look at it:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，要理解 inode 与文件之间的关系，我们可以说，在 Unix 风格的文件系统中，inode 是一个元数据结构，描述文件和目录的属性，例如类型、时间戳、大小、访问权限、链接计数，以及指向磁盘块的指针，这些磁盘块存储构成文件或目录内容的数据。每个
    inode 编号实际上是一个索引，允许内核访问文件或目录及其内容和属性，就像数组中的索引一样。实际上，如果你知道如何查看文件，你可以了解它的很多信息：
- en: '[PRE72]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: So, what we can say is that something pointing to the same inode number is pointing
    to the same data structure, the same file or directory, and that is what links
    the `..` and `.`to the representation of the parent and local directory as we
    proved by following the inode numbers.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以说，指向相同 inode 编号的东西，指向的是相同的数据结构、相同的文件或目录，这就是将 `..` 和 `.` 链接到父目录和当前目录表示的原因，就像我们通过跟踪
    inode 编号所证明的那样。
- en: '`-h -L`: This is true if a file is a link. A link is a pointer to another file
    and you can have either a soft or hard link:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-h -L`：如果文件是链接，则此选项为真。链接是指向另一个文件的指针，您可以拥有软链接或硬链接：'
- en: A soft link is a reference to a file that can span across different filesystems.
    It is a special kind of file holding a reference to another file, so when the
    operating system tries to access the link, it recognizes it as a link and redirects
    all the operations to the actual file pointed by it. If the target is removed
    the link remains, but points to nothing. The main limits of a soft link is that
    it creates an overhead in the operations; the OS must redirect all the operations
    from it to the target.
  id: totrans-193
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号链接是指向文件的引用，可以跨越不同的文件系统。它是一种特殊类型的文件，保存对另一个文件的引用，因此当操作系统试图访问该链接时，它会将其识别为链接，并将所有操作重定向到实际的目标文件。如果目标文件被删除，链接仍然存在，但指向空值。符号链接的主要限制是它在操作中会产生额外的开销；操作系统必须将所有操作从符号链接重定向到目标文件。
- en: A hard link is another file pointing to the same inode and because inodes are
    a metastructure of a file system, a hard link cannot span across filesystems.
    Once the original file is deleted, the hard link is not affected since it points
    to a valid inode, which actually remains on the file system even if the file is
    deleted. A limit is that it cannot point to a directory.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬链接是指向相同 inode 的另一个文件，由于 inode 是文件系统的元结构，硬链接无法跨越文件系统。一旦原始文件被删除，硬链接不受影响，因为它指向一个有效的
    inode，而该 inode 即使文件被删除后仍然存在于文件系统中。一个限制是它不能指向目录。
- en: 'So, to make it easy, we can say that the soft link is a pointer by name to
    a file, whereas a hard link is a pointer by inode. Let''s see some differences
    in play starting with a soft link:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，为了简单起见，我们可以说符号链接是指向文件的名称指针，而硬链接是指向 inode 的指针。我们从一个软链接开始，看看一些实际差异：
- en: '[PRE73]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Let''s `cat` the link:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们 `cat` 链接：
- en: '[PRE74]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, let''s remove the original file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们删除原始文件：
- en: '[PRE75]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And verify if we can access the content through the link:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 并验证我们是否可以通过链接访问内容：
- en: '[PRE76]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The problem is clear with `ls`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ls` 可以清楚地看到问题：
- en: '[PRE77]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The link is still there, but the original file is gone, so when the OS tries
    to reach it, it fails. Let us recreate the original file and the link:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 链接仍然存在，但原始文件已经消失，因此当操作系统尝试访问它时，它会失败。让我们重新创建原始文件和链接：
- en: '[PRE78]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, let''s link across the `/boot` filesystem. First, let''s check that `/boot`
    is mounted on its own partition and filesystem:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们跨越 `/boot` 文件系统创建链接。首先，让我们检查 `/boot` 是否挂载在自己的分区和文件系统上：
- en: '[PRE79]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'OK, it is really another filesystem, so let''s soft link:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，它确实是另一个文件系统，所以让我们使用软链接：
- en: '[PRE80]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'And access the link:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后访问该链接：
- en: '[PRE81]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Well, something has gone wild. What is happening? Have a look with `ls -lah`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，似乎出了点问题。发生了什么？用 `ls -lah` 查看一下：
- en: '[PRE82]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Well, the link points to `test.file` in `/boot` even though we linked from
    another directory. We need an absolute reference:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，尽管我们从另一个目录进行了链接，但链接指向 `/boot` 中的 `test.file`。我们需要一个绝对引用：
- en: '[PRE83]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'And now it works. Finally, let''s see what happens if we try to link a directory:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它可以工作了。最后，让我们看看如果尝试链接一个目录会发生什么：
- en: '[PRE84]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We linked `new.test` to the `test` directory and now just check that the `test`
    directory is empty:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `new.test` 链接到 `test` 目录，现在只需检查 `test` 目录是否为空：
- en: '[PRE85]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now, let''s create a file using the link:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用链接创建一个文件：
- en: '[PRE86]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'And let''s see what is in test:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们看看 test 中有什么：
- en: '[PRE87]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here we are; we can reach the data inside test using the `new.test` soft link.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们可以通过 `new.test` 软链接访问 test 中的数据。
- en: 'Now it is time to hard link across filesystems:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候跨文件系统使用硬链接了：
- en: '[PRE88]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: No way! We cannot reference with a hard link across filesystems; the inode restriction
    is preventing us from doing it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不行！我们无法跨文件系统使用硬链接，因为 inode 限制阻止了我们这么做。
- en: 'Now, let''s try to link a directory:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试链接一个目录：
- en: '[PRE89]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Again, no good to go. Now, let us try to hard link in the same filesystem:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，无法继续。现在，让我们尝试在同一个文件系统中进行硬链接：
- en: '[PRE90]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'No problem, but let''s have a look at the inodes:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 没问题，但让我们看看 inode 情况：
- en: '[PRE91]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The hard link points to the same inode of the original file, the soft link
    does not. Now remove the original file again and try to `cat` the hard and soft
    link:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 硬链接指向原始文件的相同 inode，软链接则不指向。现在再次删除原始文件并尝试 `cat` 硬链接和软链接：
- en: '[PRE92]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'As we expected, the soft link failed because there is no filename to point
    to, the hard link succeeded because the inode is still there:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们预期的那样，软链接失败了，因为没有文件名可以指向，而硬链接成功了，因为 inode 仍然存在：
- en: '[PRE93]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'A quick rule of thumb is do not use soft link to reference frequently accessed
    files, such as web pages, use them for `config` files for instance, as they are
    just read at the startup. Soft links are slow. Hard links are good for referencing
    files and preserve their content despite what happens to the origin:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的经验法则是，不要使用软链接来引用频繁访问的文件，如网页。例如，可以将它们用于 `config` 文件，因为这些文件通常只在启动时读取。软链接比较慢。硬链接适合引用文件，并且能够保留其内容，无论原文件发生什么：
- en: '`-p`: This is true if the file is a pipe. Recall for a while what we said in
    the first chapter about pipes and named pipes; they are a way to get different
    processes to communicate between each other. If a process is spawned by a parent
    is not a big deal, they share the same environment and the same file descriptors,
    on the open descriptor of the parent process, the child will be able to read data
    in the same order it was written with a buffer kernel to host the bits waiting
    to be read. For processes that do not share a common environment we can use a
    pipe that leverages a file that the processes can cling to: this file can last
    longer than the processes that make use of it, usually until a reboot and can
    be deleted or redirected. These kinds of interprocess communication structures
    are called **named pipes** or **First In First Out** (**FIFO**) pipes, based on
    the order of the data processed. Let us make an example and create a pipe, either
    with `mkfifo` or `mknode`:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`：如果文件是管道，则为真。回想一下我们在第一章中关于管道和命名管道的内容；它们是让不同进程之间进行通信的一种方式。如果一个进程是由父进程生成的，这并不算什么大事，它们共享相同的环境和文件描述符。在父进程的打开描述符中，子进程将能够按写入顺序读取数据，使用缓冲区内核来保存等待读取的位。如果进程之间没有共享相同的环境，我们可以使用管道，它利用一个文件，进程可以依附在该文件上：该文件通常会比使用它的进程存在得更久，通常直到重启时才会被删除或重定向。这类进程间通信结构被称为
    **命名管道** 或 **先进先出** (**FIFO**) 管道，基于数据处理的顺序。让我们做个示例，创建一个管道，可以使用 `mkfifo` 或 `mknode`：'
- en: '[PRE94]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, let''s open a second terminal and issue, in the same directory, the command:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开第二个终端，并在相同目录下执行以下命令：
- en: '[PRE95]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The process will hang waiting for something to read. Now, let''s go back to
    the first terminal and write something to the named pipe:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 该进程将挂起，等待读取某些内容。现在，让我们回到第一个终端并向命名管道写入一些内容：
- en: '[PRE96]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now back to the second terminal to check what happened:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到第二个终端查看发生了什么：
- en: '[PRE97]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We will see more on named pipes in one of the next chapters, now we will just
    check if `myfifo` is really a named pipe:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中进一步了解命名管道，现在我们只需检查 `myfifo` 是否真的是一个命名管道：
- en: '[PRE98]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '`-S`: This is true if it is a socket. As we already saw, a socket is an endpoint
    between two devices on the same system or across the network and it allows the
    devices to exchange data, quite as we saw for pipes and named pipes. As you can
    easily guess, a Linux system has quite a bunch of sockets:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-S`：如果它是一个套接字，则返回为真。正如我们之前看到的，套接字是同一系统内或跨网络的两个设备之间的端点，它允许设备交换数据，正如我们看到的管道和命名管道一样。正如你可以轻易猜到的，Linux系统有很多套接字：'
- en: '[PRE99]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'And we can double-check looking for and in the property of the file as listed
    by `ls`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看`ls`列出的文件属性来进行双重检查：
- en: '[PRE100]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We can see an *s* character at the beginning of the permissions list, and this
    is what tells has that this file is exactly a socket, as we expected.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到权限列表的开头有一个*s*字符，这表明这个文件正如我们预期的那样，是一个套接字。
- en: '`-t`: This is true if a file is linked to a terminal. A classic use for this
    test, as you will find almost in all guides, is to check if a `stdin` or a `stderr`
    in a script is linked to a terminal. Let''s check what the `stdout` of our shell:'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t`：如果文件链接到终端，则返回为真。几乎所有指南中都会有一个经典的用途：检查脚本中的`stdin`或`stderr`是否链接到终端。让我们检查一下我们的shell的`stdout`：'
- en: '[PRE101]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Need to double-check it? Simple, since the output of our command issued in the
    current shell has been printed to our monitor, which is connected to the terminal.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 需要再双重检查一下吗？很简单，因为我们在当前shell中执行的命令的输出已经打印到连接到终端的显示器上。
- en: '`file -ntother_file`: This is true if the file is newer than other files, comparison
    made on their modification dates. Let''s have a look:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file -ntother_file`：如果文件比其他文件更新（通过修改日期进行比较），返回为真。让我们看一下：'
- en: '[PRE102]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'So, what did we do? We simply chained some commands, and since `other_file`
    must be the older piece, we started off creating it. Then, we setup a simple "for"
    loop iterating between `1` and `10` doing nothing, as implied by the double colon,
    since we had to let some time pass before creating the newer file. Passed `10`
    iterations we created a new file and compared the two. One thing that appears
    interesting in this example is the use of:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们做了什么？我们简单地串联了一些命令，并且由于`other_file`一定是较旧的文件，我们从创建它开始。然后，我们设置了一个简单的"for"循环，迭代从`1`到`10`，什么都不做，正如双冒号所暗示的那样，因为我们需要让一些时间过去，然后才创建较新的文件。经过`10`次迭代后，我们创建了一个新文件并进行比较。这个例子中有一点值得注意的是：
- en: '[PRE103]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This is a construct available since Bash newer than 3.0\. Let us quickly set
    up a range writing the starting number and the ending one. From Bash newer than
    4.0, we can also define a range with increments, in the form of:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自Bash 3.0版本以来就有的构造。让我们快速设置一个范围，写出起始数字和结束数字。从Bash 4.0版本开始，我们还可以定义一个带有增量的范围，形式如下：
- en: '[PRE104]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Like in the following example:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 就像下面的例子一样：
- en: '[PRE105]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Well, added few things here: the cycle now goes from `1` to `120` in steps
    of 2 and prints out a message only if the cycle number can be divided by 5, so
    we will not clutter the screen. Finally, we wait for one sec at each cycle using
    the sleep command to ensure that at the end of the cycle we spent 60 seconds before
    creating the last file and making the comparison.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里加了一些东西：循环现在从`1`到`120`，步长为2，只有在循环数字能被5整除时才打印消息，这样就不会使屏幕太乱。最后，我们使用`sleep`命令让每个循环等待1秒，以确保在循环结束时，我们在创建最后一个文件并进行比较之前，已经花费了60秒的时间。
- en: 'We can also modify the date of a file using a specific date, even back in the
    past, using touch with the format `-t YYMMDDHHmm`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用特定的日期修改文件的时间，即使是回到过去，使用`touch`命令和格式`-t YYMMDDHHmm`：
- en: '`zarrelli:~$ ls -lahtest.file`'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`zarrelli:~$ ls -lahtest.file`'
- en: '`-rw-r--r-- 3 zarrellizarrelli 0 Feb 12 14:56 test.file`'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`-rw-r--r-- 3 zarrellizarrelli 0 Feb 12 14:56 test.file`'
- en: '`touch -t 8504251328 test.file`'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`touch -t 8504251328 test.file`'
- en: '`zarrelli:~$ ls -lahtest.file`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`zarrelli:~$ ls -lahtest.file`'
- en: '`-rw-r--r-- 3 zarrellizarrelli 0 Apr 25 1985 test.file`'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`-rw-r--r-- 3 zarrellizarrelli 0 Apr 25 1985 test.file`'
- en: '`file -otother_file`: This is true if the file is older than `other_file`:'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file -otother_file`：如果文件比`other_file`旧，返回为真：'
- en: '[PRE106]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'And indeed:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此：
- en: '[PRE107]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Now just touch the `userinput-or.sh`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需触摸`userinput-or.sh`：
- en: '[PRE108]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '`file -efother_file`: This is true if the file and other files share the same
    inode number and device. Have you already heard about files with the same inode
    number and that they cannot be on different devices? Yes, we call them hard links:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file -efother_file`：如果文件和其他文件共享相同的inode号和设备，则返回为真。你是否已经听说过具有相同inode号的文件，并且它们不能位于不同设备上？是的，我们称之为硬链接：'
- en: '[PRE109]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now let''s double-check:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再做一次双重检查：
- en: '[PRE110]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: All three files share the same inode and, since the inode is a metastructure
    of a file system, a single file system.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个文件共享相同的inode，因为inode是文件系统的元结构，所以它们都在同一个文件系统中。
- en: We are done with the file comparison, but there is some more that we have to
    see, for instance how we can test integers since they are quite a common presence
    in all the script we see around the Internet.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了文件比较，但还有一些其他内容需要了解，例如如何测试整数，因为它们在我们看到的所有脚本中都是相当常见的。
- en: Testing integers
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试整数
- en: 'As we saw with comparisons between files, we can do much the same thing with
    integers using some binary operators. This comes handy in case we want to take
    a decision based on the value a variable has taken, as we saw in earlier examples,
    and it is a type of action widely performed when dealing with scripts:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在文件比较中看到的，我们可以使用一些二进制操作符对整数执行类似的操作。这在我们想根据变量的值做出决策时非常有用，正如我们在之前的示例中所看到的，它是处理脚本时常见的一种操作：
- en: '`-eq`: This is true if the first integer is equal to the second:'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-eq`：当第一个整数等于第二个整数时为真：'
- en: '[PRE111]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The code is quite simple, it does not sports any checks on the input but even
    though it is so bare bones it fits our purposes:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单，它没有对输入进行任何检查，但即使如此，它的简洁性也足以满足我们的需求：
- en: '[PRE112]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '`-ne`: This is true if the first integer is not equal to the second integer.
    Let''s just modify the previous script a bit:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ne`：当第一个整数不等于第二个整数时为真。让我们稍微修改一下之前的脚本：'
- en: '[PRE113]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'And now, let''s execute the new bunch of code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行这段新的代码：
- en: '[PRE114]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '`-gt`: This is true if the fist integer is greater than the second integer.
    Again, let''s modify a bunch of lines:'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-gt`：当第一个整数大于第二个整数时为真。再一次，修改几行代码：'
- en: '[PRE115]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now, let''s try it out:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们试试：
- en: '[PRE116]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '`-ge`: This is true if the first integer is greater than or equal to the second
    integer. Here are a few amendments:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-ge`：当第一个整数大于或等于第二个整数时为真。以下是一些修改：'
- en: '[PRE117]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'And now here are some tests:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里有一些测试：
- en: '[PRE118]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '`-lt`: This is true if the first integer is less than the second integer. So,
    another small amendments are as follows:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-lt`：当第一个整数小于第二个整数时为真。所以，做一下小修改如下：'
- en: '[PRE119]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'And now a couple of tests:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来做几个测试：
- en: '[PRE120]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '`-le`: This is true if the first integer is less than or equal to the second:'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-le`：当第一个整数小于或等于第二个整数时为真：'
- en: '[PRE121]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'And now the usual tests are:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，常规测试如下：
- en: '[PRE122]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'We also have a bunch of operators that can be used with the double parenthesis
    notation, which performs an arithmetic expansion and evaluation:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一组可以与双括号符号一起使用的操作符，它会执行算术扩展和计算：
- en: '`<`: This is true if the first integer is less than the second. Here is the
    modified code:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<`：当第一个整数小于第二个整数时为真。这是修改后的代码：'
- en: '[PRE123]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'And now, let''s test it:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试一下：
- en: '[PRE124]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '`<=`: This is true if the first integer is less than or equal to the second.
    Just a small change to the previous code:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<=`：当第一个整数小于或等于第二个整数时为真。对之前的代码做一个小改动：'
- en: '[PRE125]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'And the usual tests:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以及常规测试：
- en: '[PRE126]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '`>`: This is true if the first integer is greater than the second. Just a small
    change:'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>`：当第一个整数大于第二个整数时为真。稍作修改：'
- en: '[PRE127]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'And the usual tests because we are testing all we are writing:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 以及常规测试，因为我们正在测试我们所写的所有内容：
- en: '[PRE128]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '`>=`: This is true if the first integer is greater than or equal to the second:'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>=`：当第一个整数大于或等于第二个整数时为真：'
- en: '[PRE129]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'And now, let''s run some checks:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行一些检查：
- en: '[PRE130]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Testing strings
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试字符串
- en: 'We just saw some interesting comparisons, but now things start to become more
    interesting because we are going to introduce some tests on strings, and this
    brings us a step forward in what we can do to make our scripts more reactive:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到了一些有趣的比较，但现在事情变得更加有趣，因为我们将引入一些字符串测试，这将让我们在使脚本更加反应灵敏方面迈出一步：
- en: '`=`: This is true if the first string is equal to the second string:'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=`：当第一个字符串等于第二个字符串时为真：'
- en: '[PRE131]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'And now some tests:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做一些测试：
- en: '[PRE132]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Now, look at this:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看这个：
- en: '[PRE133]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'And now some checks:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在做一些检查：
- en: '[PRE134]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Something weird, isn''t there? We just got rid of spaces around the equal sign
    and now it does not work anymore:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 有点奇怪，不是吗？我们刚刚去除了等号周围的空格，现在它不再起作用了：
- en: '[PRE135]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Those spaces are actually more important than you could think. Our comparison
    became an assignment! So, be careful!
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这些空格其实比你想象的更重要。我们的比较变成了赋值！所以，务必小心！
- en: '`==`: This is true if the first string is equal to the second string, but it
    has a different behavior than `=` when it comes to double brackets:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`==`：当第一个字符串等于第二个字符串时为真，但在双括号中使用时，它的行为与`=`不同：'
- en: '[PRE136]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Matches as long as the first string starts with the character entered for the
    second string, the `*` will match whatever characters in the second string after
    what you entered:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 只要第一个字符串以第二个字符串输入的字符开始，`*`将匹配第二个字符串中输入字符后面的所有字符：
- en: '[PRE137]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'And now we match with spaces:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们匹配带空格的情况：
- en: '[PRE138]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Be careful, with single brackets, the behavior of this operator changes due
    to file globbing and word split being in action.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 小心，在使用单括号时，由于文件模式匹配和单词拆分生效，这个操作符的行为会发生变化。
- en: '`!=`: This is true if the first string is not equal to the second, but keep
    in mind that there is a pattern matching in place; so we are going to change the
    previous script a bit:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!=`: 如果第一个字符串不等于第二个字符串，则为真，但请记住，存在模式匹配；因此，我们将稍微修改前面的脚本：'
- en: '[PRE139]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'And now the tests are:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试如下：
- en: '[PRE140]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '`<`: This is true if the first string is less than the second in ASCII alphabetical
    order. So, let''s modify the script:'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<`: 如果第一个字符串在ASCII字母顺序中小于第二个字符串，则为真。那么，让我们修改脚本：'
- en: '[PRE141]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Now, here are some tests:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行一些测试：
- en: '[PRE142]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Be careful, with single brackets, the < sign must be escaped, so the condition
    becomes:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 小心，在使用单括号时，`<`符号必须转义，因此条件变为：
- en: '`if [ ${user_input1} \< ${user_input2} ]`'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`if [ ${user_input1} \< ${user_input2} ]`'
- en: '`>`: This is true if the first string is greater than the second in ASCII alphabetical
    order. So, let''s modify the script:'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`>`: 如果第一个字符串在ASCII字母顺序中大于第二个字符串，则为真。那么，让我们修改脚本：'
- en: '[PRE143]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'And now some tests:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行一些测试：
- en: '[PRE144]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Well, actually the `@` sign has a value of `40` in the ASCII table and `A` has
    a value of `41`, so `A` is greater than `@`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`@`符号在ASCII表中的值为`40`，而`A`的值为`41`，所以`A`大于`@`。
- en: 'Be careful, with single brackets, the > sign must be escaped so the condition
    becomes:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 小心，在使用单括号时，`>`符号必须转义，因此条件变为：
- en: '`if [ ${user_input1} \> ${user_input2} ]`'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`if [ ${user_input1} \> ${user_input2} ]`'
- en: '`-z`: This is true if the string is null. Here are a bunch of lines to verify
    this condition:'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-z`: 如果字符串为空，则为真。这里有一堆行来验证这个条件：'
- en: '[PRE145]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'And now a couple of checks:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行几个检查：
- en: '[PRE146]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: As you can see, in case of a `null` value, nothing is printed on the screen
    when we `echo` the variable value.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在`null`值的情况下，当我们`echo`变量值时，屏幕上不会显示任何内容。
- en: '`-n`: This is true if the string is not null. Just a minor change to the previous
    code:'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n`: 如果字符串不为空，则为真。对之前代码的一个小修改：'
- en: '[PRE147]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: And now some tests
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行一些测试
- en: '[PRE148]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Whenever you test a variable, quote it! Unquoted variables can lead to weird
    results, especially when dealing with null values.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 每次测试变量时，请用引号引起来！未加引号的变量可能会导致奇怪的结果，特别是在处理空值时。
- en: 'Have a look at how the results change with a test with single brackets and
    unquoted variables. Keep in mind that `user_input2` is not instanced, so its value
    is `null`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 看看在单括号和未引用变量的测试中结果如何变化。请记住，`user_input2`未实例化，因此其值为`null`：
- en: '[PRE149]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'And now, let''s run it:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行它：
- en: '[PRE150]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Well, as you can see, quoting matters!
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，正如你所看到的，引号确实很重要！
- en: More on tests
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于测试的内容
- en: 'We just saw some tests with one condition checked at a time, but we also have
    the equivalent of `&&` and `||`, so we can have compound checks and test more
    conditions at once, as follows:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才看到了一些每次检查一个条件的测试，但我们也有`&&`和`||`的等效操作符，因此我们可以进行复合检查并一次测试更多条件，如下所示：
- en: '`-a`: It is a logical AND, so it is true when both conditions checked are true.
    We use this operator with the test command or in single brackets. Let''s rewrite
    one of the previous scripts:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`: 这是逻辑与，当两个条件都为真时，它为真。我们将这个操作符与测试命令一起使用，或者在单括号中使用。让我们重写之前的一个脚本：'
- en: '[PRE151]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'And now some tests are:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行一些测试：
- en: '[PRE152]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '`-o`: It is a logical OR and true if either conditions are true. We use this
    operator with the test command or in single brackets. Let''s rewrite some lines
    from the previous example:'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o`: 这是逻辑或，如果其中一个条件为真，则为真。我们将这个操作符与测试命令一起使用，或者在单括号中使用。让我们重写前一个示例中的一些行：'
- en: '[PRE153]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'And now some checks:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行一些检查：
- en: '[PRE154]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'So, now a number is acceptable if it is between `10` and `20` or it is even:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在如果数字在`10`和`20`之间或是偶数，则是可接受的：
- en: '[PRE155]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We finally got into something interesting. Not that the previous chapters were
    less important, but with the tests, we just saw that we are now able to create
    some conditional statements and let our script react to different situations.
    It is not just an echo of a variable, but we get to its value, work on it, decide
    what to do, and act accordingly. In this chapter, we had a quick bite of what
    flexibility means in a script: it must be a tool and that makes one of the main
    goals of writing a script: it must be a tool that makes decisions on our behalf
    and react as we want it to do based on the conditions that we crafted in advance.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于进入了一个有趣的主题。并不是说前面的章节不重要，而是通过测试，我们看到现在可以创建一些条件语句，让脚本对不同的情况做出反应。这不仅仅是变量的回声，我们可以获取它的值，对其进行处理，决定接下来要做什么，并据此采取行动。在这一章中，我们简要了解了脚本中的灵活性意味着什么：它必须是一个工具，这也是编写脚本的主要目标之一：它必须是一个能够代表我们做出决策并根据我们提前设定的条件作出反应的工具。
