- en: We Want to Chat
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们想聊天
- en: 'In the previous chapter, we just had a dive through the planning and coding
    of a Nagios plugin. We studied the bits needed to understand what is a plugin,
    what is expected from it, and how to integrate it with the monitoring system;
    and this is because creating a script or program is not just the coding itself:
    this is the last step of a long and complex workflow.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们刚刚深入研究了 Nagios 插件的规划和编码。我们研究了理解插件是什么、期望它做什么以及如何将其与监控系统集成所需的部分；这是因为创建脚本或程序不仅仅是编写代码本身：这只是一个漫长而复杂工作流程的最后一步。
- en: Now, we will venture into something a bit different, creating a small client
    to send information to a Slack channel. This will allow us to touch on some new
    topics, such as JSON, and have a look at how to interact with a cloud-based service.
    We will not write a fully-fledged client with the capability to read and write,
    but just the sending bit, since Bash is not the optimal tool to build a whole
    interactive client. The goal here is to write a tool that we could use to send
    notifications to a channel so that we can, for instance, notify the members of
    the channel of the outcome of a task, a cronjob, and so on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将尝试一些稍微不同的事情，创建一个小客户端，将信息发送到 Slack 频道。这将使我们接触一些新话题，比如 JSON，并且了解如何与基于云的服务进行互动。我们不会编写一个功能完备的客户端（可以读取和写入），而只是实现发送功能，因为
    Bash 不是构建完整交互式客户端的最佳工具。这里的目标是编写一个工具，我们可以用它向频道发送通知，比如通知频道成员某个任务的结果、定时任务的执行情况等。
- en: The Slack messaging service
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Slack 消息服务
- en: '**Slack** is the acronym of **Searchable Log of All Conversation and Knowledge** and
    it is a collaboration tool widely used by small and large teams to share information,
    documentation, and ideas. Slack, at a glance, offers the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**Slack** 是 **Searchable Log of All Conversation and Knowledge** 的缩写，它是一个广泛用于小型和大型团队共享信息、文档和想法的协作工具。Slack
    一目了然，提供以下功能：'
- en: '**Chat rooms:** Public or private, the chat rooms allow team mates to discuss
    any topic without interfering with other people. A channel is persistent, can
    have a topic, and anyone invited can take part in it.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聊天室：** 无论是公共还是私人，聊天室允许团队成员讨论任何话题，而不会干扰到其他人。一个频道是持久存在的，可以有一个话题，任何被邀请的人都可以参与其中。'
- en: '**Direct messages:** People can send direct messages to other people or groups
    so that they can have private direct conversations.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直接消息：** 用户可以向其他人或群组发送直接消息，以便进行私人对话。'
- en: '**Integrated searches:** Everything in Slack is searchable, from the messages
    shared in a chat, to the files uploaded to it, and to the people we dealt with;
    and this is probably one of the most interesting features of this platform.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成搜索：** Slack 中的所有内容都可以搜索，包括聊天中共享的消息、上传的文件以及我们接触过的人；这可能是该平台最有趣的功能之一。'
- en: '**Calls:** Direct or group calls can be made from inside a channel or on a
    direct message; and this is without the need of an external application, so there
    is no need to leave the platform.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通话：** 可以在频道内或直接消息中进行直接或群组通话；并且无需外部应用程序，因此无需离开平台。'
- en: '**Teams:** Anyone can join a team using a URL or invitation provided by a team
    owner; and this is probably the most community-like feature of this tool.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队：** 任何人都可以使用团队所有者提供的 URL 或邀请加入团队；这可能是该工具最具社区感的功能。'
- en: '**Integration with external services:** Slack can connect to a variety of external
    services so to enhance its offering, from Google Drive to Dropbox, from GitHub
    to Zendesk, just to name a few.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与外部服务的集成：** Slack 可以连接多种外部服务，以增强其功能，从 Google Drive 到 Dropbox，从 GitHub 到 Zendesk，仅举几个例子。'
- en: '**Clients:** The platform has plenty of clients, native or via web, for many
    platforms such as Windows, macOS, Linux, Android, just to name some, so we do
    not need another client.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端：** 该平台拥有大量客户端，无论是本地客户端还是通过网络的客户端，适用于多个平台，例如 Windows、macOS、Linux、Android，仅举几例，因此我们不需要另一个客户端。'
- en: 'So we want to interact with Slack by sending messages to one channel and having
    them displayed nicely. The first step will be to create a new team at the URL:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们希望通过向某个频道发送消息并将其显示得漂亮来与 Slack 互动。第一步将是创建一个新的团队，网址如下：
- en: '[https://slack.com/](https://slack.com/)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://slack.com/](https://slack.com/)'
- en: '![](img/00020.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00020.jpeg)'
- en: Creating a new team
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新团队
- en: 'In our first step, we are going to create a new team. We have to do all the
    usual stuff, insert an email, the confirmation code, and choose a team URL:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们将创建一个新团队。我们需要完成所有常规操作，输入电子邮件、确认代码并选择团队 URL：
- en: '![](img/00021.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00021.jpeg)'
- en: A team URL will gather people with shared interests, invite some friend if you
    are done; your team is ready to fill the ranks!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个团队 URL 将聚集有共同兴趣的人，如果你完成了，邀请一些朋友；你的团队就准备好加入行列了！
- en: '![](img/00022.jpeg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00022.jpeg)'
- en: 'We are ready to share our messages. Once you are done creating the team space,
    we will have two default channels available:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好分享我们的消息了。创建团队空间完成后，我们将有两个默认频道可用：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can use the default channel or create a new one; in our case, we will create
    a brand new public channel called `#test`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用默认频道，也可以创建一个新频道；在我们的例子中，我们将创建一个全新的公共频道，名为 `#test`。
- en: There we will send there all the messages created by our script and conveyed
    by a WebHook. Now, we have introduced a new term, WebHook, and this is crucial
    to our script, since it is a method we use to interact with Slack. So, it is better
    for us to stop a moment and deepen the concept of WebHook for Slack
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过 WebHook 发送脚本创建的所有消息。现在，我们引入了一个新术语——WebHook，这对我们的脚本至关重要，因为它是我们与 Slack
    交互的一种方式。所以，最好停下来深入理解 Slack 中 WebHook 的概念。
- en: Slack WebHooks
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Slack WebHooks
- en: 'What is a WebHook? We could define it as a method to make some web pages reactive
    to user input based on a simple HTTP POST method to support a user-defined HTTP
    callback. Still a bit obscure, isn''t it? Let''s put it this way: Slack has some
    endpoints, sensitive URLs; and when you post something through HTTP to endpoints,
    you actually communicate with Slack. What makes these WebHook interesting is that
    they are stateless, since they do not rely on a continuously open connection to
    the service; and you just ping Slack whenever you need to post or retrieve some
    pieces of information. Slack supports two different kinds of WebHooks:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 WebHook？我们可以将其定义为一种使网页对用户输入做出响应的方法，基于简单的 HTTP POST 方法来支持用户定义的 HTTP 回调。听起来还是有点模糊，是吧？换句话说，Slack
    有一些端点，敏感的 URL；当你通过 HTTP 向这些端点发送内容时，你实际上是在与 Slack 通信。使这些 WebHook 有趣的是它们是无状态的，因为它们不依赖于与服务保持持续连接；你只需在需要发布或检索一些信息时向
    Slack 发送请求。Slack 支持两种不同类型的 WebHook：
- en: '**Incoming WebHook:** This is the URL that we will be posting to when we want
    some messages to appear on our test channel'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Incoming WebHook:** 这是我们在希望某些消息出现在测试频道时发送消息的 URL'
- en: '**Outgoing WebHook:** This is the URL that Slack uses to notify us of some
    events in a channel'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Outgoing WebHook:** 这是 Slack 用于通知我们某些频道事件的 URL'
- en: 'We will be using the Incoming WebHook for our notification script. So, what
    will we need? We will need the following things:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Incoming WebHook 来进行我们的通知脚本。那么，我们需要哪些东西呢？我们需要以下内容：
- en: Slack incoming WebHook linked to one of our channels.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Slack Incoming WebHook 已连接到我们的某个频道。
- en: A JSON holding the message we want to post.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含我们要发布的消息的 JSON。
- en: An application, which will connect to the URL and post the JSON. It will be
    our script.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个应用程序，它将连接到 URL 并发布 JSON。这将是我们的脚本。
- en: 'Our first task will be to create a new incoming WebHook and link it to our
    test channel. As the administrator of the team login, we have to log in at [https://my.slack.com/services/new/incoming-webhook/](https://my.slack.com/services/new/incoming-webhook/). And
    from the dropdown menu, we must select our test channel as shown here:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的第一个任务是创建一个新的 Incoming WebHook，并将其连接到我们的测试频道。作为团队管理员，我们需要登录到 [https://my.slack.com/services/new/incoming-webhook/](https://my.slack.com/services/new/incoming-webhook/)，然后从下拉菜单中选择我们的测试频道，如下所示：
- en: '![](img/00023.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00023.jpeg)'
- en: 'Select the #test channel from the drop-down menu.'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从下拉菜单中选择 #test 频道。'
- en: Now, let's click on the Add Incoming WebHooks Integration button; and we are
    led to the Incoming WebHooks page, where we will find the URL that we have to
    call to send a message to our test channel.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击“添加 Incoming WebHooks 集成”按钮，我们将进入 Incoming WebHooks 页面，在这里我们可以找到用于发送消息到测试频道的
    URL。
- en: '![](img/00024.jpeg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: In the Incoming WebHooks page, you can find  your newly created WebHook.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Incoming WebHooks 页面中，您可以找到您新创建的 WebHook。
- en: In our case, the WebHook has the following URL: [https://hooks.slack.com/services/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](https://hooks.slack.com/services/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).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，WebHook 的 URL 为：[https://hooks.slack.com/services/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](https://hooks.slack.com/services/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)。
- en: 'As explained earlier, we have two options to send a message through this WebHook:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们有两种方式可以通过这个 WebHook 发送消息：
- en: As a JSON string in the payload parameter of a POST request
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 POST 请求的负载参数中的 JSON 字符串
- en: As a JSON string in the body of a POST request
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 POST 请求体中的 JSON 字符串
- en: So, JSON is something crucial for our messaging system, but what exactly is
    a JSON?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，JSON 对我们的消息系统至关重要，但到底什么是 JSON 呢？
- en: What is a JSON?
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 JSON？
- en: '**JSON**, or **JavaScript Object Notation**, is an open, standard format (ECMA-404)
    widely used to exchange data between applications. Created in 2007 as a subset
    of the JavaScript programing language, it quickly became adopted by many languages
    as a means to deliver data regardless of the language of the sending and receiving
    applications to be a neutral conveyor. We can find a JSON file modeled on two
    different structures.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON** 或 **JavaScript 对象表示法** 是一种开放的标准格式（ECMA-404），广泛用于应用程序之间交换数据。它在 2007
    年作为 JavaScript 编程语言的一个子集创建，并迅速被许多语言采纳，成为一种中立的数据传递方式，不受发送和接收应用程序语言的限制。我们可以看到 JSON
    文件以两种不同的结构建模。'
- en: 'An object composed by name: value pairs, opened and closed by a bracket with
    each name separated from the corresponding value by a colon and each pair separated
    by a comma, such as the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个由名称：值对组成的对象，使用括号打开和关闭，每个名称与相应的值之间用冒号分隔，每对之间用逗号分隔，如以下示例：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: An ordered list of values inside an array opened and closed by a square bracket
    and the values separated by a comma: `[ "1", "2", "3"]`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的值按顺序排列，数组以方括号打开和关闭，值之间用逗号分隔：`[ "1", "2", "3"]`。
- en: A value in JSON can be a number, object, array, string, true, false, or null.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 中的一个值可以是数字、对象、数组、字符串、true、false 或 null。
- en: 'So, JSON will be the format that we will use to transmit our messages to the
    channel using the WebHook, and it will be structured in an object made of name:value
    pairs. The simplest message in Slack would bear a simple `"text"` keyword as the
    name part of the JSON and the message to deliver as its value:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，JSON 将是我们使用 WebHook 将消息传递到频道的格式，它将以由名称：值对组成的对象结构呈现。Slack 中最简单的消息将包含一个简单的
    `"text"` 关键字作为 JSON 的名称部分，消息本身作为其值：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have our first message formatted into a neat JSON, we must proceed
    to deliver this content to our `#test` channel.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将第一条消息格式化为整齐的 JSON，我们必须将该内容传递到我们的`#test`频道。
- en: Do you like cURLing?
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你喜欢使用 cURL 吗？
- en: 'One of the easiest ways to post JSON content is to use an external utility,
    such as a cURL, whose task is to transfer data over URLs. We have two ways to
    transfer data:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 发布 JSON 内容的最简单方法之一是使用外部工具，比如 cURL，其任务是通过 URL 传输数据。我们有两种数据传输方式：
- en: Directly as a JSON in the body of an HTTP POST request, with a specific content-type
    header, and this is the preferred method
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接作为 HTTP POST 请求正文中的 JSON，带有特定的 content-type 头，这是首选方法。
- en: As a URL-escaped JSON inside the payload parameter as part of the POST body
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 URL 转义的 JSON，作为 POST 正文的一部分，通过 payload 参数传递
- en: 'In the first case, we are going to use cURL with the following bits:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们将使用 cURL 配合以下参数：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It specifies the method to use to communicate with an HTTP server. The default
    method is `GET` , but here, we have to `POST` some information:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它指定了与 HTTP 服务器通信的方法。默认方法是 `GET`，但在这里，我们必须使用 `POST` 来传输一些信息：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This option allows us to send extra headers to the HTTP server. In our case,
    we are sending a **Multipurpose Internet Mail Extensions** (**MIME**) type, informing
    the Slack server that it has to expect a JSON (rfc4627) application type object
    in the body:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项允许我们将额外的头信息发送给 HTTP 服务器。在我们的案例中，我们正在发送一个 **多用途互联网邮件扩展** (**MIME**) 类型，通知
    Slack 服务器它应该期望在正文中接收一个 JSON（rfc4627）应用程序类型的对象：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `--data` option allows us to send the JSON object in the body of the `POST`
    request so that it can be passed to the HTTP server to be processed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`--data` 选项允许我们将 JSON 对象作为 `POST` 请求的正文发送，以便它可以传递给 HTTP 服务器进行处理：'
- en: '[https://hooks.slack.com/services/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](https://hooks.slack.com/services/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)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://hooks.slack.com/services/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](https://hooks.slack.com/services/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)'
- en: 'This is the final bit: the address of the WebHook that `cURL` will call to
    make its `POST` request. Now, we have all we need, so it''s just a matter of creating our
    command line. Install it if you do not have it already; the `cURL` utility and
    issue the following command on a single line:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一部分：`cURL` 将调用的 WebHook 地址，以进行 `POST` 请求。现在，我们已经具备了所有必要的信息，所以只是创建我们的命令行问题。如果你还没有安装
    `cURL` 工具，请先安装它，然后在命令行中输入以下命令：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And here is our first message to the channel:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们发送到频道的第一条消息：
- en: '![](img/00025.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00025.jpeg)'
- en: A simple cURL gave us the first message to the channel.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 cURL 请求给我们带来了第一条消息。
- en: The second way to send a message with `cURL` is to have its URL encoded inside
    the payload parameter of the `POST` body. Your URL will become a messy string
    filled by a bunch of percentage characters, but it is more of a traditional way,
    so you could feel more confident using it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息的第二种方式是将其 URL 编码放入 `POST` 请求体的有效载荷参数中。您的 URL 将变成一个充满了百分号字符的杂乱字符串，但它是更传统的方式，因此你可能会更有信心使用它。
- en: 'To send a JSON file inside the payload parameter, we need the following bits:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要在有效载荷参数中发送 JSON 文件，我们需要以下内容：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This specifies the method to use to communicate with an HTTP server. The default
    method is `GET` , but here, we have to `POST` some information:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了用于与 HTTP 服务器通信的方法。默认方法是 `GET`，但在这里，我们需要 `POST` 一些信息：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This URL encodes our JSON, so it can be posted. The structure of the data part
    is a bit different because to be CGI compliant; it must begin with a keyword:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 URL 编码了我们的 JSON，以便它可以被发布。数据部分的结构稍有不同，因为为了符合 CGI 规范，它必须以一个关键字开始：
- en: '[https://hooks.slack.com/services/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](https://hooks.slack.com/services/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)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://hooks.slack.com/services/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](https://hooks.slack.com/services/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)'
- en: 'Finally, we have the URL, which is the same as for the first method. Let''s
    assemble our command line and try it out:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有了 URL，它与第一种方法相同。让我们组合我们的命令行并试试看：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/00026.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: Creating a new team.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新团队。
- en: That's it, our second message is being displayed on the channel. It is still
    in a basic form without any whistles and bells, but it does its job and helps
    us in understanding how to interact with the Slack server. Anyway, basic is fine,
    but why not try to embellish our conversations with some special effects?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，我们的第二条消息已经显示在频道中。它仍然是基本形式，没有任何额外的效果，但它完成了工作，帮助我们理解如何与 Slack 服务器互动。无论如何，基本功能已经很好，但为什么不尝试用一些特殊效果来美化我们的对话呢？
- en: Formatting our messages
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化我们的消息
- en: 'We can add some style to our messages, from text properties to links and buttons,
    so that they can become something more than a simple bunch of text. Actually,
    modifying by hand all the payloads to check what combinations of attributes best
    suits your messages can be too much hassle, but Slack helps us with an online
    *Message Builder* that lets you customize and preview your messages without the
    need to post it anywhere. Just head to your browser at  [https://api.slack.com/docs/messages/builder,](https://api.slack.com/docs/messages/builder) and
    let''s start having fun:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为消息添加一些样式，从文本属性到链接和按钮，让它们不仅仅是一堆简单的文本。实际上，手动修改所有有效载荷来检查哪些属性组合最适合您的消息可能会太麻烦，但
    Slack 提供了一个在线的 *消息构建器*，让你可以在不发布消息的情况下自定义和预览消息。只需打开浏览器，访问 [https://api.slack.com/docs/messages/builder,](https://api.slack.com/docs/messages/builder)
    并开始享受其中的乐趣：
- en: '![](img/00027.jpeg)![](img/00028.jpeg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpeg)![](img/00028.jpeg)'
- en: The payload editor lets you try your message before sending it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有效载荷编辑器允许你在发送消息之前进行尝试。
- en: 'Inside the upper box, we can forge our payload as we wish and preview it in
    the lower box, so let''s see some of the more interesting bits that we can add
    to our messages:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上方的框中，我们可以根据需要构造有效载荷，并在下方的框中预览它，所以让我们看看可以添加到消息中的一些有趣的内容：
- en: '**Bold:** Well, this is a classic. You can turn any strings of text in bold
    simply by wrapping it between two asterisks, try out this payload:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粗体：** 好吧，这是经典之作。你只需将文本字符串用两个星号包裹，即可将其加粗，试试这个有效载荷：'
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/00029.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.jpeg)'
- en: Here is how our bold lines appear in the Message Builder.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在消息构建器中看到的粗体文本效果。
- en: '**Italics:** This stresses the importance of a word or a sentence, and you
    can get this effect simply by wrapping a string between the two underlines:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**斜体：** 这强调了单词或句子的重点，你只需要将字符串用两个下划线包围即可实现这一效果：'
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Code:** If you are writing some text that belongs to a command line or a
    some kind of code, you can enclose it between to back tickles and have it outstanding:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码：** 如果你正在编写属于命令行或某种代码的文本，可以将其包裹在反引号之间，使其突出显示：'
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![](img/00030.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.jpeg)'
- en: Here is how your code is shown in the channel.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的代码在频道中的显示效果。
- en: '**Code block:** But how do you enclose a `multi line` code block? Let''s see:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码块：** 那么如何将 `多行` 代码块包裹起来呢？让我们看看：'
- en: '[PRE13]y=1nx=y+1nx=2[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]y=1nx=y+1nx=2[PRE14]'
- en: '![](img/00031.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.jpeg)'
- en: A `multi line` code block appears a little different compare to a single line
    code string.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`多行` 代码块与单行代码字符串相比会略有不同。'
- en: '**URL linking:** You can insert clickable links in a message by enclosing the
    URL in `<>`. You can use two different ways to insert a link:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL链接:** 你可以通过将URL包围在`<>`中，在消息中插入可点击的链接。你可以用两种不同的方式插入链接：'
- en: Just put the link itself surrounded by `<>`: `<http://www.packtpub.com>`
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需将链接本身用`<>`包围：`<http://www.packtpub.com>`
- en: Add to the previous syntax  `"|linked"` to make the linked string referring
    to the URL called `<http://www.zarrelli.org|this>"`
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的语法中添加`"|linked"`，使得链接字符串指向的URL为`<http://www.zarrelli.org|this>`"
- en: 'So, our payload with both syntaxes could well be this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的载荷使用这两种语法的形式可能是这样的：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '![](img/00032.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.jpeg)'
- en: 'We have two different ways to link a URL:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种不同的方式链接URL：
- en: '**Email address linking:** In a way similar to URL linking, just surround the
    email link and a `"|linked"` by `<>`:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电子邮件地址链接:** 类似于URL链接，只需将电子邮件链接和`"|linked"`用`<>`包围：'
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![](img/00033.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: Click on the highlighted word, and your email client will fire up with the email
    address that is filled in as the recipient.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 点击突出显示的单词，您的电子邮件客户端将启动，并自动填写收件人地址。
- en: '**Date:** We can format a date in your message using a Unix epoch timestamp
    and some selector to modify its appearance. We can optionally link a URL, but
    we always have to provide some fallback text to be displayed to older clients
    in case the time token conversion fails. The keyword to you in this case is `<!date>`,
    but with a tad more complex syntax:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期:** 我们可以使用Unix时间戳和一些选择器格式化消息中的日期，并可以修改其显示方式。我们可以选择性地添加URL链接，但必须始终提供回退文本，以防时间令牌转换失败。此时的关键词是`<!date>`，但其语法稍复杂：'
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have a bunch of different selectors available to modify how dates and times
    will appear in the channel:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多不同的选择器可以用来修改频道中日期和时间的显示方式：
- en: '**`{date}`:** Your date will appear as classic *March 26th*, so try out the
    following payload:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`{date}`:** 你的日期将以经典的*3月26日*形式显示，试试以下载荷：'
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'So, our `cURL` line would be:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的`cURL`命令将是：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](img/00034.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: 'Here is how our messages will appear in the channel:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们消息在频道中的显示方式：
- en: '**`{date_short}`**: As the name states, this is an even more compact `"Mar
    26"`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`{date_short}`**: 正如名称所示，这是一个更紧凑的格式，显示为`"3月26日"`'
- en: '**`{date_long}`**:  This gives you an extended date called `"Sunday, March
    26th"`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`{date_long}`**: 这将显示一个扩展日期，格式为`"星期天，3月26日"`'
- en: '**`{date_pretty}`**: This displays the date as `{date}`, but it uses `"yesterday`,
    `"today"` or `"tomorrow"` when it fits'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`{date_pretty}`**: 这将显示为`{date}`，但当合适时，会使用`"昨天"`、`"今天"`或`"明天"`。'
- en: '**`{date_short_pretty}`**: This displays the date as `{date_short}`, but it
    uses `"yesterday`, `"today"` , or `"tomorrow"` when it fits'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`{date_short_pretty}`**: 这将以`{date_short}`格式显示日期，但当合适时，会使用`"昨天"`、`"今天"`或`"明天"`。'
- en: '**`{date_long_pretty}`**: This displays the date as `{date_long}`, but it uses
    `"yesterday`, `"today"` , or `"tomorrow"` when it fits'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`{date_long_pretty}`**: 这将显示为`{date_long}`，但当合适时，会使用`"昨天"`、`"今天"`或`"明天"`。'
- en: '**`{time}`**: This displays the time in a 12-hour format, and in our example,
    it is `1:34 PM`; but if the client is set on a 24-hour format, it would be displayed
    as `13:34`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`{time}`**: 这将以12小时格式显示时间，在我们的例子中是`1:34 PM`；但如果客户端设置为24小时格式，它将显示为`13:34`'
- en: '**`{time_secs}`**: This displays the time to the seconds bit in a 12-hour format
    `1:34:55 PM`; but if the client is set on a 24-hour format, it would be displayed
    as `13:34:55`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`{time_secs}`**: 这将以12小时格式显示时间，精确到秒，如`1:34:55 PM`；如果客户端设置为24小时格式，则会显示为`13:34:55`'
- en: 'We can also add a URL to the date so that when you click on the date/time,
    you will be brought the website pointed as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将URL添加到日期中，这样当你点击日期/时间时，会跳转到相应的网站，格式如下：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Obviously, you can mix the formatter to have a more meaningful message as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可以混合格式化器，以便得到更有意义的消息，如下所示：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the complete `cURL` line would be as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的`cURL`命令如下所示：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Apart from the dates, we can use some special commands in your messages to
    get our audience to head up and pay attention to us:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 除了日期，我们还可以在消息中使用一些特殊命令，让观众注意到我们：
- en: '**`<!here>`:** This will notify all our team members in the channel who are
    active:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`<!here>`:** 这将通知所有在频道中活跃的团队成员：'
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**`<!channel>`:** This will notify all our team members in the channel regardless
    of their status. A notify icon will appear close to the channel name.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`<!channel>`:** 这将通知所有在频道中的团队成员，无论他们的状态如何。频道名称旁将出现一个通知图标。'
- en: '**`<!group>`:** This is a synonym of `<!channel>` and both can be used inside
    a channel or a group.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`<!group>`:** 这是`<!channel>`的同义词，二者都可以在频道或小组内使用。'
- en: '**`<!everyone>`:** This notifies all of our team members. This can be used
    in the team wide channel, which is usually called #general.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`<!everyone>`:** 这会通知我们所有的团队成员。通常可以在团队频道中使用，通常称为#general。'
- en: '![](img/00035.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: Using one of the notification tags will cause a notification icon to appear
    closer to the channel name.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用其中一个通知标签将导致通知图标出现在频道名称附近。
- en: 'If we want to have the attention of our audience, we can make use of the classical
    tools that are popular in the social networks: the so-called emojis. Slack will
    let us display any emoji we like, so let''s just go to [https://unicodey.com/emoji-data/table.htm,](https://unicodey.com/emoji-data/table.htm) and
    choose the little drawings you like the most.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想引起观众的注意，可以使用在社交网络中流行的经典工具：所谓的表情符号。Slack允许我们显示任何我们喜欢的表情符号，因此让我们访问[https://unicodey.com/emoji-data/table.htm,](https://unicodey.com/emoji-data/table.htm)，选择你最喜欢的小图案。
- en: 'Once we have chosen our emojis, we can then forge a payload like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了我们的表情符号，就可以像这样构建一个有效负载：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And `cURL` it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行`cURL`：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The results, in the following screenshot, are really nice: they attract attention
    in a fancy way, so our team members will not be haunted by our messages!'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图中的结果非常棒：它们以一种花哨的方式吸引注意力，因此我们的团队成员将不会被我们的消息所困扰！
- en: '![](img/00036.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: 'A fancy message can nicely convey the urgency of a statement. Finally, we can
    address a single user just using `<@user| Optional handle>` , and we can also
    override the channel we want to send the message to using this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一条花哨的消息可以很好地传达声明的紧迫性。最后，我们可以通过使用`<@user| 可选的处理符号>`来直接指定某个用户，我们还可以使用以下方式覆盖我们想要发送消息的频道：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So, we could address the user called `Giorgio` who is in the channel called `#general`,
    asking him to join the test channel:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们可以向频道`#general`中的用户`Giorgio`发送请求，邀请他加入测试频道：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, the complete `cURL` line would be as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，完整的`cURL`命令行如下：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: With this message, the user Giorgio will receive a notification in the `#general`
    channel; and the content will be brought to his attention.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此消息，用户Giorgio将在`#general`频道收到通知；内容将引起他的注意。
- en: 'You do not need to convert in HTML the entire text of your message, but there
    are three characters that must be necessarily turned into HTML entities:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要将消息的全部文本转换为HTML，但有三个字符必须被转换为HTML实体：
- en: '& must be replaced with &amp'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '&必须替换为&amp'
- en: < must be replaced with &lt
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <必须替换为&lt
- en: must be replaced with &gt
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 必须替换为&gt
- en: What we did so far was pretty--all you can do with a plain JSON without any
    hurdles, but if we want to further spice up our messages, we have to reply to
    message attachments, which will enable us to send images, attach buttons, and
    much more. So, our next step will be the message attachments to see not only how
    to embellish our messages, but how to make them more useful and effective.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们做的事情相对简单——这就是你可以在没有任何障碍的情况下使用普通的JSON来完成的，但如果我们想进一步美化我们的消息，我们必须使用消息附件，它将使我们能够发送图片、附加按钮等。因此，我们的下一步将是使用消息附件，看看如何不仅美化我们的消息，还能使它们更有用和更有效。
- en: Message attachments
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息附件
- en: 'A message attachment lets us convey more content to the user, and lets it be
    displayed with more whistles and bells; but we have to keep an eye on a restriction
    imposed by Slack: no more than 20 attachments per message. It makes sense, otherwise
    our messages would be so messy that it would distract the average user.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 消息附件可以让我们传递更多内容给用户，并且可以用更多的花哨效果显示出来；但我们必须注意Slack规定的一个限制：每条消息最多只能包含20个附件。这是有道理的，否则我们的消息会变得非常混乱，分散普通用户的注意力。
- en: 'What we have seen so far is a simple JSON: a one-level object, which is more
    or less like this example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的是一个简单的JSON：一个一级对象，大致是这样的示例：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In a message attachment, though we are going to see more details, more content
    modifier, and a flat structure like the one we just saw that has not enough complexity
    to convey all the information. We need structured container, still a JSON; but
    this time, it will be an array holding several properties, which will resemble
    this snippet:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息附件中，尽管我们将看到更多细节、更多内容修饰符，以及像我们刚刚看到的那种不够复杂的平面结构，我们需要一个结构化的容器，仍然是JSON；但这次，它将是一个数组，包含多个属性，像这样：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What does this snippet look like? We can see in the following screenshot how
    the attachment gets displayed:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段看起来怎么样？我们可以在下面的截图中看到附件是如何显示的：
- en: '![](img/00037.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.jpeg)'
- en: Lots of things in a single message, with a touch of pink!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一条消息中包含很多内容，并且有一丝粉色的点缀！
- en: This is a nice output, much better than the previous basic examples; but things
    get a bit more complicated, since the structure of the JSON becomes more complex,
    and we have more fields available. So, let's have a look at the main directives,
    so we can use their meaning and limitations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不错的输出，远比之前的基本示例更好；但是事情变得有些复杂，因为JSON的结构变得更加复杂，且我们有更多的字段可用。所以，让我们看一下主要指令，这样我们就可以理解它们的含义和限制。
- en: 'What we are looking at is one out of 20 possible attachments, which start with
    a fallback. As the name states, it is plain text without any markup, which is
    to be displayed if a client does not support formatted text:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在查看的是20个可能附件中的一个，它以一个回退开始。正如名称所示，这是没有任何标记的纯文本，如果客户端不支持格式化文本，它将被显示：
- en: '**`color`**: You can color code your message giving a hue to the left-side
    bar. This can be useful either to make your message stand out in the discussion
    flow or to have a quick glance at its severity. The color can have three predefined
    attributes:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`color`**：你可以为消息指定颜色，为左侧栏着色。这对于让消息在讨论流中脱颖而出，或是快速查看其严重性非常有用。颜色有三种预定义属性：'
- en: '`good`: This turns the side bar to green'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`good`：这将把侧边栏变为绿色。'
- en: '`warning`: This turns the side bar to yellow'
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warning`：这将把侧边栏变为黄色。'
- en: '`danger`: This turns the side bar to red'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`danger`：这将把侧边栏变为红色。'
- en: 'Apart from these predefined settings, you can use whatever color defined in
    hex code to turn your left-side bar into an attractive highlighted sign:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些预定义的设置外，你可以使用任何在十六进制代码中定义的颜色，将左侧的栏变成一个引人注目的高亮标记：
- en: '**`Pretext`**: This is optional text that is shown above the attachment.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Pretext`**：这是可选文本，显示在附件上方。'
- en: '**`author_name`**: This is the name of the author of the message.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`author_name`**：这是消息作者的名字。'
- en: '**`author_link`**: Any valid URL and it will turn the author''s name content
    into a link. It only works if author_name is available.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`author_link`**：任何有效的URL都会将作者的名字内容转化为一个链接。只有在`author_name`可用时才有效。'
- en: '**`author_icon`**: Any valid URL pointing to a 16x16 pixels image, which will
    be displayed to the left of `author_name`: This only works if the author''s name
    is available.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`author_icon`**：任何指向16x16像素图像的有效URL，将显示在`author_name`的左侧：只有在作者的名字可用时才有效。'
- en: The author's information, if available, will be displayed at the very beginning
    of each message.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有的话，作者的信息将显示在每条消息的最开始处。
- en: '**`title`**: As the name states, this is the title of the message and it gets
    displayed in a bigger size and bold text at the top of the message, but preceding the
    author''s information.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`title`**：正如名称所示，这是消息的标题，它会以更大的字号和粗体文本显示在消息的顶部，但在作者信息之前。'
- en: '**`title_link`**: This is a full blown URL that will  turn the tile in a clickable
    link.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`title_link`**：这是一个完整的URL，将使标题变为可点击的链接。'
- en: '**`Text`**: This is the actual body of the message, and the content can be
    formatted with the basic attributes that we saw in the previous pages. If the
    content exceeds the 500 characters of 5 line breaks, the content will collapse
    and a Show more link will allow the user to expand the content. Any URLs inside
    the text field will not unfurl.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Text`**：这是消息的实际内容，内容可以使用我们在前面页面中看到的基本格式进行格式化。如果内容超过500个字符或5行换行，内容将折叠，并且“显示更多”链接将允许用户展开内容。文本字段中的任何URL都不会展开。'
- en: '**`Fields`**: This is an array in the main array, and the bits inside it will
    be displayed in a table in the attachment. You can have more than one hash inside
    the array, just separate them with a comma, such as in the following example:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Fields`**：这是主数组中的一个数组，里面的元素将在附件中以表格形式显示。你可以在数组中放多个哈希值，只需用逗号分隔它们，如下例所示：'
- en: '[PRE31]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**`title`**: This is plain text shown in bold just above the value. It cannot
    contain any markup.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`title`**：这是简单文本，显示在值上方，以粗体显示。它不能包含任何标记。'
- en: '**`value`**: This can contain multiline text formatted with the markups that
    we saw in the previous pages.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`value`**：这可以包含格式化为我们在前面页面中看到的标记的多行文本。'
- en: '**`short`**: This optional bit will mark the value short enough to be displayed
    side by side with other values as shown here:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`short`**：这个可选项将使值变得足够简短，可以与其他值并排显示，如下所示：'
- en: '![](img/00038.jpeg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: Values can be displayed side by side.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以并排显示。
- en: '**`image_URL`:** This is any valid URL of our choice, which points to a valid
    image in the PNG, JPEG, GIF, and BMP formats. The displayed size is of 400 x 500
    pixels, and any wider or higher images will be automatically resized keeping the
    original aspect ratio. The image will be displayed inside the message attachment.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`image_URL`：** 这是我们选择的任何有效 URL，指向 PNG、JPEG、GIF 或 BMP 格式的有效图像。显示的尺寸为 400 x
    500 像素，任何宽度或高度超过该尺寸的图像会自动缩放，保持原始纵横比。该图像将显示在消息附件中。'
- en: '**`thumb_URL`:** This is any URL pointing to an image file in the PNG, JPEG,
    GIF, and BMP format. It will be displayed on the right side of the message of
    the attachment, and it will be rescaled to 75 x 75 pixels keeping the aspect ratio.
    There is a file size limit to less than 500 KB.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`thumb_URL`：** 这是指向 PNG、JPEG、GIF 或 BMP 格式图像文件的任何 URL。它将在附件消息的右侧显示，并会按 75
    x 75 像素的比例缩放保持纵横比。文件大小限制为小于 500 KB。'
- en: '**`footer`:** This is the small chunk of text, limited to 300 characters to
    give some extra information to the readers.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`footer`：** 这是简短的文本片段，最多 300 个字符，用于向读者提供一些额外的信息。'
- en: '**`footer_icon`:** Provide a valid URL to an image, and it will be displayed
    beside your footer text. The image will be displayed with a fixed size of 16 x
    16 pixels and only if you provided a footer.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`footer_icon`：** 提供指向图像的有效 URL，图像将显示在页脚文本旁边。该图像将以 16 x 16 像素的固定大小显示，仅当你提供了页脚时才会显示。'
- en: '**`ts`:** Each message has its own timestamp when published, but we can attach
    a specific timestamp to an event or happening mentioned into the message attachment
    using the ts field and time info expressed in epoch time.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`ts`：** 每条消息都有自己的时间戳，当发布时，然而我们可以通过 `ts` 字段和以纪元时间格式表达的时间信息，向消息附件中提及的事件或发生的事情附加特定的时间戳。'
- en: For what we are interested in, it is all about the message formatting. There
    are some fancy things such as buttons, but that would require a full-blown application
    able to read from the channel and react to the user actions. As of now, we will
    stick to a simpler interaction with our script by just sending nicely formatted
    information to the channel; but no one will prevent you from starting off this
    example and build up some more complex and suited to your needs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们关心的内容而言，重点在于消息格式化。有些花哨的功能如按钮，但这需要一个能够从频道读取并响应用户操作的完整应用程序。目前，我们将坚持通过脚本与频道进行更简单的交互，只是发送格式良好的信息；但没有人阻止你从这个例子出发，构建更复杂且更符合需求的功能。
- en: Our wee chatty script for Slack
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的简易 Slack 聊天脚本
- en: 'Time to start planning our script for Slack, and the first step is to ask ourselves
    what do we want out of it. Let''s recap our requirements, the script has to do
    as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候开始规划我们的 Slack 脚本了，第一步是问自己，我们希望它做什么。让我们回顾一下需求，脚本必须执行以下操作：
- en: 'Accept the text message to display: required'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受要显示的文本消息：必填
- en: 'Accept a title for the message: required'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受消息标题：必填
- en: 'Accept a title_link: optional and only if a title is available'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 title_link：可选，仅在标题可用时使用
- en: 'Accept a fallback message: required'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受回退消息：必填
- en: 'Accept an author_name: optional'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 author_name：可选
- en: 'Accept an author_link: optional and only if an author_link available'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 author_link：可选，仅在 author_link 可用时使用
- en: 'Accept an author_icon: optional and only if an author_link available'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 author_icon：可选，仅在 author_link 可用时使用
- en: 'Accept a color: required'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受颜色：必填
- en: 'Accept a pretext: optional'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受前置文本：可选
- en: 'Accept fields: required and required title, value and short'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 fields：必填，必须包括标题、值和短标记
- en: 'Accept image_URL: optional'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 image_URL：可选
- en: 'Accept thumb_URL: optional'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 thumb_URL：可选
- en: 'Accept footer: optional'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 footer：可选
- en: 'Accept footer_icon: optional and only if the footer is available'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 footer_icon：可选，仅在页脚可用时使用
- en: 'Accept ts: optional'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 ts：可选
- en: 'Now, we have a matrix to start building our bits and to parse the command line,
    and we are ready to start coding. We know what to do, but due to the complexity
    of the task, we will proceed step by step, adding bits to bits; and since the
    core of our message is the JSON, we will start coding its structure. But what
    to do before the first step? We have to think about which utilities we are going
    to use. As a start, we would say at least cURL, so check if you have it installed
    on your system; and if you don''t, install it. The first lines of our script will
    have a sha-bang, and try to locate the utility in our `PATH`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个矩阵来开始构建我们的模块并解析命令行，准备开始编码了。我们知道该怎么做，但由于任务的复杂性，我们将一步步进行，逐步添加模块；由于我们的核心信息是JSON格式，我们将从编码其结构开始。但在第一步之前，我们应该做些什么呢？我们需要考虑使用哪些工具。作为开始，我们至少需要cURL，所以请检查你的系统是否已安装它；如果没有，请安装它。我们脚本的第一行将包含sha-bang，并尝试在`PATH`中定位该工具：
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: These first lines resemble the previous Nagios plugin, and this script starts
    off with a license statement as well. It can be quite useless to state a license,
    but if we plan to make our scripts available to the public, it is upon us to let
    the potential user know what they can do with our scripts. The author of this book
    encourages distributing the software under the GNU GPL license, as it makes it
    easier to use it to create new programs from it and reutilizing the code. But
    it is up to the creator of the program what kind of license to use. To have a
    glance at the various GNU licenses available, we can just go to [https://www.gnu.org/licenses/licenses.html](https://www.gnu.org/licenses/licenses.html) and
    have a look at the numerous licenses on one of them, which will surely fit our
    purposes. Notice that for this script, we will use lower case variables just to
    get used to the different kinds of notations adopted by different coders.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些第一行代码类似于之前的Nagios插件，且这个脚本同样以许可证声明开始。声明许可证可能没什么用，但如果我们计划将脚本提供给公众使用，就有责任告知潜在用户他们能做些什么。此书的作者鼓励在GNU
    GPL许可证下发布软件，因为它使得使用该软件创建新程序并重用代码更加容易。但最终选择使用哪种许可证，取决于程序的创建者。要了解可用的各种GNU许可证，我们只需访问[https://www.gnu.org/licenses/licenses.html](https://www.gnu.org/licenses/licenses.html)，查看其中一个许可证，这一定能满足我们的需求。注意，对于这个脚本，我们将使用小写变量，以便熟悉不同编码者采用的不同符号约定。
- en: 'So, we pointed to the `cURL` utility, but how can we be sure that it is installed
    and we can reach it? Well, we have to bear in mind that the command substitution
    given to the variable the output of which and this latter will print out something
    only if the argument passed to it is reachable in one of the directories pointed
    out by the user `$PATH` environment variable. Just for a test, let''s call which
    with cURL as an argument:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们指向了`cURL`工具，但我们怎么能确认它已安装并且可以访问呢？嗯，我们需要记住，赋值给变量的命令替换结果是`which`的输出，只有当传递给`which`的参数在用户`$PATH`环境变量所指示的目录中可访问时，它才会输出某些内容。做个测试，让我们以cURL作为参数调用`which`：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s call which with some blurb:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用一些简短的说明来调用`which`：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We get nothing in the output, so our `cURL` variable will bear no value. One
    more check, let''s test ifconfig as the root:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为空，所以我们的`cURL`变量没有值。再做一次检查，让我们以root用户测试`ifconfig`：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, let''s check it again as a non-privileged user:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们再作为非特权用户检查一次：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So, since the path to `ifconfig` is in the `$PATH` variable of the root user
    only, which, for the non-privileged user, will return nothing. Based on this,
    we can implement a check with just a few lines:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`ifconfig`的路径仅在root用户的`$PATH`变量中，所以对于非特权用户，`which`将返回空值。基于这个情况，我们可以用几行代码实现一个检查：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'So, if the `$cURL` variable is not empty, the utility is reachable; if not,
    we receive a warning and exit from the script with an error:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果`$cURL`变量不为空，表示该工具可访问；如果为空，则会收到警告，并带着错误退出脚本：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Great, it seems to work. Now let's change `cURL=$(which cURL)` into `cURL=$(which
    cur1l2)`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，似乎有效。现在让我们把`cURL=$(which cURL)`改成`cURL=$(which cur1l2)`。
- en: 'Let''s run the script again:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行脚本：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Correct, the script exits because which cannot find that non sense string in
    the user `$PATH` variable. So, this check can come in handy, but as it is written
    it is not so useful, so let''s make a function out of it:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正确，脚本退出是因为`which`无法在用户的`$PATH`变量中找到那个无意义的字符串。所以，这个检查可能会派上用场，但按现在的写法并不那么有用，因此让我们将其做成一个函数：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We simply check if which outputs the path to the utility checked; if it outputs
    nothing, then the variable is empty and we exit with a message and an exit code.
    If the variable holds something, then we do nothing since we assume this is the
    path to the utility. This check resembles the one we used for the Nagios plugin:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需检查输出的路径是否为工具的路径；如果什么也不输出，则变量为空，我们会退出并输出一条信息以及退出代码。如果变量有内容，我们就不做任何处理，因为我们假设这是工具的路径。这个检查类似于我们为Nagios插件所做的检查：
- en: '[PRE41]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This other one check tests if the content of the variable actually points to
    a file. Which is better? Depends on what you are checking for. If we need to verify
    that the variable points to a real file, then `[ -e "$i" ]` is what we are looking
    for. Otherwise, when we want a more generic check, `[ -z "$i" ]` will do the job
    for us.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个检查测试的是变量内容是否指向一个文件。哪个更好？取决于你要检查的内容。如果我们需要验证变量指向一个真实的文件，那么`[ -e "$i" ]`是我们要找的。否则，当我们想做更通用的检查时，`[
    -z "$i" ]`就能完成任务。
- en: 'What do we need next in our script? Let''s recall a `cURL` that we made a few
    pages ago:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在脚本中接下来需要做什么？让我们回顾一下几页前我们做的一个`cURL`：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once we deal with the `cURL` command, we have to manage the headers:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们处理完`cURL`命令，就必须管理请求头：
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These are static and will not change, so we can use them without enclosing in
    a variable.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是静态的，不会改变，因此我们可以直接使用它们而不需要放入变量中。
- en: 'We must not forget our WebHook URL:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能忘记我们的WebHook URL：
- en: '[PRE44]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, it is time to build our first, static payload; and here comes the tricky
    part. Since the payload is a long multiline JSON, writing it in a single long
    line would be cumbersome, so we are going to give this burden to a function, which
    will create this content on our behalf; and it will be nicely formatted too:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候构建我们的第一个静态负载了；这部分有点棘手。由于负载是一个长多行的JSON，将其写成一长行会很麻烦，因此我们将把这个负担交给一个函数，它将为我们生成这些内容；而且它也会被格式化得很好：
- en: '[PRE45]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We used a *here* document which, as we saw previously, is one of the best ways
    to deal with multiline content in Bash scripts. The function will create the content
    for us, so let''s check whether this is true by adding `generate_payload` at the
    bottom of our script; and let''s run it:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了*here*文档，正如我们之前看到的，这是处理Bash脚本中多行内容的最佳方法之一。函数将为我们创建内容，因此让我们通过在脚本底部添加`generate_payload`来验证这一点；然后运行它：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Great, it works! Our content is here, and so we can proceed in building the
    command line. Let''s delete the call to the function at the bottom of the script
    and add the following line:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，它工作了！我们的内容已经生成，我们可以继续构建命令行。让我们删除脚本底部对函数的调用，并添加以下行：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`$(generate_payload)` is a command substitution that will give`--data` the
    output generated by the function; but do not forget to enclose it in double quotes,
    or your output will be taken line by line and not as a single object. Time to
    save and execute the script and check our `#test` channel:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`$(generate_payload)` 是一个命令替换，它会将函数生成的输出赋值给`--data`；但不要忘记将其括在双引号中，否则你的输出将逐行处理，而不是作为一个整体。现在是时候保存并执行脚本，检查我们的`#test`频道：'
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '![](img/00039.jpeg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00039.jpeg)'
- en: We checked our script just to be sure that it works as intended.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查了脚本，以确保它按预期工作。
- en: 'Nice, the script works, we can see the results in the `#test` channel and a
    tiny `OK` in the command line. Well, nice, but we cannot rely on a third-party
    output to know if anything went wrong, so let''s modify our command line to get
    some useful response:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，脚本运行正常，我们可以在`#test`频道看到结果，以及命令行中一个小小的`OK`。嗯，还不错，但我们不能依赖第三方输出来判断是否出了问题，因此我们需要修改命令行，以获取一些有用的响应：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We added a `-f` flag to `cURL` so that it exits silently in case of error,
    letting us write something meaningful on the output. It is not 100% failsafe and,
    as we will see, sometimes an error message slips through, but it is still usable.
    Then we add this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`cURL`添加了一个`-f`标志，这样在出错时它会悄无声息地退出，让我们可以在输出中写入有意义的信息。它不是百分百可靠的，正如我们将看到的，有时错误信息会泄漏出来，但它仍然是可用的。然后我们添加了这个：
- en: '[PRE50]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We have already seen this kind of test before. We are checking if the command
    was successful or not and echoing the exit code called `"$?"` to the `stdout`.
    Let''s have a look:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以前已经见过这种测试。我们在检查命令是否成功执行，并将退出代码`"$?"`输出到`stdout`。让我们看一下：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Great! cURL just printed `ok` on the command line, and since the execution
    went fine, we printed a `Success` message with `exit code`. Now, let''s remove
    `k` from `$webhook` on the last line and execute the script again:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！cURL 刚刚在命令行上打印了 `ok`，而且由于执行顺利，我们打印了一个带有 `exit code` 的 `Success` 消息。现在，让我们删除最后一行中的
    `$webhook` 中的 `k`，并再次执行脚本：
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'There was an error, exit code: `3`.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了一个错误，退出代码：`3`。
- en: It should have failed silently, but anyway, we were able to write our meaningful
    error message; and this is all we want.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该悄悄失败，但无论如何，我们成功地写出了有意义的错误信息；这正是我们想要的。
- en: 'Our first step is accomplished: we can send a static message to our WebHook
    and have the message displayed in the `#test` channel. This is interesting, but
    not so flexible. What we really want is to be able to modify the message based
    on our input. To reach this goal, we have to turn into variables all the bits
    inside our attachment so that we will be able to pass the values on the command
    line. Let''s start creating a couple of variables:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步已经完成：我们可以向 WebHook 发送一个静态消息，并在 `#test` 频道显示该消息。这很有趣，但不够灵活。我们真正想要的是根据输入修改消息。为了实现这个目标，我们需要将附件中的所有部分转换为变量，以便能够在命令行中传递值。让我们开始创建一些变量：
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, we just have to modify the payload:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要修改有效负载：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s run the script to see if our modifications are taken into account:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行脚本，看看我们的修改是否生效：
- en: '[PRE55]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'It seems it worked; a check to the `#test` channel will confirm the outcome,
    as we can see in the following screenshot:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它有效；我们可以通过检查 `#test` 频道来确认结果，正如我们在下面的截图中所见：
- en: '![](img/00040.jpeg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00040.jpeg)'
- en: Our variables are being taken into account by the script.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的变量正在被脚本考虑。
- en: 'Since our variables seem to be working, let''s create a new whole bunch of
    them:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们的变量似乎在正常工作，接下来让我们创建一大堆新的变量：
- en: '[PRE56]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Obviously, the payload must be modified accordingly:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，有效负载必须相应地进行修改：
- en: '[PRE57]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Again, let''s test our code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们测试一下我们的代码：
- en: '[PRE58]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The screenshot here shows our newly formatted message:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的截图显示了我们新格式化的消息：
- en: '![](img/00041.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00041.jpeg)'
- en: It seems that our new payload works well.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们新的有效负载工作得很好。
- en: 'Now that we have all the variables in place, it is time to create a menu that
    will help us manage the user input. Let''s start writing a help function; we already
    saw how to do this in the previous chapter, but this time, we have a lot of options
    to deal with, so we start associating a switch to each variable:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了所有的变量，接下来是创建一个菜单，帮助我们管理用户输入。让我们开始编写一个帮助函数；我们在上一章已经看过如何做了，但这次我们有很多选项要处理，因此我们将每个变量都关联一个选项：
- en: '[PRE59]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'What we use as short and long options is up to us, but we must keep in mind
    a golden rule: these must be meaningful not for us, but for the potential users
    of the script, so we have to take a step aside and try to think as our users.
    Once we have decided on the best options, we must proceed creating the actual
    command-line parser:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的短选项和长选项是由我们决定的，但我们必须记住一个黄金法则：这些选项必须对潜在的脚本用户有意义，而不是对我们自己，因此我们需要站在用户的角度，尝试以他们的方式思考。一旦我们确定了最佳选项，就可以开始创建实际的命令行解析器：
- en: '[PRE60]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And now the `print_help` function:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是 `print_help` 函数：
- en: '[PRE61]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, let''s comment the last line of the script: the one calling cURL. Then,
    let''s call the script with the `-h` switch:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们注释掉脚本的最后一行：也就是调用 cURL 的那一行。然后，我们通过 `-h` 参数来调用脚本：
- en: '[PRE62]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'There is a small issue: even the Nagios plugin had it, so it is time to solve
    it. Let''s call the script without any parameters:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个小问题：即使是 Nagios 插件也有这个问题，因此是时候解决它了。让我们在没有任何参数的情况下调用脚本：
- en: '[PRE63]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Nothing, we do not have anything as feedback, so we do not even know if we
    can use a `-h` switch to get more information. How do we solve this hindrance?
    Well, we have different options available; we could modify the while clause for
    instance or adopt a different strategy:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 什么都没有，我们没有任何反馈，因此甚至不知道是否可以使用 `-h` 参数来获取更多信息。我们该如何解决这个障碍呢？好吧，我们有不同的选择；例如，我们可以修改
    `while` 条件，或者采用其他策略：
- en: '[PRE64]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We have to put these lines before the menu creation, and they will check the
    input: if nothing is given on the command line, it will write an error message
    and call the `print_help` function. Time to test our script now and see what happens:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将这些行放在菜单创建之前，它们会检查输入：如果命令行没有给出任何参数，它将写入错误信息并调用 `print_help` 函数。现在是时候测试我们的脚本，看看会发生什么：
- en: '[PRE65]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'It seems it worked, and the screenshot of the `#test` channel confirms our
    guess:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它有效，`#test` 频道的截图确认了我们的猜测：
- en: '![](img/00042.jpeg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00042.jpeg)'
- en: Our script now accepts the command-line parameters.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本现在接受命令行参数。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We are now able to send formatted messages to the `#test` channel, but is this
    all we can do with this script? No, as you will learn over time with a bit more
    experience, programming is also setting a scope to our efforts: we must define
    our goals, plan accordingly, accomplish them, and assess the results. Overdoing,
    in a professional environment, breaks one of the fundamental rules of the project
    management, the so-called *iron triangle* that defines the quality of a project
    as the intersection between scope, time, and costs that are the top three constrains
    driving us in creating our programs. Spend too long on a program or exceed the
    goals, the cost will levitate and the overall quality, not the quality of the
    code, but of our project, will be impacted.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在能够向`#test`频道发送格式化的消息，但这就是我们可以用这个脚本做的全部吗？不，正如你随着时间推移、积累经验会发现的，编程也是在设定我们的努力范围：我们必须定义目标，进行相应的计划，完成目标，并评估结果。在专业环境中，做得过头违反了项目管理的基本规则，即所谓的*铁三角*，它定义了项目质量作为范围、时间和成本的交集，这三个约束条件驱动我们创建程序。如果在一个程序上花费过长时间或超出目标，成本将会膨胀，整体质量——不是代码质量，而是我们项目的质量——将会受到影响。
- en: This script was an example on how to plan and execute, how to check for the
    information we need to code a working script, and how to write down our steps.
    There are many ways to improve this framework, for example, by allowing the user
    to pass a date on the command line, not as epoch time, but in one format allowed
    by the date command, and then translating it with a tiny function or even inline
    into the code. We can, for instance, put a check on the option arguments so that
    the user will be forced to pass an argument if they specify an option on the command
    line. This is a play field and these can be advises on how to have fun and develop
    the script further. We are now moving further to deepen what we can do with a
    subshell, how to execute a bunch of processes in parallel and, as always, how
    to have fun!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本是一个关于如何规划和执行的示例，展示了如何检查我们需要的信息来编写一个可运行的脚本，以及如何记录我们的步骤。有很多方法可以改进这个框架，例如，允许用户在命令行上传递一个日期，而不是以纪元时间的形式，而是以`date`命令允许的格式传递，然后通过一个小函数或甚至直接在代码中进行转换。我们还可以，例如，检查选项参数，以便用户在命令行中指定选项时，强制传递一个参数。这是一个操作领域，这些可以是如何玩得开心并进一步开发脚本的建议。我们现在将继续深入探讨如何利用子壳执行多个并行进程，以及，像往常一样，如何玩得开心！
