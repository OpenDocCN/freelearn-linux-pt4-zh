- en: Acting Like a Typewriter and File Explorer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 像打字机和文件资源管理器一样操作
- en: 'In this chapter, we will introduce the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Basic searching for strings and files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本的字符串和文件搜索
- en: Using wildcards and regexes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通配符和正则表达式
- en: Math and calculations in script
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本中的数学和计算
- en: Striping/altering/sorting/deleting/searching strings with Bash only
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用 Bash 对字符串进行剥离/修改/排序/删除/搜索
- en: Using SED and AWK to remove/replace substrings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SED 和 AWK 删除/替换子字符串
- en: Formatting your data/output using echo and printf
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 echo 和 printf 格式化数据/输出
- en: Readying your script for different languages with internationalization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同语言准备脚本的国际化
- en: Calculating statistics and reducing duplicates based on file contents
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据文件内容计算统计信息并减少重复项
- en: Using file attributes with conditional logic
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件属性与条件逻辑
- en: Reading delimited data and altered output format
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取定界数据并修改输出格式
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Hopefully, the previous Bash crash course chapter provided more than a hint
    of the utility and power of Bash. On the other hand, this chapter introduces several
    *bolt-on* technologies to make Bash even more extensive when searching for items
    and text, or automating file explorer/file system operations.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 希望前面的 Bash 入门课程章节已经提供了有关 Bash 工具和功能的提示。另一方面，本章介绍了几种*附加*技术，使得在搜索项目和文本或自动化文件资源管理器/文件系统操作时，Bash
    的功能更加广泛。
- en: By itself, Bash is merely a powerful scripting language, but much of Bash's
    flexibility comes from being able to "glue" other technologies (tools or languages)
    together to make the output more useful. In other words, Bash is a base platform
    similar to how some auto/car lovers choose a particular platform before making
    their modifications. Will a modified car do everything, even with enhancements?
    Certainly not, but it can make it more powerful or useful in specific cases, and
    at least provides four wheels for movement.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，Bash 只是一个强大的脚本语言，但 Bash 的灵活性在于能够“粘合”其他技术（工具或语言），使得输出更加有用。换句话说，Bash 是一个基础平台，就像一些汽车爱好者在进行改装之前选择一个特定的平台。经过改装的车能做所有事情吗？当然不能，但它可以在特定情况下变得更强大或更有用，至少为移动提供了四个轮子。
- en: 'Not only do common scripts contain a series of commands for automation, they
    often include **logic** to modify strings such as the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的脚本不仅包含一系列自动化命令，通常还包括**逻辑**来修改字符串，例如以下内容：
- en: Removing trailing characters
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除尾部字符
- en: Replacing sections of words (substrings)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换单词的部分（子字符串）
- en: Searching for strings in files
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件中搜索字符串
- en: Finding files
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找文件
- en: Testing file types (directory, file, empty, and so on)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试文件类型（目录、文件、空文件等）
- en: Performing small calculations
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行简单计算
- en: Limiting the scope of searches or data (filtering)
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制搜索或数据的范围（过滤）
- en: Modifying the contents of variables (strings inside of string variables)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改变量的内容（字符串变量中的字符串）
- en: This logic that modifies, limits, and even replaces input/output data can be
    very powerful when you need to execute broad searches for a specific string or
    when you have copious amounts of data. Terminals chock; full of output or massive
    data files can be very daunting to explore!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种修改、限制甚至替换输入/输出数据的逻辑，在需要执行广泛搜索特定字符串或处理大量数据时，可以非常强大。终端可能会阻塞；充满输出或巨大的数据文件可能会让人感到探索起来非常艰巨！
- en: 'However, there is one very important concept that still needs to be discussed,
    and that is **recursive** functionality. Recursive functionality can apply to
    script functions, logic, and even a command operation. For example, you can use **grep **to **recursively **crawl
    an entire directory until no more files remain, or you can recursively execute
    a function inside of itself until a condition is met (for example, printing a
    single character at a time within a string):'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个非常重要的概念仍然需要讨论，那就是**递归**功能。递归功能可以应用于脚本函数、逻辑，甚至命令操作。例如，你可以使用**grep**来**递归**地遍历整个目录，直到没有更多文件，或者可以递归地执行一个函数，直到满足某个条件（例如，在一个字符串中一次打印一个字符）：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Be careful with recursion (especially with functions), as it can sometimes be
    really slow depending on the complexity of the structure (for example, file system
    or size of files). Also if there is a logic error, you can keep executing functions
    recursively forever!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 小心递归（特别是函数），因为它有时可能会很慢，取决于结构的复杂性（例如，文件系统或文件大小）。如果存在逻辑错误，你可能会让函数永远递归执行下去！
- en: This chapter is all about limiting data, utilizing it, modifying it, internationalizing
    it, replacing it, and even searching for it in the first place.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的内容将集中在限制数据、利用数据、修改数据、国际化数据、替换数据，甚至是搜索数据。
- en: Basic searching for strings and files
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的字符串和文件搜索
- en: Imagine searching for a four leaf clover in a big garden. It would be really
    hard (and it is still really hard for computers). Thankfully, words are not images
    and text on a computer is easily searchable depending on the format. The term **format**
    has to be used because if your tool cannot understand a given type of text (**encoding**),
    then you might have trouble recognizing a **pattern** or even detecting that there
    is text at all!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在一个大花园里寻找四叶草。这将是非常困难的（对于计算机来说，这依然非常困难）。幸运的是，文字不是图像，计算机上的文本可以根据格式轻松搜索。之所以使用**格式**这个术语，是因为如果你的工具无法理解某种类型的文本（**编码**），那么你可能会遇到无法识别**模式**，甚至无法检测到文本的情况！
- en: Typically, when you are looking at the console, text files, source code (C,
    C++, Bash, HTML), spreadsheets, XML, and other types, you are looking at it in **ASCII **or **UTF**.
    ASCII is a commonly used format in the `*NIX` world on the console. There is also
    the UTF **encoding scheme**, which is an improvement upon ASCII and can support
    a variety of extended characters that were not present in computing originally.
    It comes in a number of formats such as UTF-8, UTF-16, and UTF32.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当你查看控制台、文本文件、源代码（C、C++、Bash、HTML）、电子表格、XML等类型时，你看到的是**ASCII**或**UTF**格式。ASCII是`*NIX`世界中在控制台上常用的格式。还有UTF**编码方案**，它是对ASCII的改进，支持计算机最初没有的各种扩展字符。它有多种格式，如UTF-8、UTF-16和UTF-32。
- en: When you hear the words encoding and decoding, it is similar to encryption and
    decryption. The purpose is not to hide something, but rather to transform some
    data into something appropriate for the use case. For example, transmission, usage
    with languages, and compression.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当你听到编码和解码这两个词时，它类似于加密和解密。其目的不是隐藏某些内容，而是将某些数据转化为适合特定用途的形式。例如，用于传输、语言使用和压缩。
- en: ASCII and UTF are not the only types your target data might be in. In various
    types of files, you may encounter different types of encoding of data. This is
    a different problem that's specific to your data and will need additional considerations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII和UTF并不是你目标数据可能采用的唯一格式。在各种类型的文件中，你可能会遇到不同类型的数据编码。这是一个与数据相关的不同问题，需要额外的考虑。
- en: In this recipe, we will begin the process of searching for strings and a couple
    of ways to search for some of your own needles in a massive haystack of data.
    Let's dig in.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将开始搜索字符串的过程，并介绍几种在大量数据堆中搜索你自己目标的方法。让我们深入探讨。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Besides having a terminal open (and your favorite text editor, if necessary),
    we only need a couple of core commands such as `grep`, `ls`, `mkdir`, `touch`, `traceroute`, `strings`,
    `wget`, `xargs`, and `find.`
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了打开一个终端（如果需要，还可以打开你最喜欢的文本编辑器），我们只需要几个核心命令，如`grep`、`ls`、`mkdir`、`touch`、`traceroute`、`strings`、`wget`、`xargs`和`find`。
- en: 'Assuming that your user already has the correct permissions for your usage
    (and authorized, of course), we will need to generate data to begin searching:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的用户已经拥有正确的使用权限（当然也需要授权），我们将需要生成数据来开始搜索：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Using the data obtained by recursively **crawling** the Packt Publishing website,
    we can see that inside of **www.packtpub.com **the entire website is available.
    Wow! We also created some test data directories and files.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过递归**爬取**Packt Publishing网站获得的数据，我们可以看到，在**www.packtpub.com**上，整个网站是可以访问的。哇！我们还创建了一些测试数据目录和文件。
- en: 'Next, open up a terminal and create the following script:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开一个终端并创建以下脚本：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice in the script the use of `~/* ?`. This refers to our home directory and
    introduces the `*` wildcard, which allows us to specify anything from that point
    on. There will be more on the concept of wildcards and regexes later in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意脚本中使用的`~/* ?`。这指的是我们的主目录，并引入了`*`通配符，允许我们指定从此位置开始的任何内容。本章后面会详细介绍通配符和正则表达式的概念。
- en: 'If you remain in your home directory (`~/`) and run the script, the output
    should be similar to the following:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你保持在主目录（`~/`）并运行该脚本，输出应该类似于以下内容：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This section is a bit of a *doozy* because we are leading up to another more
    expansive topic, which is using regexes and wildcards with strings. We introduced
    them, but also showed you that you can search for terms with `${SEARCH_TERM}`or *Packt* specifically
    without their use—it's just more work and more statements. Can you imagine writing
    a specific `grep` statement for each term such as `Packt1`, `Packt2`, `Packt3`,
    and onwards? No fun.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本节有点*难懂*，因为我们要引入一个更广泛的话题——如何在字符串中使用正则表达式和通配符。我们已经介绍了它们，但也向你展示了，即使不使用它们，你也可以专门搜索诸如`${SEARCH_TERM}`或*Packt*之类的术语——这只是需要更多的工作和更多的语句。你能想象为每个术语（如`Packt1`、`Packt2`、`Packt3`等）写一个特定的`grep`语句吗？那可不有趣。
- en: Using the Packt Publishing website as a *baseline* data set, we *grepped* our
    way through the directory using the `grep` command, targeting only our current
    location, our user's home directory. **Grep** is a powerful tool that can be used
    to parse the output of commands and files using patterns, regexs, and user supplied
    parameters. In this case, we did not expect any string to be found matching *Packt* because
    **www.packtpub.com** is *not* the same as **www.Packtpub.com**. Therefore, `result1.txt`
    is an empty file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Packt Publishing网站作为*基准*数据集，我们通过`grep`命令在目录中搜索，目标仅限于我们的当前位置——用户的主目录。**Grep**是一个强大的工具，可以用来解析命令和文件的输出，使用模式、正则表达式和用户提供的参数。在这个例子中，我们并未预期会找到匹配*Packt*的字符串，因为**www.packtpub.com**和**www.Packtpub.com**并不相同。因此，`result1.txt`是一个空文件。
- en: Grep and many other utilities can be case-sensitive. To use `grep` in a way
    that's case insensitive, use the `-i` flag.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`grep`和许多其他工具都可以区分大小写。要使用不区分大小写的`grep`，请使用`-i`标志。'
- en: In the second use of `grep`, we used the recursive flag (`-r`) and found many
    matches. By default, `grep` returns the path (containing the filename) of a match,
    and the line the match occurred within. To find the line number, you can also
    use the flag (`-n`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次使用`grep`时，我们使用了递归标志（`-r`）并找到了许多匹配项。默认情况下，`grep`会返回匹配项的路径（包括文件名）和匹配所在的行。如果你想找到行号，也可以使用标志（`-n`）。
- en: 'In the third example, we demonstrated that `grep` can be used with multiple
    user-supplied arguments:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个示例中，我们演示了如何使用多个用户提供的参数来运行`grep`：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this recipe, we are searching using a *brute-force* mechanism, which means
    we'll find it all by using all of our strength, literally. When performing searching
    on large amounts of data, or even when you perform something as seemingly simple
    as a search on the `PacktPublishing` website, more advanced and targeted algorithms
    help you find exactly what you want more efficiently and quicker than what we
    are doing here!
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在使用*暴力破解*机制进行搜索，这意味着我们将完全依靠我们的力量找到所有内容。当对大量数据进行搜索时，甚至是在`PacktPublishing`网站上执行像搜索这样看似简单的操作时，更先进和更有针对性的算法能更高效、快速地帮你找到你想要的内容，而不是像我们现在这样做！
- en: 'In the fourth and fifth executed examples, we use the `find`command. We also
    pair it with pipes and the **`xargs` **command as well. By itself, `find` is another
    very powerful CLI utility that can be used to perform search functionality (and
    consequently, damaging things if used irresponsibly/maliciously):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四个和第五个执行示例中，我们使用了`find`命令。我们还将其与管道和**`xargs`**命令结合使用。单独使用`find`是一个非常强大的CLI工具，可以用来执行搜索功能（因此，如果使用不当或恶意使用，也可能造成损害）：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding `find` command, we are using `-type f`**, **which means that
    we are looking for files only within `${DIRECTORY}`. Then, we pipe the results
    into the `xargs` command for use with grep. Wait! What is xargs!? `Xargs` is a
    command that''s commonly used in tandem with a pipe to pass newline (carriage
    return) data to another command. For example, if we run ls `-l` (with the long
    flag), the results are returned like this (we''ve added the invisible line break
    or `\n` to illustrate this):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`find`命令中，我们使用了`-type f`**，**这意味着我们仅在`${DIRECTORY}`中查找文件。然后，我们将结果通过管道传输到`xargs`命令，并与grep一起使用。等等！什么是xargs！？`Xargs`是一个常用于与管道配合使用的命令，用于将换行符（回车）数据传递给另一个命令。例如，如果我们运行`ls
    -l`（带长格式标志），结果将像这样返回（我们添加了不可见的换行符或`\n`来说明）：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we piped the results directly into another command that expected an input
    like the following, it would break!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将结果直接通过管道传递给另一个期望输入的命令，就会出错！
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead, `someProgram` requires input values separated by a space and *not*
    new lines:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`someProgram`要求输入值用空格分隔，而*不是*换行符：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is why you use `xargs`: to remove or convert the new lines into something
    less problematic.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你使用`xargs`的原因：去除或转换换行符，避免出现问题。
- en: Going back to the second `find` command example, you can see that we used the
    `-name` and `! -name` parameters. `-name` is simple; we are looking for a file
    with a specific user-supplied name. In the second `! -name` instance, the `!`means
    without or *not* with that name. This is called **inverted logic**.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第二个 `find` 命令的例子，你可以看到我们使用了 `-name` 和 `! -name` 参数。`-name` 很简单；我们在寻找一个具有特定用户提供名称的文件。在第二个
    `! -name` 实例中，`!` 表示没有或 *不* 包含这个名称。这就是所谓的 **反向逻辑**。
- en: 'We also used the `*` wildcard again in a different context than in the first
    example using `grep` (again, more on this later). Instead, this time, we used
    the `*` to match anything before the file''s extension (`*.xml` or `*.css`). It
    can even be used like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在与 `grep` 的第一次示例中使用了 `*` 通配符，但这次在不同的上下文中使用它（稍后会进一步讨论）。这次，我们用 `*` 来匹配文件扩展名前的任何内容（`*.xml`
    或 `*.css`）。它甚至可以这样使用：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the following `grep` command, we use an inline subshell execution of the
    `ls` command using wildcards. Then, we take the result by setting `${RES}` to
    `$?`. `$?` is a special variable used to get the return code. Using the value
    within `${RES}`, we can now provide a bit of conditional logic if results are
    found and appropriately `echo`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下 `grep` 命令中，我们使用内联子 Shell 执行 `ls` 命令，配合通配符。然后，我们通过将 `${RES}` 设置为 `$?` 来获取结果。`$?`
    是一个特殊变量，用来获取返回码。通过 `${RES}` 中的值，我们现在可以在找到结果时提供一些条件逻辑，并适当地 `echo`：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Right before we exited the shell, we thought we would throw in a bonus: you
    can search your past ran commands using the `history` command and `grep`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就在我们退出 Shell 之前，我们想给大家一个额外的提示：你可以使用 `history` 命令和 `grep` 来搜索你过去执行过的命令。
- en: Using wildcards and regexes
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通配符和正则表达式
- en: As we saw in the previous section, there was this new concept of recursive functions
    and the introduction of wildcards. This section will extend upon those same fundamental
    primitives to create more advanced searches using regexes and globbing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一节中所看到的，出现了递归函数的新概念和通配符的引入。本节将基于这些基本的原语，通过使用正则表达式和通配符扩展更高级的搜索方法。
- en: 'It will also extend them with a number of built-in Bash features, and some
    one-liners (nifty tricks) to enhance our searches. In short:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本节还将通过一系列内置的 Bash 特性以及一些单行命令（巧妙的小技巧）来增强我们的搜索。简而言之：
- en: 'A wildcard can be: `*`, `{*.ooh,*.ahh}`, `/home/*/path/*.txt`, `[0-10]`, `[!a]`,
    `?`, `[a,p] m`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个通配符可以是：`*`，`{*.ooh,*.ahh}`，`/home/*/path/*.txt`，`[0-10]`，`[!a]`，`?`，`[a,p]
    m`
- en: 'A regex can be: `$`, `^`, `*`, `[]`, `[!]`, `|` (be careful to escape this)'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正则表达式可以是：`$`，`^`，`*`，`[]`，`[!]`，`|`（使用时要小心转义此符号）
- en: '**Globbing **basically refers to a far more computer-eccentric term, which
    can be simply described in layman terms as **extended pattern matching**. Wildcards
    are the **symbols** used to describe patterns, and **regex** is short for **regular
    expression**, which are terms used to describe the pattern that is to match a
    series of data.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**通配符匹配** 基本上指的是一个计算机术语，可以用通俗的语言简单描述为 **扩展模式匹配**。通配符是用来描述模式的 **符号**，而 **正则表达式**
    是 **regular expression** 的简称，表示用来描述要匹配数据序列的模式。'
- en: Globbing in Bash is powerful, but likely not the best place to perform even
    more advanced or intricate pattern matching. In these cases, Python or another
    language/tool might be more appropriate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 中的通配符匹配非常强大，但可能不是执行更复杂或精细模式匹配的最佳场所。在这些情况下，Python 或其他语言/工具可能更合适。
- en: 'As we can imagine, globbing and pattern matching are really useful, but they
    cannot be used by every utility or application. Usually, though, they can be used
    at the command line with utilities such as `grep`. For example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以想象的，通配符和模式匹配非常有用，但并不是所有工具或应用程序都能使用它们。不过，通常它们可以在命令行中与诸如 `grep` 等工具一起使用。例如：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using the `ls` command, which is piped into `grep` with a regex, we can see
    that after we `touch` three files and re-run the command that the regex allowed
    us to correctly filter the output for files starting with a lowercase character,
    which are followed by a single digit.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ls` 命令并将其通过管道传递给带有正则表达式的 `grep`，我们可以看到在使用 `touch` 创建了三个文件并重新运行命令后，正则表达式使我们能够正确地过滤出以小写字母开头并紧接着一个数字的文件。
- en: 'If we wanted to further enhance grep (or another command), we could use any
    of the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想进一步增强 `grep`（或其他命令），我们可以使用以下任意一种方法：
- en: '`[:alpha:]`: Alphabetic (case-insensitive)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:alpha:]`：字母字符（不区分大小写）'
- en: '`[:lower:]`: Lowercase printable characters'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:lower:]`：小写可打印字符'
- en: '`[:upper:]`: Uppercase printable characters'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:upper:]`：大写可打印字符'
- en: '`[:digit:]`: Numbers in decimal 0 to 9'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:digit:]`：十进制数字 0 到 9'
- en: '`[:alnum:]`: Alphanumeric (all digits and alphabetic characters)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:alnum:]`：字母数字字符（所有数字和字母字符）'
- en: '`[:space:]`: White space meaning spaces, tabs, and newlines'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:space:]`：空白字符，表示空格、制表符和换行符'
- en: '`[:graph:]`: Printable characters excluding spaces'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:graph:]`：可打印字符，不包括空格'
- en: '`[:print:]`: Printable characters including spaces'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:print:]`：可打印字符，包括空格'
- en: '`[:punct:]`: Punctuation (for example, a period)'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:punct:]`：标点符号（例如，句号）'
- en: '`[:cntrl:]`: Control characters (non-printable characters like when a signal
    is generated when you use *Ctrl* + *C)*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:cntrl:]`：控制字符（如使用*Ctrl* + *C*时生成的不可打印字符）'
- en: '`[:xdigit:]`: Hexadecimal characters'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:xdigit:]`：十六进制字符'
- en: Getting ready
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'Besides having a terminal open (and your favorite text editor, if necessary),
    we only need a couple of core commands: `grep`, `tr`, `cut`**, **and `touch`.
    We''re assuming that the `www.packtpub.com` directory that we crawled through
    in the previous step is still available:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了打开终端（并且如果需要的话，还可以打开你喜欢的文本编辑器），我们只需要几个核心命令：`grep`、`tr`、`cut`、**和`touch`。我们假设在前一步中我们爬取的`www.packtpub.com`目录仍然可用：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s get started:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Open a terminal, and an editor of your choice to create a new script.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端，并选择一个你喜欢的编辑器来创建一个新的脚本。
- en: 'Inside of your script, add the following:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的脚本中，添加以下内容：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, execute the script and your console should be flooded with the output.
    Most importantly, let's look at the last five results. Notice the `Z9(,)` and
    `Z9.test(3)` among the results? This is the power of a regex at work! Okay, so
    we get that we can now create and search for a bunch of folders or files using
    variables, but can I use regexes to find things like variable parameters? Absolutely!
    See the next step.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行脚本，你的控制台应该会被输出结果淹没。最重要的是，让我们看看最后五个结果。注意到结果中有`Z9(,)`和`Z9.test(3)`吗？这就是正则表达式的强大作用！好了，我们已经知道可以使用变量创建并搜索一堆文件夹或文件了，但是我能否使用正则表达式来查找像变量参数这样的东西呢？当然可以！请看下一步。
- en: 'In the console, try the following:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台中，尝试以下命令：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Again, in the console, try the following:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在控制台中，尝试以下命令：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Can we do better using commands like `tr`to remove new lines when finding instances
    of IF that may span multiple lines?
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查找可能跨越多行的IF实例时，使用`tr`等命令来删除换行符，我们能做得更好吗？
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s remove a bit more gunk from the screen using `cut`as a finale.
    Usually, the console is `80` characters wide, so let''s add a line number and
    trim the output from `grep`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`cut`来清理屏幕上的一些杂乱信息，作为收尾。通常，控制台的宽度是`80`个字符，因此让我们添加行号并修剪`grep`的输出：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Entire books have been dedicated to parsing data with regexes, but the key thing
    to note is that regexes are not always the best option for either performance
    or for markup languages like HTML. For example, when parsing HTML, it is best
    to use a parser that is aware of the language itself and any language-specific
    nuances.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 整本书都在讲解如何使用正则表达式解析数据，但关键点是，正则表达式并不总是最适合的选择，特别是在性能和像HTML这样的标记语言中。例如，在解析HTML时，最好使用一个能够理解该语言及其特定语法的解析器。
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: As you may have guessed, snooping through lots of data without regexes and wildcards
    can be a nightmare for the uninitiated. An even scarier one might even occur when
    your expressions don't use the correct terms or a valid (and accurate) expression
    to begin with. However, wildcards are quite useful on the command line when trying
    to **craft **strings together, find data quickly, and finding files. Sometimes,
    it the usability of the search result that's irrelevant if I'm merely looking
    to find the filename and rough location/line of a specific occurrence.For example,
    where is this CSS class in what file?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的，没有正则表达式和通配符的情况下，通过大量数据进行查询，对于没有经验的人来说可能是一场噩梦。更可怕的情况可能发生在你的表达式没有使用正确的术语或有效（且准确）表达式的情况下。然而，通配符在命令行中非常有用，尤其是在你需要**拼接**字符串、快速查找数据和寻找文件时。有时候，如果我仅仅是想找到特定发生位置的文件名和大致位置/行号，搜索结果的可用性可能并不重要。例如，这个CSS类在哪个文件里？
- en: Well, you made it through the script and ran several commands to get a real-world
    idea of how to use regexes and wildcards at a surface level. Let's turn back the
    clock and walk through the recipe.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你已经通过脚本并执行了多个命令，了解了如何在表面上使用正则表达式和通配符。让我们回过头来，走一遍这个过程。
- en: 'In step 1, we opened a console, created a simple script, and executed it. The
    output results were then displayed on the console:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1步中，我们打开了控制台，创建了一个简单的脚本并执行。然后，输出结果显示在控制台上：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It could be a lot scarier! Right? In the first line, we begin by chasing down
    some PDFs that start with a capital (uppercase) letter. The line `ls * | grep
    [[:upper:]]*.pdf` uses the `ls`command with a `*` wildcard (for everything) and
    then pipes the output into `grep` with a simple regex. The regex is `[[:upper:]]`
    followed by another **`*`** wildcard to combine the `.pdf` string. This produces
    our search results, which at a minimum will contain `Test.pdf` (my results returned
    PDFs for a popular Linux journal too!).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会更可怕！对吧？在第一行中，我们开始查找以大写字母开头的PDF文件。命令`ls * | grep [[:upper:]]*.pdf`使用了带有`*`通配符（表示所有文件）的`ls`命令，然后将输出传递给`grep`，并使用一个简单的正则表达式。这个正则表达式是`[[:upper:]]`，后面跟着另一个**`*`**通配符和`.pdf`字符串的组合。这将返回我们的搜索结果，最少会包含`Test.pdf`（我的结果也返回了一个流行的Linux期刊的PDF文件）。
- en: Then, we perform almost the same search using `ls -l [[:upper:]]* `, but using
    the `ls` directory with a regex will return a large amount of data (if all of
    the folders have contents). It begins in the current directory where the script
    is located, and then marches one directory deep and prints the contents. A neat
    feature is the use of the `-l` flag, which will produce *long* results and print
    the size of the directory in bytes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们几乎进行相同的搜索，使用`ls -l [[:upper:]]*`，但使用带正则表达式的`ls`命令会返回大量数据（如果所有文件夹都有内容的话）。它从脚本所在的当前目录开始，然后深入到一个目录并打印内容。一个很好的特性是使用`-l`标志，它会产生*详细*的结果并打印目录的大小（以字节为单位）。
- en: 'Next, we use `ls` and look for all files beginning with a lowercase character
    and end with the `.test` extension. Little did you know, when you set up this
    recipe, you also saw wildcards and an expansion at work: `touch {a..c}.test` .
    The `touch` command created three files: `a.test`, `b.test`, and `c.test`. The
    `ls` command with this simple regex returns the names of the previous three files.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`ls`命令查找所有以小写字母开头并以`.test`扩展名结尾的文件。你可能没注意到，当你设置这个命令时，你也看到了通配符和扩展的实际应用：`touch
    {a..c}.test`。`touch`命令创建了三个文件：`a.test`、`b.test`和`c.test`。带有这个简单正则表达式的`ls`命令返回了这三个文件的名称。
- en: Again, we use the `ls` command with the (`*`), wildcard and expansion brackets
    to match for file extensions: `ls *.{test,txt}`. It searches for files with any
    name (`*`), which are then concatenated with a period (`.`), followed by either
    `test` or `txt` extensions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用带有（`*`）通配符和扩展括号的`ls`命令来匹配文件扩展名：`ls *.{test,txt}`。它会查找任意名称（`*`）的文件，这些文件会与一个句点（`.`）连接，后面跟着`test`或`txt`扩展名。
- en: 'Next, in step 7, we combined a few things we have learned using pipes, `grep`,
    `xargs`, and a regex in the command: `echo "${STR1}" | grep -o [[:punct:]] | xargs
    echo`. The fact that the output from grep will be in `\n` delimited form (new
    lines for each instance found), this will break our intention to have all of the
    values echoed to the console in this form and thereby we need `xargs` to fix the
    output into parameters `echo` can properly use. For example, `echo "item1\n item2\n
    item3\n"` will not work, but with `xargs`, it will look like: `echo "item1"  "item2"
    "item3"`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第7步中，我们结合了通过管道、`grep`、`xargs`和正则表达式学到的一些内容，命令是：`echo "${STR1}" | grep -o
    [[:punct:]] | xargs echo`。由于`grep`的输出是以`\n`（换行符）分隔的形式（每个找到的实例一个新行），这会打破我们希望将所有值按这种形式回显到控制台的意图，因此我们需要`xargs`来修复输出，以便`echo`可以正确使用这些参数。例如，`echo
    "item1\n item2\n item3\n"`是无法工作的，但使用`xargs`后，它看起来像这样：`echo "item1"  "item2" "item3"`。
- en: 'And in the final command, we finally arrive at a *crazier* regex, which in
    truth is actually quite tame: `ls | grep -E "([[:upper:]])([[:digit:]])?.test?."
    | tail -n 5`. It introduces a couple of concepts, including groups (the parentheses),
    (`?`) wildcards, and how you can combine multiple expression components, and `tail`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的命令中，我们终于达到了一个*更疯狂*的正则表达式，实际上它其实相当简单：`ls | grep -E "([[:upper:]])([[:digit:]])?.test?."
    | tail -n 5`。它引入了一些概念，包括组（括号）、（`?`）通配符，以及如何组合多个表达式组件，并使用`tail`命令。
- en: 'Using `grep`, the `-E` (expression flag), and two groups (the expressions inside
    of the parenthesis), we can combine them with the `?` regex operator. This acts
    as a wildcard for a single character:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`grep`、`-E`（表达式标志）和两个组（括号内的表达式），我们可以将它们与`?`正则操作符组合使用。这个操作符是用于表示单个字符的通配符：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can see that the last five results were returned, starting with a capital
    letter, followed by a number, a character (either `.` or `,`), and then the word
    test and a number. We created one test file called `Z9..test2`. Notice how it
    was not included among the list items? This was because we did not use an expression
    like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，最后五个结果被返回，且第一个字母是大写，后跟一个数字，一个字符（可能是`.`或`,`），然后是“test”这个词和一个数字。我们创建了一个名为`Z9..test2`的测试文件。注意它没有包含在列表项中吗？这是因为我们没有使用这样的表达式：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In step 4, we run a particular regex using `grep` and `-oP` flags, `grep -oP
    'name="\K.*?(?=")' www.packtpub.com/index.html`, on top of our recently crawled
    archive of `www.packtpub.com`. The `-o` flag means output only matching values,
    and `-P`is for using the Perl expressions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们使用`grep`和`-oP`标志运行了一个特定的正则表达式，`grep -oP 'name="\K.*?(?=")' www.packtpub.com/index.html`，对我们最近抓取的`www.packtpub.com`的档案进行了处理。`-o`标志表示仅输出匹配的值，`-P`用于使用Perl正则表达式。
- en: Notice all of the values contained with double quotes? It's looking for *any*
    match that matches the pattern `name="anythingGoesHere"`.It's certainly not extremely
    useful by itself, but it illustrates the point of being able to quickly get values
    (for example, what if the name was very specific? You could alter `name=` to another
    value and get the exact same result!).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意那些被双引号包围的值吗？它是在寻找与模式`name="anythingGoesHere"`匹配的*任何*内容。单独来看，这并不特别有用，但它说明了快速提取值的一个方法（例如，如果`name`非常具体，你可以把`name=`改成其他值，得到完全相同的结果！）。
- en: Following along the same context, in step 5, we can also find *all* occurrences
    of `name=`: `grep -P 'name=' www.packtpub.com/index.html`. This type of command
    is useful for understanding the context of information or merely the existence
    of it; this comes back to the idea of looking for values in CSS, C/C++, and other
    data/source files.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的上下文中，在第5步中，我们也可以找到所有`name=`的出现：`grep -P 'name=' www.packtpub.com/index.html`。这种类型的命令对于理解信息的上下文或仅仅了解其存在非常有用；这回到我们寻找CSS、C/C++以及其他数据/源文件中的值的概念。
- en: Onward to step 6, we are looking for the title HTML tag. Normally, you should
    use a dedicated HTML parser, but if we wanted to use grep with regexes in a hurry—we
    can! The `tr '\n' ' ' < www.packtpub.com/index.html | grep -o '<title>.*</title>'` command
    uses the translate function (`tr`) to convert the `\n` or newline special character
    into an empty space. This is useful when data has a markup that may span multiple
    lines.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 进入第6步，我们需要寻找标题的HTML标签。通常情况下，你应该使用专门的HTML解析器，但如果我们想快速用grep结合正则表达式来处理——是完全可以的！`tr
    '\n' ' ' < www.packtpub.com/index.html | grep -o '<title>.*</title>'` 命令使用了转换函数(`tr`)，将`\n`或换行符特殊字符转换为空格。这在数据标记可能跨越多行时非常有用。
- en: 'In our closing step, we end with a bit of fine-tuning when performing broad
    searches. We simply use `grep` to provide us with the line number and filename.
    Using `cut`, we an trim the remaining characters of the output on the console
    (this can be really useful):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后的步骤中，我们将进行一些细化操作，以执行广泛的搜索。我们只需使用`grep`来提供行号和文件名。使用`cut`，我们可以修剪控制台输出中的剩余字符（这非常有用）：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Regexes can also be tested online using a number of regex simulators! One popular
    and free tool available online is: [https://regexr.com/](https://regexr.com/).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式也可以通过许多在线正则模拟器来测试！一个常见且免费的在线工具是：[https://regexr.com/](https://regexr.com/)。
- en: Don't forget that some regex functionalities also allow you to nest commands
    within groups! We didn't demonstrate this functionality, but it exists with acceptable
    results in some use cases!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，某些正则表达式功能也允许你在组内嵌套命令！我们没有演示这一功能，但它在某些使用场景中是有效的，并且结果是可以接受的！
- en: Math and calculations in script
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本中的数学和计算
- en: After a grueling introduction to the world of wildcards and regexes for searches,
    we're going to move on to being able to perform some basic mathematical operations
    at the console. If you haven't already tried, what happens when you run something
    like the following in the Bash shell? Does it look like this?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在经历了繁琐的通配符和正则表达式介绍后，我们将进入在控制台上执行一些基本数学运算的部分。如果你还没尝试过，运行类似以下命令会发生什么呢？它看起来是这样的：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Command not found? Certainly, we know the computer can do *math*, but clearly
    Bash is unable to interpret mathematical operations in this way. We have to ensure
    that Bash is able to **interpret **these operations correctly through the use
    of:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 命令未找到？当然，我们知道计算机能够进行*数学运算*，但显然Bash无法以这种方式解释数学运算。我们必须确保Bash能够通过以下方法正确**解释**这些操作：
- en: The `expr` command (antiquated)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expr` 命令（过时）'
- en: The **`bc` **command
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`bc`** 命令'
- en: POSIX Bash shell expansion
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX Bash shell 扩展
- en: Another language/program to do the *dirty* work
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个语言/程序来做这些*脏*活
- en: 'Let''s try again, but using the POSIX Bash shell expansion:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再试一次，但使用 POSIX Bash shell 扩展：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We got the expected answer of `5`, but where does this go wrong? It goes wrong
    when using division and floats because Bash works primarily with integers:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了期望的答案 `5`，但它错在哪里呢？它出错的地方在于使用除法和浮点数，因为 Bash 主要处理整数：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: True, `1` divided by `5` is `0`, but there is a remainder missing! And this
    is why we may rely on other methods to perform simple mathematics.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，`1` 除以 `5` 是 `0`，但缺少了一个余数！这就是为什么我们可能依赖其他方法来进行简单的数学运算。
- en: One of the many uses or reasons to use equations and `math` in a script is to
    determine sizes of file system partitions. Can you imagine what may happen if
    a disk becomes too full? Or that we may want to automatically archive a directory
    if it reaches a predetermined size? Of course, this is theoretical, but things
    can and do break if we let a file system silently become full!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方程和 `math` 在脚本中的众多用途之一是确定文件系统分区的大小。你能想象如果磁盘空间过满会发生什么吗？或者如果某个目录达到预定大小，我们可能想要自动归档它？当然，这只是理论上的，但如果我们让文件系统悄悄地变满，确实可能会发生故障！
- en: The following recipe is about determining the size of a tarball (and contents),
    the remaining available space on the destination partition, and whether the operation
    could continue or be canceled.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下这个方案是关于确定一个 tarball（及其内容）大小、目标分区剩余空间以及操作是否可以继续或取消的。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe is going to take into account a few interesting things:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案将考虑一些有趣的因素：
- en: Bash can't do everything well
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bash 并非无所不能
- en: Other utilities exist (for example, `bc`)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有其他工具（例如，`bc`）
- en: We can create our own in another language like C
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以用其他语言，比如 C，自己创建一个
- en: Creating a tarball
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 tarball
- en: Sometimes, on small embedded systems, Python might not be available, but Bash
    (or a close relative) and C are. This is where being able to perform math without
    extra programs (that may not be available) can come in handy!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在一些小型嵌入式系统上，Python 可能不可用，但 Bash（或其近亲）和 C 是可用的。这时，能够在没有额外程序（可能不可用）的情况下进行数学运算就显得非常方便！
- en: 'We will use the following command to make sure that we have all of the utilities
    installed for this experiment:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令来确保所有必要的工具已经安装，以便进行此次实验：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we need to create a tarball called `archive.tar.gz`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个名为 `archive.tar.gz` 的 tarball：
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We realize that the purpose of creating/compiling a simple program that is
    not written in Bash may be beyond the scope of this book, but it can be a helpful
    skill. To do this, we will need to install GCC, which is short for the GNU Compiler
    Collection. This sounds terribly complex and we assure you that we did all the
    hard work:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们意识到，创建/编译一个不是用 Bash 编写的简单程序的目的是超出了本书的范围，但这确实是一个有用的技能。为了做到这一点，我们需要安装 GCC，它是
    GNU 编译器集合的简称。听起来可能很复杂，但我们向你保证，我们已经做了所有的艰苦工作：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding command installs the compiler, and now we need the C source code
    (in order to compile a *simple* C program). Open up a console and retrieve the
    code using:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令安装了编译器，现在我们需要 C 源代码（以便编译一个*简单*的 C 程序）。打开控制台并通过以下命令获取代码：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This code is also available on Github at [https://github.com/PacktPublishing/Bash-Cookbook](https://github.com/PacktPublishing/Bash-Cookbook).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也可以在 Github 上找到，链接：[https://github.com/PacktPublishing/Bash-Cookbook](https://github.com/PacktPublishing/Bash-Cookbook)。
- en: 'To compile the code, we will use `gcc` and `-lm` (this refers to `libmath`)
    as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译这段代码，我们将使用 `gcc` 和 `-lm`（指的是 `libmath`），如下所示：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the compiler completes successfully (which it should), you will be left
    with a utility binary called `mhelper` (or math helper). We can also add this
    to our list of local commands by copying it to `/bin` using `sudo` and `cp`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器成功完成（应该是的），你将得到一个名为 `mhelper`（或数学助手）的工具二进制文件。我们也可以通过使用 `sudo` 和 `cp` 将它复制到
    `/bin` 来将其添加到本地命令列表中：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, `mhelper` can be used for basic operations such as division, multiplication,
    addition, and subtraction:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`mhelper` 可以用来进行基本的运算，如除法、乘法、加法和减法：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `mhelper` code is not designed to be particularly robust and to handle specific
    edge cases, but rather to demonstrate that another utility can be used. Python
    and numpy would be an excellent alternatives!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`mhelper` 代码并不是为了特别强大且能处理特定边缘情况而设计的，而是为了演示另一个工具的使用。Python 和 numpy 会是很好的替代品！'
- en: How to do it...
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Using the `mhelper` binary, `bc`, and other expressions, we can begin the recipe:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `mhelper` 二进制文件、`bc` 和其他表达式，我们可以开始这道菜谱：
- en: 'Begin by opening a terminal and an editor to create a new script called `mathexp.sh`with
    the following contents:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开终端和编辑器，创建一个新的脚本文件 `mathexp.sh`，并在其中添加以下内容：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, running the script should produce an output similar to the following:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行脚本应该会产生类似于以下的输出：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Great! So we can use Bash size calculations, the `bc` command, and our binary.
    If you want to calculate the radius of a circle (which will certainly get you
    a float value) or a percentage, for example, you will need to be aware of this
    limitation in Bash.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒！所以我们可以使用 Bash 大小计算，`bc` 命令和我们的二进制。如果你想计算一个圆的半径（这肯定会得到一个浮动值）或者一个百分比，例如，你将需要注意
    Bash 中这个限制。
- en: To bring this recipe to a close, it is important to note that the `expr` command
    still exists, but it is deprecated. Using `$(( your equation ))` is recommended
    as the preferred method in new scripts.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后值得注意的是，`expr` 命令仍然存在，但它已经被弃用。建议在新的脚本中使用 `$(( 你的方程式 ))` 作为首选方法。
- en: Using the same premise using the `mhelper` binary or `$((..))` scripting, you
    can also calculate percentages for situations that need variable output (for example,
    not whole numbers). For example, calculating screen sizes based on percentages
    while a whole number will be desired, you can then round up or down post calculation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的前提条件，利用 `mhelper` 二进制文件或 `$((..))` 脚本，你还可以计算需要变量输出的情况的百分比（例如，不是整数的情况）。例如，在计算基于百分比的屏幕尺寸时，虽然你会期望得到一个整数，你也可以在计算后进行四舍五入。
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'First things first, as this recipe alluded to—we noticed that the Bash shell
    doesn''t like decimal numbers with fractions or even non-whole numbers. Wait,
    math!? Unfortunately, we can''t hide all the details, but in programming, there
    are a couple of concepts that you should be aware of:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如这个教程所暗示的那样——我们注意到 Bash shell 不喜欢带有小数点或甚至非整数的十进制数字。等等，数学！？不幸的是，我们无法隐藏所有细节，但在编程中，有几个概念是你应该了解的：
- en: Signed and unsigned numbers
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号和无符号数字
- en: Floats, doubles, and integers
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数、双精度数和整数
- en: The first concept is fairly simple—current computers are binary, which means
    they compute using zeros (0) and ones (1). This means that they work in powers
    of 2^. Without getting into a lesson about basic computer science, if you see
    a value (datatype) that is an int (integer) and that it is a 32 bit number, this
    means that the maximum value if it begins at `0` is `4,294,967,295` in decimal
    (2^32). This makes one critical assumption and that is that all numbers (0 included)
    are positive. This positive or negative property is called **sign**! If a datatype
    mentions signed or unsigned—now you know what it means!
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个概念相当简单——当前的计算机是二进制的，这意味着它们使用零（0）和一（1）进行计算。这意味着它们的运算是基于 2^ 的幂次进行的。在不深入基础计算机科学课程的情况下，如果你看到一个数据类型是
    int（整数），并且它是一个 32 位数字，那么如果它从 `0` 开始，最大值是十进制下的 `4,294,967,295`（2^32）。这做出了一个关键假设，那就是所有数字（包括
    0）都是正数。这个正负特性叫做 **符号**！如果数据类型提到有符号或无符号——现在你知道它是什么意思了！
- en: However, there is a consequence of whether something is signed and that is that
    the maximum positive or negative value is decreased because one bit is used to
    represent sign. A signed 32 bit int (which can also be referred to as `int32`)
    shall now have a range of `(-)2,147,483,647` to `(+)2,147,483,647`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，是否带符号会有一个后果，那就是最大正数或负数的值会减少，因为一个比特用于表示符号。一个有符号的 32 位 int（也可以称为 `int32`）现在的范围是
    `(-)2,147,483,647` 到 `(+)2,147,483,647`。
- en: As a note from the author, I realize that some of the computer science definitions
    are not computer science correct, meaning that I tweaked some of their meanings
    to make sure the key points got across in *most* general situations.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 作为作者的说明，我意识到一些计算机科学的定义并不完全符合计算机科学的标准，意思是我稍微调整了它们的含义，以确保在 *大多数* 一般情况下关键点能清晰传达。
- en: On another note, Bash only uses integers and you may have already seen that
    when you divide a value like `1/5`, the answer is `0`. True, it is not divisible,
    but the answer is `0.20` as a fraction. We also cannot multiply numbers that have
    a decimal point as well! Therefore, we have to use other programs such as `bc`
    or `mhelper.`
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Bash 只使用整数，可能你已经看到，当你将一个值像 `1/5` 进行除法时，结果是 `0`。没错，它无法整除，但结果是 `0.20`（作为一个小数）。我们也不能对带有小数点的数字进行乘法运算！因此，我们必须使用其他程序，比如
    `bc` 或 `mhelper`。
- en: If you are keen on computers, you also know that there are floats, doubles,
    and other datatypes to represent numbers. `Mhelper` and `bc` can help you deal
    with these types of numbers when the concept of integers fails (for example, resulting
    numbers are not whole numbers when dividing).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对计算机有兴趣，你也知道有浮点数、双精度数和其他数据类型来表示数字。`Mhelper`和`bc`可以帮助你处理这些类型的数字，当整数的概念无法使用时（例如，除法得到的数字不是整数时）。
- en: 'Back to the recipe, and in step 1:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到步骤 1：
- en: We created a script that will check the `/home` directory to determine how much
    size is available using the `df` command. Using `tail`, another command that can
    be used to reduce output, we skip the first line of output and pipe all output
    into the `$CURRENT_PART_ALL`variable(or all current partition information).
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个脚本，它将检查`/home`目录，使用`df`命令确定有多少可用空间。通过使用`tail`，另一个可以用来减少输出的命令，我们跳过了输出的第一行，并将所有输出通过管道传入`$CURRENT_PART_ALL`变量（或所有当前分区信息）。
- en: 'Then, the contents of the `$CURRENT_PART_ALL` variable are read into an array
    using the `read`command. Notice the use of the re-direction errors: `<<<`. This
    is called a **her****e-string**, which in simple terms expands the variable and
    feeds it into `` `stdin.` ``'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，`$CURRENT_PART_ALL`变量的内容通过`read`命令读入一个数组。注意错误重定向的使用：`<<<`。这被称为**her****e-string**，简单来说就是展开变量并将其传递到``
    `stdin.` ``。
- en: Now, the `/home` partitions storage information is inside of an array, and we
    have a `tarball` (or a file that compresses and contains the contents within),
    where we need to know the size of the contents within the `tarball.` To do this,
    we use a long-winded command with multiple piped commands, which retrieves the
    size of the contained elements and pushes them through the `bc` command.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，`/home`分区的存储信息已经在一个数组中，我们有一个`tarball`（或压缩并包含内部内容的文件），我们需要知道`tarball`内部内容的大小。为此，我们使用一个冗长的命令，通过多个管道命令来获取包含元素的大小，并将其传递给`bc`命令。
- en: Upon determining the size of the elements contained within our archive, we validate
    the calculated size against the remaining available space. This value is inside
    of the `array element[1]`. If the available space is less than equal to the extracted
    files, then exit. Otherwise, print the remaining size after performing.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在确定我们归档文件中包含的元素大小后，我们将计算出的大小与剩余可用空间进行验证。这个值位于`array element[1]`中。如果可用空间小于等于提取的文件，则退出。否则，执行后打印剩余空间。
- en: For fun, we combined forking a subshell to retrieve the division results of
    the `mhelper`, which are piped through `bc`. This is so we can determine if there
    is enough space as a mere `boolean` value of true (1) or false (0).
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了好玩，我们结合了分叉子壳程序以获取`mhelper`的除法结果，这些结果通过`bc`管道传递。这样，我们就能确定是否有足够的空间，并以`boolean`值为真（1）或假（0）表示。
- en: Since we assume we have enough space, we untar (decompress and extract the contents)
    the `$TARBALL`. If the `tar` command returns a value not equal to `0`, then exit
    with an error. Otherwise, exit with success.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们假设有足够的空间，我们解压（解压并提取内容）`$TARBALL`。如果`tar`命令返回的值不等于`0`，则退出并报错。否则，退出并表示成功。
- en: After executing our script, the contents of the tarball (`empty.bin`) should
    be present in the current working directory.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行脚本后，tarball（`empty.bin`）的内容应该出现在当前工作目录中。
- en: Inside of the script, we put two different evaluations in the comments, which
    would return floating point values or errors in syntax. We included them for your
    awareness and to drive the main lesson home.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们在注释中加入了两个不同的评估，它们会返回浮动值或语法错误。我们加入它们是为了提醒你并帮助强化主要的教学内容。
- en: Did we miss anything? Absolutely! We never checked the size of the tarball itself
    and made sure that its size was among the used space when performing a check to
    determine the remaining free space. One should always be careful when performing
    and enforcing size restrictions!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们错过了什么吗？当然有！我们从未检查过tarball本身的大小，也没有确保它的大小包括在执行检查以确定剩余可用空间时的使用空间中。进行和强制大小限制时，一定要小心！
- en: Striping/altering/sorting/deleting/searching strings with Bash only
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仅使用Bash进行字符串的剥离/修改/排序/删除/查找
- en: 'So far, we have seen inkling of the power of commands available in Linux, and
    some of these are among the most powerful: `sed` and `grep`. However, while we
    can easily use these commands together, *sed by itself* or even using another
    very useful command called `awk`, we can leverage Bash itself to shave time and
    reduce external dependencies in a portable way!'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到 Linux 中可用命令的强大之处，其中一些命令是最强大的：`sed` 和 `grep`。然而，尽管我们可以轻松地将这些命令一起使用，*仅使用
    sed* 或者使用另一个非常有用的命令 `awk`，我们也可以利用 Bash 本身来节省时间并减少外部依赖，从而实现可移植的解决方案！
- en: 'So, how can we do this? Let''s begin with a few examples using this Bash syntax:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该怎么做呢？让我们从几个使用 Bash 语法的例子开始：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding example, we can see a special way of calling special substring
    functionality using `${...}`, where `VARIABLE` is a string variable within your
    script (or even global), and then the following variable is the `:`.After the
    `:`, there is the `startingPosition` parameter(remember that strings are just
    arrays of characters and each character can be addressed by index), and there
    is another optional semicolon and length parameter (`optionalLength`).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到一种特殊的调用子字符串功能的方式，使用 `${...}`，其中 `VARIABLE` 是脚本中的字符串变量（甚至是全局变量），接下来的变量是
    `:`。在 `:` 后面是 `startingPosition` 参数（记住字符串就是字符数组，每个字符可以通过索引访问），并且还有一个可选的分号和长度参数（`optionalLength`）。
- en: 'If we ran this script, the output would be:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个脚本，输出会是：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'How is this possible, you may ask? Well, its possible with Bash''s equivalent
    of `substr` (a function in C and many other programming languages), and this is
    achieved through the usr of the **`${...}`**syntax. This tells bash to look inside
    for a variable named `VARIABLE` and then for two parameters: to start at byte/character
    `3` (technically `4` because arrays start at element `0` in Bash) and a length
    of `4` (to print only four characters). The result of the echo is `test`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，这怎么可能呢？嗯，这可以通过 Bash 中等效的 `substr`（C 语言和许多其他编程语言中的函数）来实现，具体通过使用 **`${...}`**
    语法。这告诉 bash 查找名为 `VARIABLE` 的变量，并获取两个参数：从字节/字符 `3`（技术上是 `4`，因为在 Bash 中数组是从元素 `0`
    开始的）开始，长度为 `4`（只打印四个字符）。`echo` 的结果是 `test`。
- en: Can we do more with this, such as removing the last character? Deleting words?
    Searching? Of course, and all of this is covered in this recipe!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做更多吗？比如去除最后一个字符？删除单词？搜索？当然可以，所有这些内容都会在本教程中讲解！
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'Let''s get ready for the exercise by creating some data sets which mimic common
    daily problems:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一些模拟常见日常问题的数据集来准备练习：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using these two CSVs, we are going to:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个 CSV 文件，我们将：
- en: Remove the extra spaces on the first two lines of `garbage.csv`
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 去掉 `garbage.csv` 前两行的多余空格
- en: Remove the last character from each line in `garbage.csv`
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除 `garbage.csv` 中每行的最后一个字符
- en: Change the case of each character to uppercase in the first two lines of `garbage.csv`
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `garbage.csv` 中前两行的每个字符转换为大写
- en: Replace `Bob` with `Robert` in `employees.csv`
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `employees.csv` 中的 `Bob` 替换为 `Robert`
- en: Insert a `#` at the beginning of each line in `employees.csv`
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `employees.csv` 每行的开头插入一个 `#`
- en: Remove the exact date of birth column/field in each line of `employees.csv`
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除 `employees.csv` 中每行的精确出生日期列/字段
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s begin our activity:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始我们的活动：
- en: 'Open a new terminal and a new file with your preferred editor. Add in the following
    contents into the new script and save it as `builtin-str.sh`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端，并用你喜欢的编辑器打开一个新文件。将以下内容添加到新脚本中，并将其保存为 `builtin-str.sh`：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Execute the script with `bash builtin-str.sh`and notice how we were able to
    strip the last character from a string and even compare strings.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行脚本 `bash builtin-str.sh` 并注意我们如何从字符串中剥离最后一个字符，甚至比较字符串。
- en: 'Again, open a new file called `builtin-strng.sh`and add the following contents
    into it:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，打开一个名为 `builtin-strng.sh` 的新文件，并将以下内容添加到其中：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let''s strip the garbage—remove spaces:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们去除垃圾—去掉空格：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s remove the last character from each line:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除每行的最后一个字符：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, let's turn all of the characters into uppercase!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将所有字符都转换为大写！
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We will delete the day in the `birth` column. The field to remove is 5 (but
    this is really -4):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将删除 `birth` 列中的日期。要删除的字段是 5（但实际上是 -4）：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Execute the script with `bash builtin-strng.sh`and review the output.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行脚本 `bash builtin-strng.sh` 并查看输出。
- en: Did you notice all of the opportunities to re-direct input or output? Imagine
    the possibilities! Furthermore, much of the previous script can be performed using
    another tool called AWK instead.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到所有重定向输入或输出的机会？想象一下这些可能性！此外，之前的许多脚本可以改用另一个工具AWK来执行。
- en: How it works...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe is a bit iterative, but it should *re-iterate*(pardon the pun)
    to demonstrate that Bash has a fair number of functionalities built-in to manipulate
    strings or any structured data. There is a basic assumption though and that is
    based on many OSes using C programs:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这份食谱有些迭代性，但它应该*反复强调*（请原谅这个双关语）来展示Bash内置了相当多的功能来操作字符串或任何结构化数据。然而，有一个基本假设，那就是许多操作系统使用C语言编写程序。
- en: A string is an array of characters
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串是字符的数组。
- en: Characters such as `','` are the same as any other character
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像`,`这样的字符和其他任何字符一样。
- en: Therefore, we can evaluate or test for the existence of a character to separate
    fields from lines and even use this to build arrays
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，我们可以评估或测试某个字符的存在，用于分隔行中的字段，甚至用它来构建数组。
- en: 'Now, reviewing the steps in this recipe:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回顾一下这份食谱中的步骤：
- en: 'After running the script, we have the following output in the console:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本后，我们在控制台上得到了以下输出：
- en: '[PRE43]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We began with the string `STR="1234567890asdfghjkl"`and as the script ran in
    the first step:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从字符串`STR="1234567890asdfghjkl"`开始，当脚本在第一步运行时：
- en: In the first step, we printed out a single character starting at the zero (0)
    position. Remember that this is an array, and position `0` is the starting element.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一步中，我们从位置零（0）开始打印出一个字符。记住，这是一个数组，位置`0`是起始元素。
- en: 'Next, we retrieved the first three characters to arrive at: `123`.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们提取了前三个字符，得到：`123`。
- en: 'However, what if we wanted all of the characters after position 3? We would
    used `${STR: 3}` instead of `${STR: 0-3}`.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '然而，如果我们想要获取位置3之后的所有字符怎么办？我们可以使用`${STR: 3}`而不是`${STR: 0-3}`。'
- en: 'Then, given the preceding point, if we wanted the characters at position 4
    (the forth element in the array, but this is addressed at position three (3) because
    counting begins at zero (0)), we use `${STR: 3: 3}`.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '然后，基于之前的内容，如果我们想要获取位置4的字符（数组中的第四个元素，但由于从零（0）开始计数，因此这是位置三（3）），我们使用`${STR: 3:
    3}`。'
- en: And finally, to get only the last character, we can use `${STR:-1}`.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，要仅获取最后一个字符，我们可以使用`${STR:-1}`。
- en: To finish the first script in the recipe, we had three more strings. If we wished
    to compare them to each other, we can do so using conditional logic. Remember
    that bcd is less than BCD.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成食谱中的第一个脚本，我们还需要三个字符串。如果我们希望将它们彼此比较，可以使用条件逻辑来实现。记住，bcd小于BCD。
- en: Comparing strings using simple Bash constructs can be useful when you want to
    write a script that quickly compares filenames for a specified execution. For
    example, run the `001-test.sh` script before `002-test.sh`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的Bash构造来比较字符串非常有用，当你想写一个脚本来快速比较文件名以指定执行顺序时。例如，先运行`001-test.sh`脚本，再运行`002-test.sh`。
- en: 'In the second half of the recipe, we begin with a long-winded script to duplicate
    in an easily explained manner. We covered some of the tricks you can use with
    the Bash shell without using AWK and SED:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这部分食谱中，我们从一个冗长的脚本开始，以易于解释的方式进行复制。我们涵盖了在不使用AWK和SED的情况下，你可以在Bash shell中使用的一些技巧：
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here is the breakdown of the script, but a brief introduction is required for
    **arrays**, **readarray**, **IFS**, and **oldIFS. **The point of the exercise
    is to not go into a great lesson on arrays (this will happen later), but to know
    that you can use them automatically to create dynamic lists of things such as
    files or lines within a file. They are referred to using the `${ARR[@]}` notation,
    and each element can be referred to by its index value within the square brackets `[...]`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这是脚本的详细解析，但在此之前需要简要介绍**数组**、**readarray**、**IFS**和**oldIFS**。这个练习的重点不是深入讲解数组（这将在后面讨论），而是要知道你可以自动使用它们来创建动态列表，例如文件或文件中的行。它们通过`${ARR[@]}`符号引用，且每个元素可以通过其索引值在方括号`[...]`中引用。
- en: 'The `readarray` command parses the input into an array using the `IFS` and
    `oldIFS` variables. It separates the data based on a common delimiter (IFS), and
    oldIFS can maintain the old values, should they be altered:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`readarray`命令使用`IFS`和`oldIFS`变量将输入解析成数组。它根据一个共同的分隔符（IFS）分隔数据，如果这些值被修改，oldIFS可以保持原值：'
- en: In the first step, we use read in the `garbage.csv` (`${GB_CSV}`) and then `${#ARR[@]}`
    to retrieve the number of elements in the array. We don't use this value, but
    it is interesting to note the structure of your file and whether it is being read
    in correctly. Then, for each member of the array, we remove the empty spaces by
    counting the number of spaces and then removing them with an additional while
    loop, performing `${i/, /,}`until we're done. The corrected values are then re-inserted
    into the array.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一步中，我们使用read读取`garbage.csv`（`${GB_CSV}`），然后使用`${#ARR[@]}`来获取数组中元素的数量。我们不使用这个值，但值得注意的是文件的结构以及它是否被正确读取。然后，对于数组中的每个成员，我们通过计算空格的数量来移除空格，再通过额外的while循环，执行`${i/,
    /,}`直到完成。修正后的值然后重新插入到数组中。
- en: In the next step, we use `${i::-1}` and a for loop to remove the last character
    from each line. Then, the result is re-inserted into the array.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一步中，我们使用`${i::-1}`和for循环来删除每行的最后一个字符。然后，将结果重新插入到数组中。
- en: Using a `for` loop and `ARR[$INC]=${i^^}`, all characters in the array are made
    uppercase, and we print out the array using `printf `(more on this later in another
    recipe).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`for`循环和`ARR[$INC]=${i^^}`，数组中的所有字符都被转为大写，我们使用`printf`打印数组（稍后在其他示例中会详细介绍）。
- en: On to `employees.csv`, we read it into the array again using `readarray.` Then,
    we add a hash sign (`#`) to the beginning of each line and re-insert it into the `ARR[$INC]="#${i}"` array.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是`employees.csv`，我们再次使用`readarray`将其读入数组。然后，我们在每一行的开头添加一个井号（`#`），并将其重新插入到`ARR[$INC]="#${i}"`数组中。
- en: 'Then, we search for the substring `Bob` and replace it with `ARR[$INC]=${i/Bob/Robert} `.
    To use the built-in search and replace functionality, we use the following syntax:
    **`${variable/valueToFind/valueToReplaceWith}`**. Notice that this is also the
    same premise behind the space removal performed in an earlier step.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们搜索子字符串`Bob`并用`ARR[$INC]=${i/Bob/Robert}`替换它。要使用内建的查找和替换功能，我们使用以下语法：**`${variable/valueToFind/valueToReplaceWith}`**。请注意，这也是前面步骤中移除空格所用的原理。
- en: The final step is a bit more complicated and a bit *long in the tooth*, meaning
    it could be shortened and performed using another tool such as AWK, but for the
    purpose of an easy to read example—it was written a bit like a C program. Here,
    we want to remove the actual birthday value (0-31), or column 5 (the index is
    4 if we consider that arrays begin at 0). To begin, we iterate through the array
    using a for loop, and then we use read to take the input value as an array, too!
    Then, for each field in the array `${ELEM_ARR[@]}`, we then check to see if it
    is not the first value, and also not the column we wish to remove. We build the
    correct string via concatenation and then re-insert it into the array before printing
    each value using `echo`.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一步稍微复杂一点，*有点冗长*，意味着它可以通过使用其他工具如AWK来缩短和执行，但为了让示例易于阅读——它写得有点像C程序。这里，我们要删除实际的生日值（0-31），或者说是第5列（如果考虑到数组从0开始，索引是4）。首先，我们使用for循环遍历数组，然后使用read将输入值也作为数组！接着，对于数组`${ELEM_ARR[@]}`中的每个字段，我们检查它是否不是第一个值，也不是我们希望删除的列。我们通过连接构建正确的字符串，然后将其重新插入数组，再使用`echo`打印每个值。
- en: '**Arrays** are a data construct and the important thing to think about data
    is that it can be manipulated in a number of ways. Just like how we split a file
    line by line to create an array of elements, we can also split those elements
    into arrays of their own!'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组**是一种数据结构，重要的是要考虑数据可以以多种方式进行操作。就像我们如何按行拆分文件以创建元素数组一样，我们也可以将这些元素拆分成自己的数组！'
- en: Using SED and AWK to remove/replace substrings
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SED和AWK来删除/替换子字符串
- en: Again, when we need to remove a pesky character or remove sections of strings
    upon occurrence, we can always rely on these two powerful commands: `sed`and `awk`.
    And while we saw that Bash does indeed have a similar functionality built-in,
    the full tools are able to offer the same and more complex functionality. So,
    when should we use these tools?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当我们需要删除某个恼人的字符或删除字符串中的某些部分时，我们总是可以依赖这两个强大的命令：`sed`和`awk`。虽然我们看到Bash确实有类似的内建功能，但完整的工具能提供相同的功能甚至更复杂的功能。那么，我们什么时候应该使用这些工具呢？
- en: When we care less about the speed that might be gained by using the built-in
    functionality of Bash
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们不太关心通过使用Bash内建功能可能获得的速度时
- en: When more complex features are needed (when programming constructs like multi-dimensional
    arrays are required or editing streams)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要更复杂的功能时（例如需要多维数组或编辑流等编程结构）
- en: When we are focused on portability (Bash might be embedded or a limited version
    and standalone tools may be required)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们专注于可移植性时（Bash可能被嵌入或是一个有限版本，并且可能需要独立工具）
- en: Complete books have been written on both SED and AWK, and you can always find
    far more information online at [https://www.gnu.org/software/sed/](https://www.gnu.org/software/sed/)
    and [https://www.gnu.org/software/gawk/](https://www.gnu.org/software/gawk/).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有完整的书籍写了关于SED和AWK，你可以随时在[https://www.gnu.org/software/sed/](https://www.gnu.org/software/sed/)和[https://www.gnu.org/software/gawk/](https://www.gnu.org/software/gawk/)上找到更多信息。
- en: '**Stream editor** (**SED**) is a handy text manipulation tool that is great
    for one-liners and offers a simple programming language and regex matching. Alternatively,
    AWK is also powerful and arguably more than SED. It offers a more complete programming
    language with a variety of data structures and other constructs. However, it is
    better suited when working with files such as CSVs, which may contain fields or
    structured data, but SED can be better when working with text substitutions when
    working with pipes (for example, `grep X | sed ... > file.txt`).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**流编辑器**（**SED**）是一个方便的文本处理工具，非常适合一行命令，并提供一个简单的编程语言和正则表达式匹配。或者，AWK也是强大的，可以说比SED更多。它提供了一个更完整的编程语言，具有各种数据结构和其他构造。但是，当处理可能包含字段或结构化数据的文件（例如CSV）时，它更适合。然而，当使用管道（例如`grep
    X | sed ... > file.txt`）时，SED在处理文本替换时可能更好。'
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s get ready for this exercise by creating some data sets which mimic common
    daily problems:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一些模仿常见日常问题的数据集来为这个练习做好准备：
- en: '[PRE45]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Using these two CSVs, we are going to:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个CSV文件，我们将要：
- en: Remove the extra spaces on the first two lines of `garbage.csv`
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`garbage.csv`的前两行中移除额外的空格。
- en: Remove the last character from each line in `garbage.csv`
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`garbage.csv`中的每行删除最后一个字符。
- en: Change the case of each character to uppercase in the first two lines of `garbage.csv`
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`garbage.csv`的前两行中将每个字符的大小写更改为大写。
- en: Replace `Bob` with `Robert` in `employees.csv`
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`employees.csv`中用`Robert`替换`Bob`。
- en: Insert a `#` at the beginning of each line in `employees.csv`
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`employees.csv`的每行开头插入一个`#`。
- en: Remove the exact date of the birth column/field in each line of `employees.csv`
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每行的`employees.csv`中移除出生日期列/字段的确切日期。
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'As with the exercise using Bash only, we are going to perform a similar recipe
    as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 就像只使用Bash练习一样，我们将执行类似的操作如下：
- en: 'Create a script called `some-strs.sh`with the following content and open a
    new terminal:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`some-strs.sh`的脚本，并使用以下内容打开一个新的终端：
- en: '[PRE46]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Execute the script and review the results.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本并查看结果。
- en: 'Create another script called `more-strsng.sh` and then execute it:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 创建另一个名为`more-strsng.sh`的脚本，然后执行它：
- en: '[PRE47]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We want to add a `#` at the beginning of each line and we will also use the
    `sed` tool on a per file basis. We just want to strip Bob out and change his name
    to Robert by manipulating the file in-place:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在每行开头添加`#`，并且我们还将在每个文件基础上使用`sed`工具。我们只需删除Bob并通过对文件进行操作而将其更改为Robert：
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Examine the results—was it simpler to get the results to the recipes that leverage
    only bash built-in constructs? Likely yes in many situations, IF they are available.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 检查结果——是否更容易获得仅使用Bash内置构造的配方的结果？在许多情况下可能是的，如果它们可用的话。
- en: How it works...
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: After running the two scripts in this recipe, we can see a few items emerge
    (especially if we compare the built-in Bash functionality for searching, replacing,
    and substrings).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行本教程中的两个脚本后，我们可以看到一些项目出现（特别是如果我们比较内置的Bash功能用于搜索、替换和子字符串）。
- en: 'After executing `some-strs.sh`, we can see the following output in the console:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行`some-strs.sh`后，我们可以在控制台中看到以下输出：
- en: '[PRE49]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: At this point, we have seen the `echo` command used several times, but the `-n`
    flag means that we should not automatically create a new line (or carriage return).
    The `<<<` re-direct for inputting values as a string has also been previously
    used, so this should not be new information. Given that, in the first instance,
    we are using `sed` like this: `sed 's/.//2g' <<< $STR` . This script uses `sed`
    in very simple ways compared to the plethora of ways you can combine pure sed
    with regexs. First, you have the command (`sed`), then the parameters (`'s/.//2g'`),
    and then the input (`<<< $STR`). You can also combine parameters like this: `'s/.//2g;s/','/'.'/g'`
    . To get the first character, we use `sed` in substitute mode (`s/`) and we retrieve
    two characters using (`/2g`), where `g` stands for global pattern.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经多次看到 `echo` 命令的使用，但 `-n` 标志意味着我们不应自动创建新的一行（或回车）。`<<<` 输入重定向用于将值作为字符串输入，这之前也已经使用过，因此这不会是新信息。基于这一点，在第一次使用
    `sed` 时，我们这样写：`sed 's/.//2g' <<< $STR`。与通过正则表达式结合 `sed` 的各种方式相比，这个脚本中的 `sed` 使用非常简单。首先，你有命令（`sed`），然后是参数（`'s/.//2g'`），接着是输入（`<<<
    $STR`）。你也可以像这样组合参数：`'s/.//2g;s/','/'.'/g'`。要获取第一个字符，我们在替换模式（`s/`）中使用 `sed`，并通过（`/2g`）来获取两个字符，其中
    `g` 代表全局模式。
- en: The reason it is `2g` and not `1g` is that a null byte is returned automatically
    and therefore, if you desire *n* characters then you must specify *n+1* characters.
    To return the first three characters, we merely change the `sed` parameters to
    include `4g` instead of `2g.`
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以是 `2g` 而不是 `1g`，是因为会自动返回一个空字节，因此，如果你需要 *n* 个字符，那么必须指定 *n+1* 个字符。要返回前三个字符，我们只需要将
    `sed` 参数中的 `2g` 改为 `4g`。
- en: In the next block of the script, we use sed as follows: `sed -r 's/.{3}//'`
    and `sed -r '$s/.{3}//;s/.//4g'` . You can see that in the first execution of
    `sed`, `-r` is used to specify a regex and so we use the regex to return the string
    at position 4 (again, those pesky arrays and strings) and everything beyond. In
    the second instance, we combine starting at the third character but limit the
    output to only 3 characters.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的下一个代码块中，我们使用如下的 `sed`：`sed -r 's/.{3}//'` 和 `sed -r '$s/.{3}//;s/.//4g'`。你可以看到，在第一次执行
    `sed` 时，`-r` 用于指定正则表达式，因此我们使用正则表达式返回位置为 4 的字符串（再次提到，那些麻烦的数组和字符串），以及后续的内容。在第二次执行时，我们从第三个字符开始，但限制输出只包含
    3 个字符。
- en: In the third block of script, we want the final character of the string using
    `sed 's/.*\(.$\)/\1/'` and then get the entire string *except* the last character
    using `sed 's/.$//'`. In the first instance, we use grouping and wildcards to
    create the regular expression to return only one character (the last character
    in the string), and in the second instance, we use the `.$` pattern to create
    an expression that returns everything minus the last character.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的第三个代码块中，我们想要获取字符串的最后一个字符，使用 `sed 's/.*\(.$\)/\1/'`，然后使用 `sed 's/.$//'` 获取去掉最后一个字符的整个字符串。第一次，我们使用分组和通配符创建正则表达式，只返回一个字符（即字符串中的最后一个字符）；而在第二次，我们使用
    `.$` 模式创建一个表达式，返回去掉最后一个字符的所有内容。
- en: It is important to note that search and replace can also be used for deletion
    operations by specifying an empty value to replace. You can also use the `-i`
    flag for in-place edits and to also perform deletion using other flags/parameters.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，搜索和替换也可以通过指定空值来执行删除操作。你还可以使用 `-i` 标志进行就地编辑，并通过其他标志/参数执行删除。
- en: 'Onto the next script, and after execution, the console should look similar
    to the following:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入下一个脚本，执行后，控制台应该类似如下所示：
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Again, in the first block of code, we read in the CSV into an array and for
    each element, we perform a substitution to remove the spaces: `sed ''s/ //g''`.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在第一个代码块中，我们将 CSV 读取到数组中，并且对每个元素进行替换操作，去除空格：`sed 's/ //g'`。
- en: In the second block, again, we iterate through the array, but we remove the
    last character, `sed  's/.$//'`, and then pipe the output to convert everything
    to uppercase using `sed -e 's/.*/\U&/'`. In the first part of the pipe, we search
    for the last character using `.$` and remove it (the `//`). Then, we use an expression
    to select everything and convert it to upper case using `\U&` (notice that it
    is a special case allowed by GNU sed). Lowercase can be achieved using `\L&` instead.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个代码块中，我们再次遍历数组，但我们去掉最后一个字符，使用 `sed 's/.$//'`，然后将输出通过管道转换为大写，使用 `sed -e 's/.*/\U&/'`。在管道的第一部分，我们使用
    `.$` 搜索最后一个字符并将其移除（`//`）。接着，我们使用表达式选择所有内容，并通过 `\U&` 将其转换为大写（注意，这是 GNU sed 允许的特殊情况）。如果需要小写，则可以使用
    `\L&`。
- en: In the third block, again, we used a for each loop and a subshell, but we didn't
    echo the input into `sed.` Sed also takes input like this using the `<<<` input
    direction. Using `sed -e 's/^/#/'`, we start at the beginning of the string (specified
    by the `^`) and append a `#`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个代码块中，我们再次使用了`for each`循环和子Shell，但我们没有将输入回显到`sed`。Sed也可以通过`<<<`输入方向来接受这样的输入。使用`sed
    -e 's/^/#/'`，我们从字符串的开头（由`^`指定）开始，添加一个`#`。
- en: Next, for the last three examples, we perform work on the actual files themselves
    and *not* the arrays loaded into memory by using `sed` with the `-i` flag. This
    is an important distinction as it will have direct consequences on the files used
    as input; this is probably what you desire in your scripts anyway!To replace `Bob`
    with `Robert,` it is the same as removing spaces except we specify the replacement.
    However, we are performing the replacement on the *entire* input CSV file! We
    can also add the hash sign for each line in the file, too.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于最后三个示例，我们将在实际文件本身上执行操作，而*不是*内存中加载的数组，方法是使用带有`-i`标志的`sed`。这是一个重要的区别，因为它会对作为输入使用的文件产生直接影响；这很可能是你在脚本中所期望的！要将`Bob`替换为`Robert`，这和删除空格一样，只是我们指定了替换内容。然而，我们是在对*整个*输入的CSV文件进行替换！我们还可以为文件中的每一行添加哈希符号。
- en: In the final example, we briefly use AWK to show the power of this utility.
    In this example, we specify the delimiters (FS and OFS) and then we specify the
    fifth column alongside the `gsub sub` command in the AWK language to remove the
    column or field. Begin specifies the rules AWK shall use when parsing input and
    if there are multiple rules, the order received is the order executed.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个示例中，我们简要使用AWK来展示这个工具的强大。在这个示例中，我们指定了分隔符（FS和OFS），然后使用AWK语言中的`gsub sub`命令指定第五列来删除该列或字段。Begin指定了AWK在解析输入时使用的规则，如果有多个规则，则按照接收到的顺序执行。
- en: Alternatively, we can print the first column or field using `awk 'BEGIN { FS=","}
    { print $1}'  testdata/employees.csv` and even the first occurrence by specifying
    `NR==1` like this: `awk ' BEGIN { FS=","} NR==1{ print $1}' `. Specifying the
    number or returned records is very useful when using the `grep` command and copious
    amounts of matches are returned.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`awk 'BEGIN { FS=","} { print $1}' testdata/employees.csv`打印第一列或字段，甚至通过指定`NR==1`来打印第一次出现的内容，像这样：`awk
    'BEGIN { FS=","} NR==1{ print $1}'`。指定返回的记录数量在使用`grep`命令时非常有用，尤其是在返回大量匹配结果时。
- en: Again, there is so much you can do with AWK and SED. Combined with regular expressions
    (regexes), explanations and examples of all sorts of usage could fill a book dedicated
    to each command. You can check out the tools available in the documentation on
    the web so that you are aware of some platform differences.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，AWK和SED能做的事情非常多。结合正则表达式（regex），各种用法的解释和示例足以填满一本书，专门讲解每个命令。你可以查看网上文档中的工具，以便了解一些平台差异。
- en: Formatting your data/output using echo and printf
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用echo和printf格式化数据/输出
- en: 'Sometimes, finding the string or the exact data you are looking for is the
    easy part of your task, but formatting the output data is tricky. For example,
    here are some situations that have subtle elements that need to be altered:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，找到你要找的字符串或数据是任务中最简单的部分，但格式化输出数据却很棘手。例如，以下是一些需要调整的微妙情况：
- en: Echoing output without the newline terminator (\n)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出时不加换行符（\n）
- en: Echoing raw hexadecimal (hex) data
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出原始十六进制（hex）数据
- en: Printing raw hexadecimal values and printable ASCII characters
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印原始十六进制值和可打印的ASCII字符
- en: Concatenating strings
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串连接
- en: Escaping specific characters
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转义特定字符
- en: Aligning text
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对齐文本
- en: Printing horizontal rules
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印水平分隔线
- en: 'In addition to tricks, we can also print values to the screen that are also
    floats as well (in addition to the recipe for math). Wait, what is a hexadecimal number?
    Yes, another type of data or at least a representation exists. To understand what
    hexadecimals are, we first need to remember that computers use **binary**, which
    consists of 1s and 0s (ones and zeros). However, binary is not very friendly to
    us humans (we use the decimal format when looking at numbers typically), so other
    representations are sometimes needed, one of which is called **hexadecimal.**
    As you have probably guessed, it is base 16 so it looks like 0x0 to 0xF (0x0,0x1,
    ... ,0x9,0xA,0xB, ..., 0XF). Here is an example:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 除了技巧，我们还可以将值打印到屏幕上，这些值也可以是浮动值（除了数学公式的部分）。等等，什么是十六进制数？是的，存在另一种数据类型，或者至少是一种表示方式。为了理解什么是十六进制数，我们首先需要记住计算机使用
    **二进制**，它由 1 和 0（即 1 和 0）组成。然而，二进制对我们人类并不友好（通常我们在查看数字时使用十进制格式），所以有时需要其他表示方式，其中一种就是
    **十六进制**。如你所料，它是基数 16，因此看起来像 0x0 到 0xF（0x0，0x1，...，0x9，0xA，0xB，...，0xF）。以下是一个例子：
- en: '[PRE51]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding example, both `printf` and `echo` can be used to print raw
    hex and Unicode characters. Using a Unicode reference, I found the UTF-8 encoding
    for the **skull **character (`F0 9F 92 80`) and then formatted it using `\xFF`.
    Notice where FF is; it is in each **byte**.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`printf` 和 `echo` 都可以用来打印原始十六进制和 Unicode 字符。通过一个 Unicode 引用，我找到了 **骷髅**
    字符（`F0 9F 92 80`）的 UTF-8 编码，然后使用 `\xFF` 格式化它。注意 FF 的位置，它在每个 **字节** 中。
- en: What can you do knowing about "raw hex" values? Well, you can send characters
    that the shell can interpret differently, or you can print neat things! See [unicode-table.com](https://unicode-table.com) for
    more detail.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 知道了“原始十六进制”值后，你能做什么呢？嗯，你可以发送 shell 可以解释为不同内容的字符，或者你可以打印出漂亮的东西！查看更多详情请访问 [unicode-table.com](https://unicode-table.com)。
- en: Wait, another term called a **byte**? Yes, and here is another one called a **bit.** A **bit **is
    the form because it refers to either a 0 or 1, but a **byte is 8 bits** (one byte
    is made up of eight bits! Get it?).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，另一个术语叫做 **字节**？是的，还有一个叫做 **比特**。**比特** 是指 0 或 1，而 **字节是 8 个比特**（一个字节由八个比特组成！明白了吗？）。
- en: As a side note, depending on the platform or measurement—be aware that 1 kilobyte
    or KB can mean 1,024 Bytes (B) or on many marketing datasheets, 1 KB= 1,000 B.
    Furthermore, when you see Kb—it does NOT mean kilobytes. It means **Kilo** **bits!**
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，根据平台或度量的不同——请注意，1 千字节或 KB 可能意味着 1,024 字节（B），或者在许多市场数据表中，1 KB = 1,000 B。此外，当你看到
    Kb 时——它并不意味着千字节。它意味着 **千比特！**
- en: Again, being aware of computational basics such as types of data and conversion
    between basic data forms is a very useful tool to have in your skill set. It might
    even be in a job interview or two!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，了解计算基础知识，如数据类型和基本数据形式之间的转换，是你技能库中非常有用的工具。这可能会出现在一两次面试中！
- en: However, we are getting a bit ahead of ourselves—what is `echo` and `printf`?
    Both are commands which you may have seen earlier in this cookbook that allow
    you to output the contents of variables and more to the console or even to a file. **Echo**
    is far more "straightforward", but **printf** can provide the same and more functionality
    using C style parameters. In fact, one of the main features of printf over echo
    is that printf can format characters, pad them, and even align them.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们有点超前了——什么是 `echo` 和 `printf`？这两个命令你可能已经在本书中看到过，它们允许你将变量的内容等输出到控制台或文件中。**Echo**
    更“直接”，而 **printf** 则可以使用 C 风格的参数提供相同的功能，甚至更多。事实上，`printf` 相对于 `echo` 的一个主要优势是它可以格式化字符、填充字符，甚至对齐字符。
- en: Alright; let's get to work.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，开始工作吧。
- en: Getting ready
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this exercise, no extra tools or scripts are required—just you, your terminal,
    and Bash.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，不需要额外的工具或脚本——只需你、你的终端和 Bash。
- en: How to do it...
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s begin our activity as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始如下活动：
- en: 'Open up a new script called `echo-mayhem.sh` in your favorite editor and a
    new terminal. Enter the following contents and then execute the script at the
    prompt:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的脚本文件，命名为 `echo-mayhem.sh`，使用你喜欢的编辑器，并打开一个新的终端。在终端中输入以下内容并执行该脚本：
- en: '[PRE52]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'After reviewing the results of `echo-mayhem.sh`, create another script called
    `printf-mayhem` and enter the following contents:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查看 `echo-mayhem.sh` 的结果后，创建另一个名为 `printf-mayhem` 的脚本，并输入以下内容：
- en: '[PRE53]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Execute the contents of `printf-mayhem.sh` and review the contents for subtle
    differences.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `printf-mayhem.sh` 的内容，并查看其微妙的差异。
- en: How it works...
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'While this is a pretty important topic revolving around data types (especially
    when dealing with math or calculations), we broke the solution to this recipe
    up into two parts:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个关于数据类型的非常重要的话题（特别是处理数学或计算时），我们将这个问题的解决方案分成了两部分：
- en: 'In step 1, echo is pretty straightforward. We have mentioned in the past that
    there are special characters and escapes. `\t` stands for tab `\r\n` a new line
    in Windows (although in Linux, `\n\n` would have sufficed) and again, we could
    print out a fancy UTF character:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一步中，echo相当简单。我们之前提到过有特殊字符和转义符。`\t`表示制表符，`\r\n`表示Windows中的换行符（尽管在Linux中，`\n\n`就足够了），我们还可以打印出一个漂亮的UTF字符：
- en: '[PRE54]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, the results of step 2 are a bit different, as we can see in the following
    code. Let''s explore this a bit more as it looks like it''s a bit more than sloppy
    alignment:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，第二步的结果有点不同，我们可以从下面的代码中看到这一点。让我们深入探讨一下，因为这看起来不仅仅是对齐不当的问题：
- en: '[PRE55]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As we can see, in the preceding step after execution, there are a few interesting
    things. The first thing we notice is that `printf` is echo on steroids; it provides
    the same functionality and far more such as alignment, strings being printed with `%s`,
    and decimal places (for example, `%.2f`). As we dig deeper, we can see that we
    can limit the number of decimal places using a % after the `%tag`. Notice the
    single character usually immediately after the `%` sign—this is how you format
    the following parameters. Using a value like `%10f`, we are dedicating 10 spaces
    to the value, or rather, the width of 10 characters. If we use `%-10`, then it
    means we are aligning the value to the left. And besides the near horizontal rule,
    which uses expansion, we also "stepped" our way through the string "No place like
    home!". Using a `while` loop, we print out each ASCII character using (`%-c`)
    with its corresponding hexadecimal value (`%-2X`).
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们所见，在前面的步骤执行后，有几个有趣的地方。首先我们注意到的是，`printf`是强化版的echo，它提供了相同的功能，甚至更多的功能，比如对齐、用`%s`打印字符串，以及小数点（例如`%.2f`）。深入了解后，我们可以看到，使用`%`后跟一个值，我们可以限制小数点的位数。注意，通常在`%`符号后面紧跟的字符——这就是你如何格式化后续参数。使用像`%10f`这样的值时，我们将为该值分配10个空格，或者说，分配10个字符的宽度。如果我们使用`%-10`，则表示我们将值左对齐。除了几乎水平的规则使用扩展之外，我们还通过“逐步”处理字符串“No
    place like home!”来进行演示。使用`while`循环，我们打印出每个ASCII字符（使用`%-c`）及其对应的十六进制值（`%-2X`）。
- en: 'Notice that even spaces have a hexadecimal (hex) value, and that is `0x20.` If
    you ran the script and got `"printf-mayhem.sh: line 26: printf: !: invalid number"`,
    this is because you missed the single `'' `in `"''${STR:$TMP_CNT:1}"`. This signifies
    how to interpret the returned value as either a string/character or numeric value.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，即使是空格也有一个十六进制（hex）值，它是`0x20`。如果你运行了脚本并得到了 `"printf-mayhem.sh: line 26: printf:
    !: invalid number"`，那是因为你在`"''${STR:$TMP_CNT:1}"`中漏掉了单引号`''`。这意味着如何将返回的值解释为字符串/字符或数字值。'
- en: Readying your script for different languages with internationalization
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好你的脚本以适应不同语言的国际化
- en: 'Great, so you have this awesome script, but it''s written in standard English
    and you would like to target those nice people who speak other languages. In some
    countries like Canada, they (we) have two official languages: English and French.
    Sometimes, the dual-language component is enforced with legislature and localized
    language laws.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，你有了这个很棒的脚本，但它是用标准英语写的，你希望面向那些讲其他语言的人。在像加拿大这样的国家，他们（我们）有两种官方语言：英语和法语。有时候，双语组件通过立法和本地化语言法律得以执行。
- en: 'To get around this, let''s imagine a scenario where you are an individual who
    has written a script that prints out specific strings, but in English first. He/she
    wishes to have all of the strings inside of variables so that they can be swapped
    in and out dynamically using system language variables. Here are the basics:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了绕过这个问题，假设你是一个编写了脚本的个人，这个脚本首先用英语打印特定的字符串。他/她希望将所有字符串放入变量中，以便可以使用系统语言变量动态地进行替换。这里是基础知识：
- en: Create a shell script that utilizes **gettext **and sets the appropriate variables
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个利用**gettext**并设置适当变量的Shell脚本
- en: Build a **po **file that contains the necessary language definitions
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含必要语言定义的**po**文件
- en: Install your output language localization file for your script
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的脚本安装输出语言本地化文件
- en: Run your script with a language that's different than the one you originally
    use (by setting the LANG variable)
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同于原始语言的语言运行脚本（通过设置LANG变量）
- en: 'Before getting started, though, there are two terms that need to be discussed:
    internationalization (i18n) and localization (L10n). Internationalization is a
    process that enables translation and localisation/adaptation for a specific script
    or program, and localization refers to the process of having adapted the program/application
    for a specific culture.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，在开始之前，有两个术语需要讨论：国际化（i18n）和本地化（L10n）。国际化是一个使翻译和本地化/适应特定脚本或程序成为可能的过程，而本地化则是指将程序/应用程序适配特定文化的过程。
- en: The translation of scripts from the start can be an effective way to save time
    and improve the success of multi-lingual efforts. However, be aware that it can
    be a time-consuming process if the developers are fluent in only one language,
    or translation skills are not immediately present.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始就翻译脚本是节省时间并提高多语言工作的成功率的一种有效方法。然而，请注意，如果开发人员只精通一种语言，或者翻译技能不立即可用，这可能是一个耗时的过程。
- en: For example, in English, there are several dialects. In the USA, a product of
    a process or leftover can be called an **artifact**, but in Canadian English,
    it may be called an **artefact**. It could go unnoticed (or ignored), but the
    program could automatically adapt with specific localization.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在英语中，有几种方言。在美国，一个过程的产物或剩余物可以称为**artifact**，但在加拿大英语中，它可能被称为**artefact**。这可能不会引起注意（或被忽略），但程序可以通过特定的本地化自动适应。
- en: Getting ready
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Let''s get ready for the exercise by ensuring that we have the following applications
    and supporting libraries installed:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备好进行练习，确保已经安装了以下应用程序和支持库：
- en: '[PRE56]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, verify your language environment variables (LANG):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，验证你的语言环境变量（LANG）：
- en: '[PRE57]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We're assuming your environment probably has some form of English set as the
    default (`en_CA:en` is Canadian English)—keep note of the values returned for
    later!
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设你的环境可能已经将某种形式的英语设为默认语言（`en_CA:en`是加拿大英语）——记得记录返回的值以便后续使用！
- en: You may need to recover your language and locale settings later if something
    goes wrong. There are many posts on the internet, but a few hints are: `$ export
    LC_ALL="en_US.UTF-8"`; `sudo locale-gen`; and `sudo dpkg-reconfigure locales`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现问题，你可能需要恢复你的语言和区域设置。网上有许多帖子提供帮助，几个提示是：`$ export LC_ALL="en_US.UTF-8"`；`sudo
    locale-gen`；以及`sudo dpkg-reconfigure locales`。
- en: How to do it...
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s begin our activity as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的活动开始如下：
- en: 'Open a new terminal and create a new script called `hellobonjour.sh`with the
    following contents:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端，并创建一个名为`hellobonjour.sh`的脚本，内容如下：
- en: '[PRE58]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run `xgettext` to generate the appropriate strings. We will not use the results,
    but this is how you can generate a minimalist PO file:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`xgettext`以生成适当的字符串。我们不会使用这些结果，但这就是你如何生成一个极简的PO文件：
- en: '[PRE59]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Copy the already compiled list of strings into the language PO file called
    `hellobonjour_fr.po`:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将已经编译好的字符串列表复制到名为`hellobonjour_fr.po`的语言PO文件中：
- en: '[PRE60]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, using `msgfmt`,compile the PO file into a binary language file with the
    `.mo` extension and place it in our arbitrary language folder:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`msgfmt`将PO文件编译为具有`.mo`扩展名的二进制语言文件，并将其放入我们指定的语言文件夹中：
- en: '[PRE61]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once you have your language file in place, create the following script with
    the name of `translator.sh`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你将语言文件就位，创建以下名为`translator.sh`的脚本：
- en: '[PRE62]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Upon executing `translator.sh`, review the results for both executions of `translator.sh`:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`translator.sh`后，检查两次执行`translator.sh`的结果：
- en: '[PRE63]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: How it works...
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: It goes without saying that translation can be a tricky beast, especially when
    managing encoding and when producing results that make sense at the human language
    level. Furthermore, even a slight change in the value within the script can break
    the PO file and the resulting script will not be fully translated (sometimes,
    not even at all).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，翻译可能是一个棘手的事情，尤其是在处理编码时，以及生成在语言层面上有意义的结果时。此外，即使脚本中的值发生轻微变化，也可能会破坏PO文件，导致生成的脚本没有完全翻译（有时甚至根本没有翻译）。
- en: Take care not to break the *keys* when making modifications to the scripts at
    a later date.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在稍后修改脚本时，请小心不要破坏*keys*。
- en: 'Step one is fairly straightforward—you just create a script. If you run the
    script, you will see purely an English result, but at least the plural and non-plural
    output is correct. Notice `. gettext.sh`; this line preps `gettext` to prepare
    and to be ran for internationalization/localization. In the script, we also use `gettext`,
    `eval_gettext`, and `eval_ngettext`. These are functions that allow the translation
    to occur. Use `gettext` for simple translations, `eval_gettext` for a translation
    that contains a variable, and `eval_ngettext` when you have translations that
    contain plural objects. As you may have noticed, `eval_ngettext` is a bit more
    complex: `$(eval_ngettext "I have \$COUNT electronic device" "I have \$COUNT electronic
    devices" $COUNT)`. The first parameter for `eval_ngettext` is the singular translation,
    the second is the plural, and the count is the variable used to determine if a
    singular or plural value is used. Variables are referred to in the original script
    with an escape `\$COUNT`, and the translated string that contains the variable
    will appear as `$COUNT` inside of the translation file without the escape:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步相当简单——你只需创建一个脚本。如果你运行脚本，你会看到纯粹的英文输出，但至少复数和单数的输出是正确的。请注意`. gettext.sh`；这一行准备了`gettext`以进行国际化/本地化。在脚本中，我们还使用了`gettext`、`eval_gettext`和`eval_ngettext`。这些是允许翻译发生的函数。对于简单的翻译，使用`gettext`，对于包含变量的翻译，使用`eval_gettext`，对于包含复数对象的翻译，使用`eval_ngettext`。正如你可能注意到的，`eval_ngettext`稍微复杂一些：`$(eval_ngettext
    "I have \$COUNT electronic device" "I have \$COUNT electronic devices" $COUNT)`。`eval_ngettext`的第一个参数是单数翻译，第二个是复数翻译，而计数是用来确定是使用单数还是复数值的变量。变量在原始脚本中以转义符`\$COUNT`来表示，翻译字符串中的变量将出现在翻译文件中，形式为`$COUNT`，而没有转义符：
- en: '[PRE64]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In step two, we create the language file called a PO file using `xgettext`.
    PO is short for Portable Object. Notice that we omitted the header because it
    will produce extra output. It is particularly useful when you want to write notes,
    versions, and even specify the encoding used.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二步中，我们使用`xgettext`创建了一个名为PO文件的语言文件。PO是“便携对象”（Portable Object）的缩写。请注意，我们省略了头部信息，因为它会产生额外的输出。这在你想要写笔记、版本信息，甚至指定使用的编码时特别有用。
- en: 'Instead of writing the translations from scratch, we used our trusty friend
    Google translate to produce a few basic translations and we copy them over the
    output from `xgettext.` Xgettext created almost the same file! Notice `msgid`,
    `msgstr`, `msgplural`, and `msgstr[...]`. `Msgid` and `msgid_plural` are used
    to match the original values as if they were a key. For example, as the script
    runs, `gettext` sees `"I have $COUNT electronic device"`, and then knows to output
    a specific translation that matches that same `msgid`:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们并没有从头开始编写翻译，而是使用了我们值得信赖的朋友Google翻译来生成一些基础翻译，然后将其复制到`xgettext`的输出中。Xgettext几乎生成了相同的文件！请注意`msgid`、`msgstr`、`msgplural`和`msgstr[...]`。`Msgid`和`msgid_plural`用于匹配原始值，就像它们是一个键一样。例如，当脚本运行时，`gettext`看到`"I
    have $COUNT electronic device"`，然后知道输出一个特定的翻译，匹配那个相同的`msgid`：
- en: '[PRE65]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`hellobonjour_fr.po` contains all of our translations, and now we can use a
    command called `msgfmt`, which is used to produce a MO file or Machine Object.
    If you open this file with an editor like `vi`, you will notice that it contains
    a bunch of symbols representing binary and the strings. This file should not be
    edited, but rather the input PO file itself.'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hellobonjour_fr.po`包含了我们的所有翻译，现在我们可以使用一个叫做`msgfmt`的命令，它用于生成MO文件或机器对象。如果你用像`vi`这样的编辑器打开这个文件，你会发现它包含了一堆符号，代表二进制数据和字符串。这个文件不应该被编辑，而应该编辑输入的PO文件本身。'
- en: 'Next, we create a file called `translator.sh`. It runs `hellobonjour.sh` and
    contains a few lines that set three important variables: `TEXTDOMAIN`, `TEXTDOMAINDIR`,
    and `LANGUAGE`. `TEXTDOMAIN` is typically the variable used to describe the binary
    or shell script (think of it as a namespace), and `TEXTDOMAINDIR` is the directory
    for `gettext` to look for the translation. Notice that it''s in a local relative
    directory, and not `/usr/share/locale` (which it could be). Finally, we set `LANGUAGE`
    to fr for French.'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为`translator.sh`的文件。它运行`hellobonjour.sh`并包含几行代码，这些代码设置了三个重要的变量：`TEXTDOMAIN`、`TEXTDOMAINDIR`和`LANGUAGE`。`TEXTDOMAIN`通常是用来描述二进制文件或脚本的变量（可以将其视为命名空间），而`TEXTDOMAINDIR`是`gettext`查找翻译的目录。请注意，它位于本地相对目录中，而不是`/usr/share/locale`（尽管它也可以是）。最后，我们将`LANGUAGE`设置为法语（fr）。
- en: 'When we execute `translator.sh`, `hellobonjour.sh` is run twice and outputs
    once in English, and the second time in French:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们执行`translator.sh`时，`hellobonjour.sh`会被运行两次，第一次输出英文，第二次输出法语：
- en: '[PRE66]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Do not use the old format of $"my string" for translation. It is subject to
    security risks!
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用旧的格式 $"my string" 来进行翻译。它存在安全风险！
- en: Calculating statistics and reducing duplicates based on file contents
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于文件内容计算统计数据并减少重复项
- en: 'At first glance, calculating statistics based on the contents of a file might
    not be among the most interesting tasks one could accomplish with Bash scripting,
    however, it can be useful in several circumstances. Let''s imagine that our program
    takes user input from several commands. We could calculate the length of the input
    to determine if it is too little or too much. Alternatively, we could also determine
    the size of a string to determine buffer sizes for a program written in another
    programming language (such as C/C++):'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，基于文件内容计算统计数据可能不是使用 Bash 脚本完成的最有趣的任务，但在某些情况下，它却能派上用场。让我们假设程序从多个命令获取用户输入。我们可以计算输入的长度，以确定它是否过短或过长。或者，我们也可以确定字符串的大小，以便为用其他编程语言（如
    C/C++）编写的程序确定缓冲区大小：
- en: '[PRE67]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We can use commands like `wc` to calculate the number of occurrences of words,
    total number of lines, and many other actions in conjunction to the functionality
    provided by your script.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用像`wc`这样的命令来计算单词出现的次数、行数总数以及许多其他功能，结合脚本提供的功能来使用。
- en: 'Better yet, what if we used a command called **strings** to output all printable
    ASCII strings to a file? The strings program will output *every* occurrence of
    a string—even if there are duplicates. Using other programs like `sort` and `uniq`
    (or a combination of the two), we can also sort the contents of a file and reduce
    duplicates if we wanted to calculate the number of *unique* lines within a file:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，如果我们使用一个名为**strings**的命令将所有可打印的 ASCII 字符串输出到一个文件呢？`strings`程序会输出*每一个*字符串的出现次数——即使它们是重复的。通过使用其他程序，如`sort`和`uniq`（或者这两者的组合），我们也可以对文件内容进行排序，并减少重复项，如果我们想计算文件中*唯一*行的数量：
- en: '[PRE68]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Now that we know a few basic premises of why we may need to perform some basic
    statistics, let's carry on with the recipe.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了执行一些基本统计的几个基本前提，接下来继续进行实际步骤。
- en: Getting ready
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s get ready for the exercise by creating a single dataset:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个数据集来准备练习：
- en: '[PRE69]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How to do it...
  id: totrans-395
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We have already seen most of these concepts already and even `wc`itself in
    one of the previous recipes, so let''s get started:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的步骤中看到了这些概念，甚至在其中一个食谱中也使用了`wc`，所以我们直接开始：
- en: 'Open a terminal and run the following commands:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并运行以下命令：
- en: '[PRE70]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As you may have noticed, the output has the filename included. Can we remove
    it with AWK? Absolutely, but we can also remove it with a command called `cut.` The
    `-d` flag stand, for delimiter and we would like to have a field (specified by
    `-f1`):'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，输出中包含了文件名。我们能用 AWK 移除它吗？当然可以，但我们也可以使用名为`cut`的命令来移除它。`-d`选项代表分隔符，我们想选择一个字段（由`-f1`指定）：
- en: '[PRE71]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Imagine that we have a massive file full of strings. Could we reduce the returned
    results? Of course, but let''s use the `sort` command first to sort the elements
    contained in `testdata/duplicates.txt` and then use `sort` to produce a list of
    only the unique elements:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们有一个充满字符串的庞大文件。我们能减少返回的结果吗？当然可以，但首先我们使用`sort`命令对`testdata/duplicates.txt`中的元素进行排序，然后使用`sort`命令生成仅包含唯一元素的列表：
- en: '[PRE72]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works...
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Overall, no truly abstract concepts were introduced in this script, except for
    counting numbers of occurrences and the benefit of sort. Sorting can be a time-consuming
    process to reduce unneeded or extra data or when the order matters, but it can
    also be rewarding when performing bulk operations, and pre-processing yields faster
    returns overall.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，除了计数出现次数和排序的好处外，本脚本没有引入真正的抽象概念。排序可能是一个耗时的过程，尤其是在减少不需要的或多余数据时，或者当顺序很重要时，但当进行大规模操作时，它也可以带来回报，并且预处理通常会更快地得到结果。
- en: 'Onward and upward to the recipe:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来开始实际步骤：
- en: 'Running these two `wc`commands will produce both a character and line count
    of the file `testdata/duplicates.txt.` It also begins to show another problem.
    The data can be padded with the filename prefixed with a space:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这两个`wc`命令会生成文件`testdata/duplicates.txt`的字符数和行数统计。同时，这也暴露了另一个问题：数据可能会被文件名前的空格填充：
- en: '[PRE73]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'In step 2, we use `awk` and `cut` to remove the second field. The `cut` command
    is a useful command for trimming strings, which may be delimited or merely using
    hard-coded values such as remove X characters. Using `cut`, `-d` stands for delimiter,
    the space in this example (`'' ''`), and `-f1` stands for field `1`:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在步骤2中，我们使用`awk`和`cut`命令删除第二个字段。`cut`命令是一个有用的命令，用于修剪字符串，可以按分隔符分割，或使用硬编码的值（例如删除X个字符）。使用`cut`时，`-d`表示分隔符，这里是空格（`'
    '`），`-f1`表示字段`1`：
- en: '[PRE74]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the final step, we run the `sort` command three times. We run it once to
    merely sort the elements in `testdata/duplicates.txt`, but then we use the `-u` to
    sort and keep only unique elements, and the `final` command counts the number
    of unique elements. Of course, the returned value is `9` because we had 18 lines
    in the original duplicates file:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，我们运行`sort`命令三次。第一次我们仅仅对`testdata/duplicates.txt`中的元素进行排序，然后使用`-u`选项对其进行排序并保留唯一元素，最后使用`final`命令统计唯一元素的数量。当然，返回的值是`9`，因为我们在原始重复文件中有18行：
- en: '[PRE75]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Using file attributes with conditional logic
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文件属性和条件逻辑
- en: Earlier in this book, we touched upon various tests for strings, numbers, and
    variables. Using a similar concept built into Bash, we can also use various attributes
    to test against files and directories. This extends upon the introduction conditional
    logic to perform tests on files. Does an example exist? Is it a directory? and
    so on.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早些时候，我们提到了各种针对字符串、数字和变量的测试。通过Bash内置的类似概念，我们也可以使用各种属性来对文件和目录进行测试。这是在条件逻辑介绍的基础上扩展，来执行文件测试。例如：是否存在某个文件？它是目录吗？等等。
- en: For a moment, though, couldn't we just use the results from executing and checking
    the return code? Absolutely! This is another method you can use, especially if
    you are using a version of Bash that supports all of Bashes features. It is just
    another way to "skin the rabbit".
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，稍等一下，我们难道不可以直接使用执行结果并检查返回码吗？当然可以！这是你可以使用的另一种方法，尤其是当你使用支持所有Bash功能的Bash版本时。这只是“换个方式做事”的另一种方法。
- en: 'Let''s start off first with some of the common flags, which return true if:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从一些常见的标志开始，如果满足以下条件则返回真：
- en: '`-e`: The file exists'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-e`：文件存在'
- en: '`-f`: This is a regular file and not a directory or device file'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`：这是一个常规文件，而不是目录或设备文件'
- en: '`-s`: The file is not empty or zero in size'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`：该文件不为空或大小为零'
- en: '`-d`: This is a directory'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-d`：这是一个目录'
- en: '`-r`: This has read permissions'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`：该文件具有读取权限'
- en: '`-w`: This has write permissions'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-w`：该文件具有写入权限'
- en: '`-x`:This has execute permissions'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x`：该文件具有执行权限'
- en: '`-O`: This is the owner of the file the current user'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-O`：这是文件的所有者，当前用户'
- en: '`-G`: This executes the user if they have the same group as yours'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-G`：如果用户与您属于同一组，则执行该操作'
- en: '`f1` (`- nt`, `-ot`, `-ef`) `f2`: Refers to if `f1` is newer than `f2`, older
    than `f2`, or are hard-linked to the same file'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`f1`（`-nt`，`-ot`，`-ef`）`f2`：指示`f1`是否比`f2`更新，或者比`f2`更旧，或者是否与`f2`是硬链接到同一文件'
- en: There is more information available on file test operations in the GNU Bash
    manual:[ https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html](https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 文件测试操作的更多信息可以在GNU Bash手册中找到：[https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html](https://www.gnu.org/software/bash/manual/html_node/Bash-Conditional-Expressions.html)。
- en: Getting ready
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备开始
- en: 'Let''s get ready for the exercise by creating a few text files and directories,
    and adding some content:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一些文本文件和目录并添加内容来为练习做好准备：
- en: '[PRE76]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This recipe is about performing some simple file tests and to combine some of
    the other knowledge from earlier recipes on conditional logic, but with a twist—using
    user input from the CLI and file permissions.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱讲解的是执行一些简单的文件测试，并结合之前条件逻辑中学到的一些知识，但有个小变化——使用来自CLI的用户输入和文件权限。
- en: Notice the commands `chmod`, `useradd`, and `chmod`. Chmod is the command you
    may use to change the permissions of files for execution and more.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令`chmod`，`useradd`和`chmod`。Chmod是你用来更改文件权限（例如执行权限等）的命令。
- en: How to do it...
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作……
- en: 'Let''s begin our activity as follows:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按如下方式开始我们的活动：
- en: 'Open a new terminal and start an editor of your choice and create a new script.
    The following is a code snippet from the script:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的终端，启动你选择的编辑器并创建一个新的脚本。以下是脚本中的代码片段：
- en: '[PRE77]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Execute the script and try to access the various files, including the directories
    and files that do not exist. What do you notice?
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行脚本并尝试访问各种文件，包括不存在的目录和文件。你注意到了什么？
- en: 'Remove the folder now with this command:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用以下命令删除该文件夹：
- en: '[PRE78]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: How it works...
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'First, before digging into the script itself or even the attributes/properties
    of files, we need to know a few things about Linux and its sibling operating systems:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在深入研究脚本本身甚至文件的属性/属性之前，我们需要了解Linux及其兄弟操作系统的一些情况：
- en: Files and directories can be owned. This means that they can have an owner (user)
    and groups associated with their ownership. For this, we can use the `chown` and
    `chgrp`commands.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和目录可以有所有者。这意味着它们可以有一个所有者（用户）和与其所有权相关联的组。为此，我们可以使用`chown`和`chgrp`命令。
- en: Files and directories can have different permissions applied to them. This means
    that they may be executable, readable, writable, and/or everything. For this,
    we can use the `chmod`command and the appropriate permission setting.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和目录可以应用不同的权限。这意味着它们可能是可执行的、可读的、可写的和/或所有的。为此，我们可以使用`chmod`命令和适当的权限设置。
- en: Files and directories can also be empty.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件和目录也可以是空的。
- en: 'Great! Furthermore, there are two more concepts that need to be introduced:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！此外，还有两个需要介绍的概念：
- en: The `read`command, which is used to wait for user input and read it into a variable.
    It is also useful for "pause" functionality in scripts.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read`命令，用于等待用户输入并将其读入变量。它在脚本中也非常有用，用于“暂停”功能。'
- en: Recursive functions. Notice that inside of the script unless it exits or the
    user presses *ctl + C*, the script keeps calling a particular function. This is
    recursion and it will continue unless stopped or a limit is applied.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归函数。请注意，脚本中的特定函数在退出或用户按下*ctl + C*之前会不断调用。这就是递归，除非停止或应用限制。
- en: At this point, we also know functions, parameters, input/output, return codes,
    subshells, and conditional logic. You may not have noticed the `!` character,
    and this is used to negate a statement. For example, if we test for the existence
    of `fileops/bobs.txt` using the `-e` test operator, it will return true. Instead,
    we can test for the opposite, which is that `fileops/bobs.txt` is non-existent.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还了解了函数、参数、输入/输出、返回码、子shell和条件逻辑。您可能没有注意到`!`字符，这用于否定语句。例如，如果我们使用`-e`测试运算符测试`fileops/bobs.txt`的存在，它将返回true。相反，我们可以测试其相反情况，即`fileops/bobs.txt`不存在。
- en: The same logic as inverting or negating statements can also be achieved using
    if/else functionality, but it can sometimes improve script "readability" and "flow".
    Ultimately, the choice to use inversion is up to the script writer.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 与反转或否定语句相同的逻辑也可以通过if/else功能实现，但有时候这可能会提高脚本的“可读性”和“流畅性”。最终，是否使用反转取决于脚本编写者。
- en: Great! We have created our script and are ready to execute it.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太棒了！我们已经创建了我们的脚本，并准备执行它。
- en: 'Upon executing the script, we are greeted with:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行脚本后，我们看到：
- en: '[PRE79]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If we look back at the setup for this recipe, we know that we created several
    files inside of the directory `fileops/` and that a few of them have different
    permissions, one of which is owned by a user named `Bob`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下这个配方的设置，我们知道我们在`fileops/`目录内创建了几个文件，并且其中一些文件具有不同的权限，其中一个文件是由名为`Bob`的用户拥有的。
- en: 'Let''s try a few executions (in order) :'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些执行（按顺序）：
- en: '`fileops/bobs.txt`'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileops/bobs.txt`'
- en: '`fileops/write.txt`'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileops/write.txt`'
- en: '`fileops/exec.txt`'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileops/exec.txt`'
- en: '`fileops/all.txt`'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileops/all.txt`'
- en: '`thisDoesNotExist.txt`:'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thisDoesNotExist.txt`：'
- en: '[PRE80]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: As `thisDoesNotExist.txt` does not exist, the script abruptly exits and places
    you back at the console prompt. We tested with the various flags, negation, ownership,
    and even our ever useful utility `xargs`.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`thisDoesNotExist.txt`不存在，脚本会突然退出并将您放回到控制台提示符。我们测试了各种标志、否定、所有权，甚至我们非常有用的实用程序`xargs`。
- en: Reading delimited data and altered output format
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取分隔数据和更改输出格式
- en: 'Every day, we open many files in many different formats. However, when thinking
    about large amounts of data, it is always a good practice to use standard formats.
    One of these is called **Comma Separated Values**, or CSVs, and it uses a comma
    (,) to separate **elements **or **delimit** on each row. This is particularly
    useful when you have large amounts of data or **records**, and that data will
    be used in a scripted fashion. For example, in every school semester, Bob, the
    system administrator, needs to create a series of new users and set their information.
    Bob also gets a standardized CSV (like in the following snippet) from the people
    in charge of attendance:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 每天，我们会打开许多不同格式的文件。但是，当处理大量数据时，使用标准格式始终是一个好习惯。其中之一称为**逗号分隔值**，或CSV，它使用逗号（,）来分隔**元素**或**分隔**每一行。当您拥有大量数据或记录，并且这些数据将以脚本方式使用时，这特别有用。例如，在每个学期，系统管理员Bob需要创建一系列新用户并设置他们的信息。Bob还从负责出勤的人那里得到一个标准化的CSV（就像下面的片段中那样）：
- en: '[PRE81]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If Bob the administrator wishes to only read this information into an array
    and create users, it is relatively trivial for him to parse a CSV and create each
    record in one single scripted action. This allows Bob to focus his time and effort
    on other important issues such as troubleshooting end-user WiFi issues.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果管理员Bob只希望将此信息读入数组并创建用户，那么对他来说，解析CSV并在一个单一的脚本化操作中创建每个记录相对较为简单。这使Bob可以将时间和精力集中在其他重要问题上，比如解决最终用户的WiFi问题。
- en: 'While this is a trivial example, these same files may be in different forms
    with **delimiters **(the `,` or `$` sign, for example), different data, and different
    structures. However, each file works on the premise that each line is a record
    that needs to be read into some structure (whatever it may be) in SQL, Bash arrays,
    and so on:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个琐碎的例子，但这些文件可能以不同形式存在，使用**分隔符**（例如逗号`,`或美元符号`$`）、不同的数据和不同的结构。但是，每个文件的基础都是每一行都是一个需要被读入某种结构（不管是什么）的记录，在SQL、Bash数组等中：
- en: '[PRE82]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In the preceding example of a pseudo CSV, there is a header, which may be optional
    (not present), and then several lines (each being a record). Now, for Bob to parse
    the CSV, he has many ways to do this, but he may use specialized functions that
    apply a strategy such as:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述伪CSV的示例中，有一个可能是可选的标题（不出现），然后有几行（每行是一条记录）。Bob有许多方法可以解析CSV，但他可能会使用应用策略的专业函数，例如：
- en: '[PRE83]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'To read in the data, Bob or yourself may resort to using:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取数据，Bob或您自己可能会使用：
- en: For loops and arrays
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于循环和数组
- en: A form of iterator
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种迭代器的形式
- en: Manually walking through each line (not efficient)
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动逐行读取（效率低下）
- en: Once any input data has been read in, the next step is to do something with
    the data itself. Is it to be transformed? Is it to be used immediately? Sanitized?
    Stored? Or converted to another format? Just like Bob, there are many things that
    can be performed using the data read in by the script.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦读入任何输入数据，下一步就是对数据本身进行处理。是要进行转换？是要立即使用？经过消毒处理？存储？还是转换为另一种格式？就像Bob一样，使用脚本读入的数据可以执行许多操作。
- en: 'In regards to outputting the data, we can also convert it to XML, JSON, or
    even insert it into a database as SQL. Unfortunately, this process requires being
    able to know at least two things: the format of the input data and the format
    of the output data.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 关于输出数据，我们也可以将其转换为XML、JSON，甚至将其作为SQL插入到数据库中。不幸的是，此过程需要了解至少两个方面：输入数据的格式和输出数据的格式。
- en: Knowing common data formats and how they often have validation applied can be
    a great asset when building automated scripts and identifying any changes in the
    future. Enforcement of data validation also has several benefits and can help
    save the day when all of a sudden the script breaks without warning!
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 知道常见的数据格式及其通常应用验证时，可以在构建自动化脚本和识别未来任何变化时提供极大帮助。强制执行数据验证还有几个好处，可以在脚本突然无预警中断时挽救局面！
- en: This recipe aims at walking you through reading a trivial CSV and outputting
    the data into some arbitrary formats.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 本文旨在引导你逐步阅读一个简单的CSV并将数据输出到一些任意的格式中。
- en: Getting ready
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s get ready for the exercise by creating some data sets which mimic common
    daily problems:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一些模仿常见日常问题的数据集来为这项练习做好准备：
- en: '[PRE84]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In Bash, the single quote (') is used for literal strings. In this case, we
    want every part of the string to be present without escaping slashes and double
    quotes.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash中，单引号（'）用于字面字符串。在这种情况下，我们希望字符串的每一部分都存在，不需要转义斜杠和双引号。
- en: 'To operate this script, you have the following applications installed for use
    within the script:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此脚本，您需要安装以下应用程序，以便在脚本中使用：
- en: '[PRE85]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: How to do it...
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s begin our activity as follows:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下方式开始活动：
- en: 'Open a terminal and create the `data-csv-to-xml.sh` script with the following
    contents. Then, execute the script after saving it using `$ bash data-csv-to-xml.sh`:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端并创建名为 `data-csv-to-xml.sh` 的脚本，内容如下。保存后，使用 `$ bash data-csv-to-xml.sh` 执行该脚本：
- en: '[PRE86]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Examine the output, but be aware that "pretty" XML isn't necessary and in fact,
    we don't even need to have the XML on multiple lines. If pure data is required
    for a web application, the extra new lines and tabs are unnecessary data to be
    transmitted.
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查输出时，请注意，“美观”的 XML 不是必需的，实际上，我们甚至不需要将 XML 分布在多行上。如果 web 应用程序只需要纯数据，那么额外的换行符和制表符就是不必要的传输数据。
- en: 'Create another script named `data-xml-to-json.sh` with the following contents.
    Then, execute the script after saving it using `$  data-xml-to-json.sh`:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为 `data-xml-to-json.sh` 的脚本，内容如下。保存后，使用 `$ data-xml-to-json.sh` 执行该脚本：
- en: '[PRE87]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Review the output and see how it easy it is! Are there areas you could improve
    on in both of the scripts?
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 审查输出，看看它是多么简单！在两个脚本中，是否有可以改进的地方？
- en: How it works...
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have already discussed several important aspects such as the power of the
    SED and AWK commands, and even CSVs, but we have not discussed the importance
    of being able to **transform** the format and structure of data. CSVs are a fundamental
    and very common format of data, but unfortunately, it isn''t the best choice for
    some applications, so we may use XML or JSON. Here are two scripts (or rather
    one script and one tool) that can convert our original data into various formats:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了几个重要的方面，比如 SED 和 AWK 命令的强大功能，甚至 CSV 文件，但我们还没有讨论能够**转换**数据格式和结构的重要性。CSV
    是一种基础且非常常见的数据格式，但不幸的是，它并不是某些应用程序的最佳选择，因此我们可能会使用 XML 或 JSON。这里有两个脚本（或者说一个脚本和一个工具），可以将我们的原始数据转换成各种格式：
- en: 'When executing `data-csv-to-xml.sh`, we notice several things: we utilize two
    source template files, which can be altered for flexibility, and then a large
    piped command that leverages sed and AWK. On input, we take each of the CSV values
    and build a `<word lang="x">Y</word>` XML element using the format template inside
    of `word.tpl`, where `$0` is field one and `$1` is field two. The script will
    produce a `words.csv` and output the following:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行 `data-csv-to-xml.sh`时，我们注意到几个要点：我们使用了两个源模板文件，可以根据需要进行修改，然后是一个大型的管道命令，利用了
    sed 和 AWK。在输入时，我们将每个 CSV 值提取出来，并使用 `word.tpl` 中的格式模板构建一个 `<word lang="x">Y</word>`
    的 XML 元素，其中 `$0` 是第一列，`$1` 是第二列。该脚本将生成 `words.csv` 并输出以下内容：
- en: '[PRE88]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In the second script, we merely take `words.xml` as input into the command `xml2json`.
    The output will be in JSON format. Cool hey?
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个脚本中，我们仅仅将 `words.xml` 作为输入传递给命令 `xml2json`。输出将是 JSON 格式。很酷吧？
- en: '[PRE89]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The differences and reasons between all three formats of data (CSV, XML, and
    JSON) is left as an exercise for the reader to discover. Another exercise to explore
    is performing data validation to ensure integrity and constraints on data. For
    example, XML can use XSD schemas to enforce data limits.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 关于三种数据格式（CSV、XML 和 JSON）之间的差异及其原因，留给读者自行发现。另一个需要探索的练习是执行数据验证，以确保数据的完整性和约束。例如，XML
    可以使用 XSD 模式来强制数据限制。
