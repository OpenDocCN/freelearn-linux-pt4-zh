- en: Quoting and Escaping
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用和转义
- en: 'Not everything is what it looks like. We must bear in mind that when dealing
    with operators and variables, sometimes we get unexpected results based on how
    we use them. A small example will make this advice more clear:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的东西看起来都像它的样子。我们必须记住，当处理操作符和变量时，有时我们会根据使用它们的方式得到意外的结果。一个小例子可以让这个建议更加清楚：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The directory has no content, so it is our starting point:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 目录没有内容，所以它是我们的起始点：
- en: '[PRE1]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We just created a file named star:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个名为 star 的文件：
- en: '[PRE2]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we do `ls *` , we actually see it:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行 `ls *` 时，我们实际上会看到它：
- en: '[PRE3]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We see this even if we issue a simple `ls` without any arguments:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们没有提供任何参数，简单地执行 `ls` 时，我们仍然能看到这一点：
- en: '[PRE4]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we created three empty files:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们创建了三个空文件：
- en: '[PRE5]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Well, we tried to list only the star file, but we saw all of them. How to show
    only the star named file? We can do so as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们试图列出只有星号的文件，但我们看到了所有的文件。如何只显示以星号命名的文件？我们可以这样做：
- en: '[PRE6]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So, now that we have quoted the star symbol, we can see the file named after
    it. Why is this? Well, as I said, there are some characters that have a special
    meaning for the shell, such as the star, which is expanded by the shell into *ALL*
    characters. This is why if we issue `ls *`, we will see all the files held into
    the directory, because we are asking to show any file whose name is made up of
    any characters or numbers (except for filenames starting with a dot). Quoting
    the star symbol prevents the shell from actually interpreting the special character
    ,and so take it literally, we want to see the file whose name is simply `*`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在我们已经引用了星号符号，我们可以看到以它命名的文件。为什么会这样呢？嗯，正如我所说，有一些字符对 Shell 来说有特殊意义，比如星号，它会被
    Shell 扩展为*所有*字符。这就是为什么当我们执行 `ls *` 时，我们会看到目录中的所有文件，因为我们请求显示任何文件名由任意字符或数字组成（除了以点号开头的文件名）。引用星号符号可以防止
    Shell 解释这个特殊字符，因此将其视为字面意义上的字符，我们只想看到名为 `*` 的文件。
- en: Special characters
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊字符
- en: We have already used some of these special characters in the previous chapters
    by giving a hint of what was their meaning. Now, we will be closely looking at
    each of them and examining their special value for the shell and how they can
    be used in our scripts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章已经使用过一些特殊字符，给出了它们的含义提示。现在，我们将仔细查看每一个字符，并研究它们对 Shell 的特殊价值，以及如何在脚本中使用它们。
- en: The hash character (#)
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 井号字符（#）
- en: 'This represents a comment. Each line beginning with `#` is taken as a comment
    and not interpreted by the shell. Let''s have a look at the following script:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示一个注释。每行以 `#` 开头的内容都会被视为注释，Shell 不会对其进行解释。让我们看看以下脚本：
- en: '[PRE7]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first pound sign is not really a comment, but it is associated to the following
    exclamation mark and is interpreted as a *sha-bang*. The second line shows a typical
    comment line, the third a comment after a command, the fourth line is still a
    comment, and the `ps` command is not interpreted and executed. Let''s run it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个井号（#）符号实际上不是一个注释，而是与随后的感叹号关联，被解释为*sha-bang*。第二行显示了典型的注释行，第三行是命令后的注释，第四行仍然是注释，`ps`
    命令没有被解释和执行。让我们运行它：
- en: '[PRE8]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We see the output of the `ls` command, but not of `ps` as expected. Also notice
    that the comments are not printed to `stdout`. Since we use it inside the code
    to comment, it is not something to be shown at runtime. Let''s add a couple of
    lines:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了 `ls` 命令的输出，但没有看到预期的 `ps` 输出。同时注意到注释没有被打印到 `stdout`。因为我们在代码中使用它作为注释，它不是运行时需要显示的内容。让我们再添加几行：
- en: '[PRE9]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run the script again:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行脚本：
- en: '[PRE10]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the first `echo` command creates a blank line and the comment
    is not taken in account; so, it is as if we had no argument to the `echo` command.
    The second comment is even more interesting. We escaped the pound sign placing
    a back slash in front of it. So, being escaped the pound sign is just a pound
    sign followed by a bunch of characters, and all together, they get printed to `stdout`
    as the `echo` command arguments. So, be careful since you will find the pound
    sign used with different meaning, as we already saw in the paragraphs dealing
    with a parameter substitution and a pattern matching on variables.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，第一个 `echo` 命令创建了一个空行，并且注释没有被考虑进去；所以，就好像我们没有给 `echo` 命令传递任何参数。第二个注释则更有意思。我们通过在它前面加反斜杠来转义了井号。因此，转义后的井号只是一个井号后跟一串字符，所有这些字符作为
    `echo` 命令的参数一起被打印到 `stdout`。所以，要小心，因为你会发现井号有不同的含义，就像我们在涉及参数替换和变量模式匹配的段落中看到的那样。
- en: The semicolon character (;)
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分号字符（;）
- en: 'The semicolon is a command separator, and it allows us to chain one command
    after the other, just as we did for the if construct. For instance, look at this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 分号是命令分隔符，允许我们将一个命令链式执行到下一个命令，就像我们在 if 构造中所做的那样。例如，看看这个：
- en: '[PRE11]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We created a `test.txt` file, and we cat its content right after it. Be careful
    with the find `-exec` command, as the semicolon must be escaped. The `-exec` option
    allows us to perform a command on the files provided by find:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`test.txt`文件，并紧接着使用 `cat` 命令查看其内容。使用 `find -exec` 命令时要小心，因为分号必须进行转义。`-exec`
    选项允许我们对 `find` 提供的文件执行命令：
- en: '[PRE12]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With the find `-exec` object, the semicolon is the command sequence terminator
    and not a command separator, so it must be escaped in order to avoid the shell
    to interpret it as a special character. After the first escaped semicolon, we
    then added a second semicolon to separate the `find` command from the subsequent
    `ls`. Notice that`{}` in the command is substituted by `find` with the full path
    to the file found.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `find -exec` 对象中，分号是命令序列终止符，而不是命令分隔符，因此必须进行转义，以避免 shell 将其解释为特殊字符。在第一个转义分号之后，我们再添加第二个分号，以分隔
    `find` 命令和随后的 `ls` 命令。请注意，命令中的 `{}` 会被 `find` 替换为找到的文件的完整路径。
- en: The double semicolon character (;;)
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双分号字符（`;;`）
- en: 'The double semicolon is a case construct option terminator. We will see the
    case constructor later in this book, but as of now, just think of it as a sequence
    of if/then/else, which is widely adopted to create a user menu:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 双分号是案例构造选项的终止符。我们将在本书后续部分看到案例构造器，但现在，您可以将其视为一种 if/then/else 结构，广泛应用于创建用户菜单：
- en: '[PRE13]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As you can see, the case construct starts with the case keyword and is closed
    by the reverse of it: `esac`. What it does is try to verify each condition into
    the different options that we defined. Each option is separated from the other
    by the double colon. The last option is usually a star, which means *whatever
    you type,* and it is a catchall option just in case any other option did not trap
    what the user typed in. Let''s have a look:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，案例构造从 `case` 关键字开始，并由其反转 `esac` 结束。它的作用是验证我们定义的不同选项中的每一个条件。每个选项之间由双冒号分隔。最后一个选项通常是星号，表示*无论你输入什么*，它是一个兜底选项，以防其他选项未能捕捉到用户输入的内容。让我们看一下：
- en: '[PRE14]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use this for the default option:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 用于默认选项：
- en: '[PRE15]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Have you noticed that the screen has been cleared out of any content? This is
    thanks to the `clear` command that we wrote at the beginning of the file, as it
    clears out the screen so that whatever you write to the customer, it will appear
    at the top of the screen without any other content distracting the user.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否注意到屏幕上的内容已经被清空了？这要归功于我们在文件开头写的 `clear` 命令，它清空了屏幕，这样你向客户写的任何内容都会出现在屏幕顶部，不会有其他内容分散用户的注意力。
- en: The case terminator (;;&) and (;&))
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例终止符（`;;&`）和（`;&)`）
- en: 'These are enhanced case terminators too, but they are only available in Bash
    from a version higher than 4.0\. Here are the differences between the three operators:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也是增强型的案例终止符，但它们仅在 Bash 4.0 及更高版本中可用。以下是三种操作符之间的区别：
- en: '`;;`: If the condition is matched, the other options will not be tested'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`;;`：如果条件匹配，则不会再测试其他选项'
- en: '`;&`: This makes the execution continue with the commands associated to the
    next condition'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`;&`：这使得执行会继续到下一个条件关联的命令'
- en: '`;;&`: This makes the shell check the option and execute the associated commands
    if the condition is matched'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`;;&`：这使得 shell 检查选项，并在条件匹配时执行关联的命令'
- en: If no matches are found, the exit status is `0`; otherwise, the exit status
    is the one from the last command executed. We will see more about these terminators
    and the case constructor in the next chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有找到匹配项，则退出状态为`0`；否则，退出状态为最后执行的命令的状态。我们将在下一章中进一步了解这些终止符和案例构造器。
- en: The dot character (.)
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点字符（`.`）
- en: 'The dot command is a shell builtin, and it has the same function of the source;
    when executed into the shell, it executes a file. And if it is used inside a script,
    it loads the referenced file content:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 点命令是一个 Shell 内建命令，其功能与 source 相同；当在 shell 中执行时，它会执行一个文件。如果在脚本中使用，它会加载引用文件的内容：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see from this example, the first try was not successful because `comment.sh`
    is not in the search path; but the second time, we were successful since the dot
    command executed the script. Now, let''s see how to include some code from an
    external file into a script. Let''s start writing the external file that we will
    source from the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子可以看到，第一次尝试失败了，因为 `comment.sh` 不在搜索路径中；但第二次成功了，因为点命令执行了脚本。现在，让我们看看如何将外部文件中的一些代码包含到脚本中。我们从以下代码开始编写外部文件，并从中加载：
- en: '[PRE17]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, we have to write the script that will source from this file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要编写将从此文件加载的脚本：
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, it is just a matter of having a look at what happens:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需看看发生了什么：
- en: '[PRE19]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, as we can see, we actually sourced the variables content from the external-data
    file. But there is more since if we source an external script, its code gets executed
    and can also return values to the main script:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们实际上从外部数据文件加载了变量的内容。但还有更多，因为如果我们加载了一个外部脚本，它的代码会被执行并且还能返回值给主脚本：
- en: '[PRE20]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is a simple menu that asks the user for a digit and then checks it; do
    not worry, as we will see how to match digits and characters later on:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的菜单，询问用户一个数字并进行检查；不用担心，我们稍后将展示如何匹配数字和字符：
- en: '[PRE21]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There is a quick way to match characters  by using a POSIX character class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种快速的方法可以通过使用 POSIX 字符类来匹配字符：
- en: '`[:alnum:]` matches both alphabetic and numeric characters'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:alnum:]` 匹配字母和数字字符'
- en: '`[:alpha:]` matches only alphabetic characters'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:alpha:]` 只匹配字母字符'
- en: '`[:blank:]` matches only a tab or a space'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:blank:]` 只匹配制表符或空格'
- en: '`[:cntrl:]` matches any control characters'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:cntrl:]` 匹配任何控制字符'
- en: '`[:digit:]` matches only digits between 0 to 9'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:digit:]` 只匹配 0 到 9 之间的数字'
- en: '`[:graph:]` matches any the character that has a value between 33 and 126 in
    the ASCII table'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:graph:]` 匹配 ASCII 表中值介于 33 到 126 之间的任何字符'
- en: '`[:lower:]` matches alphabetic characters in lower case'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:lower:]` 匹配小写字母字符'
- en: '`[:print:]` matches the graph, but also matches the range is from 32 to 126,
    including the space characters too'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:print:]` 匹配图形字符，同时也匹配从 32 到 126 的范围，包括空格字符'
- en: '`[:space:]` matches the space and horizontal tabs'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:space:]` 匹配空格和水平制表符'
- en: '`[:upper:]` matches alphabetic characters in upper case'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:upper:]` 匹配大写字母字符'
- en: '`[:xdigit:]` matches digits, but in a hexadecimal notation'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[:xdigit:]` 匹配数字，但采用十六进制表示'
- en: 'Now, let''s do something nicer and modify the previous external script in the
    following way:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们做些更有趣的事情，按以下方式修改之前的外部脚本：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Instead of exiting, we are returning a value to the caller script so that the
    execution once ended on the child script will continue on the main one. Now a
    new main script is here:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有退出，而是将一个值返回给调用脚本，这样子脚本执行结束后，主脚本的执行将继续。现在有了一个新的主脚本：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now let''s see a couple of tests:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看几个测试例子：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will now source the `external-script-return.sh` file and ask the customer
    for a digit between `0` to `9`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将加载 `external-script-return.sh` 文件，并要求客户输入一个 `0` 到 `9` 之间的数字：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will now source the `external-script-return.sh` file and ask the customer
    for a digit between `0` to `9`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将加载 `external-script-return.sh` 文件，并要求客户输入一个 `0` 到 `9` 之间的数字：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will now source the `external-script-return.sh` file and ask the customer
    for a digit between `0` to `9`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将加载 `external-script-return.sh` 文件，并要求客户输入一个 `0` 到 `9` 之间的数字：
- en: '[PRE27]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We used the builtin command return to stop the execution of the inner script
    once a condition is met and returned an exit status to the parent script. Usually,
    we can use return without any exit code, and it will serve back the exit status
    of the last command executed, or we can use an integer between `0` to `255`. Would
    it not be nice to have in return something different from a simple number? Well,
    you can''t. Actually you can with a little trick. Let''s modify the previous child
    script:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了内建命令 `return` 来停止内部脚本的执行，一旦满足条件，就会返回一个退出状态到父脚本。通常，我们可以不带任何退出代码使用 `return`，它会返回上一个执行命令的退出状态，或者我们也可以使用一个介于
    `0` 到 `255` 之间的整数。难道不希望 `return` 返回一些不同于简单数字的东西吗？好吧，你不能。不过，你可以用一个小技巧来实现。让我们修改之前的子脚本：
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s call the script:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们调用这个脚本：
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'What did we do? We got rid of `return` and echoed on the standard output of
    our message. Then, from the calling script, we used a command substitution. What
    does this do? It simply reassigns the output of a command; in our case, we reassigned
    the output of the sourced script to the variable returning. You can do a command
    substitution using `...`: the classic backtics, which has been superseded by `$(...)`.
    So, use the latter form, since it is the most actual and also allows you to nest
    multiple command substitutions. Let''s give it a try:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了什么？我们去掉了`return`并将消息输出到标准输出中。然后，在调用脚本中，我们使用了命令替换。这是做什么的？它简单地重新分配了命令的输出；在我们的例子中，我们将被调用脚本的输出重新分配给了返回变量。你可以使用`...`进行命令替换：经典的反引号，虽然它已经被`$(...)`所取代。所以，使用后者，因为它是当前的形式，并且允许你嵌套多个命令替换。让我们试一下：
- en: '[PRE30]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Oh well, nice! It gave us the echoed string from the first case option, but
    unfortunately, we also trapped the message printed to the user asking to input
    a integer. Well, how do you get rid of it? You should already know this; just
    keep in mind that we are getting everything printed to `stdout`, and so we will
    need a tiny alteration to the inner script:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，好吧，不错！它给我们回传了来自第一个选项的回显字符串，但不幸的是，我们也捕获了要求用户输入整数的消息。那么，如何去除它呢？你应该已经知道了；只需记住，我们获取的是打印到`stdout`的所有内容，因此我们需要对内部脚本做一个小小的修改：
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We need one modification to the calling script so that the last line will be
    this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对调用脚本进行一次修改，以便最后一行会是这样的：
- en: '[PRE32]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It is time to test our modifications:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候测试我们的修改了：
- en: '[PRE33]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'What did we do? First, we redirected `stdout` to `stderr`; and both are attached
    to the terminal, so the user will still see the question asked by the script,
    but the sentence will not be caught by the command substitution since this latter
    works only with `stdout`. Then, we silenced the read builtin so that it will not
    `echo` to the `stdout` and the value typed by the customer; and at the end, we
    just printed the returned value without any comments. This gave us a neat output.
    This trick can be used when you have to return a value from a function to the
    main script body, and you do not want to be limited by the 0-255 value restriction
    of the returned builtin. A file can be sourced passing by it positional parameters
    with the following syntax:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了什么？首先，我们将`stdout`重定向到`stderr`；两者都与终端相连接，因此用户仍然可以看到脚本提出的问题，但该句子不会被命令替换捕获，因为命令替换只对`stdout`有效。然后，我们使`read`内建命令静默，以免它将值回显到`stdout`和客户输入的值；最后，我们只打印返回值，而没有任何注释。这给了我们一个整洁的输出。当你需要从函数返回一个值到主脚本体中时，这个技巧非常有用，而且不受返回内建命令0-255值限制的影响。一个文件可以通过以下语法被调用并传递位置参数：
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The sourced script will access the parameters value using `$1`, `$2`, and `$n`.
    From the 10th parameter, the value must be accessed bracketing the `${15}` variable.
    Before ending the description of the dot character, we should recall what we said
    in the previous chapter: a single dot is a link to the current directory. It is
    also widely used in filenames to specifically define file extensions. Finally,
    in the regular expressions context, the dot matches any single character except
    for the new line.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用的脚本将使用`$1`、`$2`和`$n`来访问参数的值。从第10个参数开始，必须通过`${15}`变量来访问值。在描述点字符之前，我们应该回顾一下上一章所说的内容：单个点是指向当前目录的链接。它在文件名中也被广泛使用，用来专门定义文件扩展名。最后，在正则表达式中，点表示匹配除换行符之外的任何单个字符。
- en: The double quotes ("...")
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双引号（"..."）
- en: Double quotes are also known as partial or weak quoting, which avoid the interpretation
    of most of the special characters by the shell. We will see more about them in
    the next section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号也称为部分引号或弱引号，它避免了外壳对大多数特殊字符的解释。我们将在下一节中进一步探讨它们。
- en: The single quotes ('...')
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单引号（'...）
- en: The single quote, also known as a full or strong quote, avoids the interpretation
    of all special characters by the shell. More information on it is mentioned in
    the next section.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号，也称为全引号或强引号，避免了外壳对所有特殊字符的解释。更多信息将在下一节中提到。
- en: The comma character (,)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逗号字符（,）
- en: 'The comma operator chains together arithmetic operations or strings:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号运算符将算术运算或字符串连接在一起：
- en: '[PRE35]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'What we can see here is that even though the operations are concatenated, only
    the value of the last one is returned. So, `x` is instanced with the value of
    just `6-1`. But, as I mentioned before, we can use the comma character to concatenate
    strings:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是，即使操作被串联起来，只有最后一个操作的值会被返回。所以，`x`被实例化为仅`6-1`的值。但正如我之前提到的，我们可以使用逗号字符来连接字符串：
- en: '[PRE36]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As you can see, you can concatenate a list of values to create new strings
    and do some funny stuff in the process:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以将一系列值连接起来，创建新的字符串，并在此过程中做一些有趣的事情：
- en: '[PRE37]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is funny, but it is up to you how to use it. You can cycle in a for statement
    and construct a list of paths to examine; for instance, the applications of a
    string concatenation is really up to your creativity.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，但使用它的方式由你决定。你可以在for语句中循环并构建一个路径列表进行检查；例如，字符串连接的应用完全取决于你的创造力。
- en: The ,, and , () case modificators
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ',, 和 , () 大小写修饰符'
- en: This is new in Bash 4.0, and it forces a lower case conversion in the parameter
    substitution.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Bash 4.0 新增的功能，它强制在参数替换中进行小写转换。
- en: The ^^ and ^ () case modificators
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ^^ 和 ^ () 大小写修饰符
- en: 'This is new in bash 4.0, it forces upper case conversion in the parameter substitution:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Bash 4.0 新增的功能，它强制在参数替换中进行大写转换：
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we will do a couple of tests, starting with a lowercase string:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将做几个测试，从小写字符串开始：
- en: '[PRE39]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we will test an upper case string:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将测试一个大写字符串：
- en: '[PRE40]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This comes in handy when you want to *normalize* a string that you retrieved
    for a previous operation or from a user input.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要*规范化*你从前一个操作或用户输入中获取的字符串时，这非常有用。
- en: The backslash (\)
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反斜杠 (\)
- en: This escape character is used to prevent the special characters interpretation
    by the shell. We saw an example of its usage in the previous bunch of code where
    we escaped `\${my_input}` so that the echo was able to print it literally as a
    string and not trying to output its value. Using `\` has the same effect as surrounding
    a variable with single quotes, so this is a strong quotation useful to literally
    print the `"` and `'` characters, which are usually interpreted as quotation characters.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转义字符用于防止特殊字符被 shell 解释。我们在前面的代码段中看到过它的使用，我们转义了`\${my_input}`，使得 echo 能够将其字面打印出来，而不是试图输出其值。使用`\`具有与将变量用单引号括起来相同的效果，因此这是一个强引用，对于字面打印`"`和`'`字符非常有用，这些字符通常被解释为引号字符。
- en: The forward slash (/)
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 斜杠 (/)
- en: 'The forward slash has two different uses:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 斜杠有两种不同的用途：
- en: It is a file name separator in paths, as we can see in the `/usr/lib/dbus-1.0/dbus-daemon-launch-helper`
    example. Every bit between a forward slash is a directory until the last leaf,
    which is a file.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是路径中的文件名分隔符，如我们在`/usr/lib/dbus-1.0/dbus-daemon-launch-helper`示例中看到的那样。每个斜杠之间的部分都是一个目录，直到最后的文件名。
- en: It is the arithmetic operator for the division.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是除法的算术运算符。
- en: '''...'''
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '''...'''
- en: This is the command substitution, and we just used it a few pages ago; it assigns
    the `stdout`  command to a variable.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令替换，我们在前几页刚刚使用过；它将`stdout`命令赋值给一个变量。
- en: The colon character (:)
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒号字符 (:)
- en: 'The colon does actually nothing except expanding arguments and performing redirection.
    It can be handy in cycles and tests to actually do nothing if a condition is met.
    It is also interesting to see how it can be used to evaluate a series of variables
    using the parameter substitution:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号实际上什么也不做，除了扩展参数并执行重定向。在循环和测试中，它可以在满足条件时什么也不做。看到它如何用于评估一系列变量的参数替换也很有意思：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is a bite on redirection:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是重定向的一个小例子：
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So, what we see here is that the combining of the colon with `>` gives us a
    quick method for truncating a regular file without changing the permission. If
    the file does not exist, it gets created; but if we use `>>`, it only creates
    a file and does not truncate a preexisting file. You will find more *strange* uses
    for a colon, such as a field separator in the `/etc/passwd` file or as a legit
    function name.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们在这里看到的是，冒号与`>`的组合为我们提供了一种快速截断普通文件的方法，而不改变其权限。如果文件不存在，它将被创建；但是，如果我们使用`>>`，它只会创建一个文件，而不会截断一个已存在的文件。你会发现冒号有更多*奇怪*的用途，比如在`/etc/passwd`文件中作为字段分隔符，或者作为合法的函数名称。
- en: The exclamation (!)
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惊叹号 (!)
- en: 'The exclamation mark is a keyword that negates or reverses a test or an exit
    status. For instance, take a look at this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 惊叹号是一个关键字，用来否定或反转一个测试或退出状态。例如，看看这个：
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The exit code of ls is `0`, true, since it was successful. But let''s reverse
    it:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls`的退出码是`0`，是的，因为它成功执行。但我们来反转它：'
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Keywords
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键字
- en: 'A *keyword* is a reserved word that has a special meaning to the shell and
    is hardwired in it such as the builtins; but differing from the latter, the keywords
    are not full-blown commands, but parts of a command construct, and you can have
    a list of these by just typing this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*关键字* 是一个保留字，在 shell 中具有特殊意义并且是硬编码的，比如内建命令；但不同于后者，关键字不是完整的命令，而是命令构造的一部分，你只需输入以下内容即可列出这些关键字：'
- en: compgen -k
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: compgen -k
- en: if
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: if
- en: then
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: then
- en: else
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: else
- en: elif
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: elif
- en: fi
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: fi
- en: case
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: case
- en: esac
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: esac
- en: for
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: for
- en: select
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: select
- en: while
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: while
- en: until
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: until
- en: do
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: do
- en: done
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: done
- en: in
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: in
- en: function
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: function
- en: time
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: time
- en: '{'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '{'
- en: '}'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '}'
- en: '!'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '!'
- en: '[['
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[['
- en: ']]'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ']]'
- en: From the command line, but not from a script, the exclamation mark triggers
    the bash history.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从命令行执行，但不是从脚本中执行时，感叹号会触发 bash 历史记录。
- en: The asterisk (*)
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 星号 (*)
- en: 'The asterisk, also known as a wildcard, when used in a file name expansion,
    matches all the file names in a directory. The file name expansion is also known
    as **Globbing**. It takes into account some special characters as `*`, which is
    expanded to all, and `?`, which expands to any single character along with some character
    lists in brackets:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 星号，也被称为通配符，在文件名扩展中使用时，匹配目录中的所有文件名。文件名扩展也叫做 **Globbing**。它考虑了一些特殊字符，如 `*`，它会扩展为所有内容，`?`，它会扩展为任何单个字符，并且还有一些字符集，使用括号表示：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As we can see in the example, we listed all the  `*` files whose names started
    either with `e` or `s`. But it also interprets the `^` character as negation:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在示例中看到的，我们列出了所有文件名以 `e` 或 `s` 开头的 `*` 文件。但它也将 `^` 字符解释为否定：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In this case, we listed all the files in the current directory whose names
    did not start with either `e` or `s`. Be careful as the `*` in file globbing does
    not trap file names starting with a dot:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们列出了当前目录下所有文件名不以 `e` 或 `s` 开头的文件。要小心，文件通配符中的 `*` 不会匹配以点开头的文件名：
- en: '[PRE47]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Something is clearly missing, so let''s try this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 显然缺少一些内容，我们再试试这个：
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You could also try this for some nice effects:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试这个，效果不错：
- en: '[PRE49]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Final remarks, you will find the asterisk used as a wild card in regular expressions
    as well with the same meaning and also as a multiplication operator in arithmetic
    operations.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的备注，你会发现星号在正则表达式中也被用作通配符，具有相同的含义，同时在算术运算中也用作乘法运算符。
- en: The double asterisk (**)
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双星号（**）
- en: 'The double asterisk is being used in two different contexts:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 双星号在两种不同的上下文中使用：
- en: It is used as a exponentiation operator in an arithmetic context
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在算术上下文中用作指数运算符
- en: It is used as an extended file match globbing operator from Bash 4, meaning
    it matches filenames and directories recursively
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它作为一个扩展的文件匹配通配符运算符从 Bash 4 开始使用，意味着它递归匹配文件名和目录。
- en: 'So, we have this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们有了这个：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is different from the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下内容不同：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The double star matched all files and directories globally. If the double star
    does not work for you, enable the globstar shell options with `zarrelli:~$ shopt
    -s globstar ; for i in ** ; do echo "$i" ; done`. The `globstar` value changes
    the way the shell interprets the double star, which, in a file name expansion,
    matches all files and any subdirectories. If the pattern is followed by a `/`,
    only the directories and subdirectories will be matched:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 双星号匹配所有文件和目录。如果双星号对你不起作用，可以通过 `zarrelli:~$ shopt -s globstar ; for i in ** ;
    do echo "$i" ; done` 来启用 globstar shell 选项。`globstar` 值改变了 shell 对双星号的解释方式，在文件名扩展中，匹配所有文件和任何子目录。如果模式后面跟着
    `/`，则只会匹配目录和子目录：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Test operators (?)
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试运算符（?）
- en: 'The test operator can be used in a few different scenarios. We already saw
    in the parameter substitution that it is used to check whether a variable has
    a value or not. In arithmetic operations, it can be used to implement the trinary
    or ternary operator in a C-style notation:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运算符可以用于几种不同的场景。我们已经在参数替换中看到，它用于检查变量是否有值。在算术运算中，它可以用来实现 C 风格的三元运算符：
- en: '[PRE53]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see, the C-style notation is more compact even though it is not
    as readable as a standard loop notation. Let''s try it here:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，C 风格的表示法更简洁，尽管它不如标准的循环表示法易读。让我们在这里尝试一下：
- en: '[PRE54]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Usually, you would write a control loop in the following way:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会以以下方式编写控制循环：
- en: '[PRE55]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But you can also use the C-style trinary operator to achieve the same result:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也可以使用 C 风格的三元运算符来实现相同的结果：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, we reached the same result but with a more compact code. Essentially,
    we give a condition that ends with the `?` character and then, alternative results
    follow, which are separated by a `:` character.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们得到了相同的结果，但代码更加简洁。实质上，我们给出了一个以`?`字符结尾的条件，然后，替代结果跟随其后，使用`:`字符分隔。
- en: 'We see that the C-style is widely used in loops and can be defined as a compound
    command used to evaluate mathematical expressions in a loop, and as seen in the
    previous example, assign a variable. It is made of three blocks: the first initializes
    a variable before the first iteration, the second checks for a condition that
    exits the look, and the third modifies the initial condition. Sounds strange?
    Look at this, it will look really familiar:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，C 风格在循环中被广泛使用，可以定义为在循环中用于评估数学表达式的复合命令，正如在前面的例子中所看到的，它还可以用于赋值一个变量。它由三个块组成：第一个在第一次迭代前初始化变量，第二个检查退出循环的条件，第三个修改初始条件。听起来很奇怪？看这个，它会显得非常熟悉：
- en: '[PRE57]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let''s execute it:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行它：
- en: '[PRE58]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Finally, you can find the quotation mark used for file name expansion in globbing
    as a wild card matching any one characters; in regular expressions, use it as
    a single character match.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在文件名扩展的通配符中找到用于文件名扩展的引号，它作为一个匹配任意单个字符的通配符；在正则表达式中，它用作单个字符匹配。
- en: The substitution ($)
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换（$）
- en: 'We already know this and have used it for the variable substitution that allows
    us to access the content of a variable:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道这个并且使用过它，用于变量替换，使我们能够访问变量的内容：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'But it is also used in a regular expression to match at the end of a line:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 它也被用于正则表达式中，以匹配行尾：
- en: '[PRE60]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this example, the output of `ls` is filtered on that file whose name ends
    with a single integer.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`ls` 的输出被过滤为名称以单个整数结尾的文件。
- en: The parameter substitution (${})
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数替换（${}）
- en: This gives us a parameter substitution, which we have already seen earlier in
    this book.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了一个参数替换，我们之前在本书中已经看到过。
- en: The quoted string expansion ($'...')
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引号字符串扩展（$'...'）
- en: 'This is a quoted string expansion, and it is used to expand escaped octal or
    hex values in Unicode or ASCII:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个引号字符串扩展，用于扩展 Unicode 或 ASCII 中的转义八进制或十六进制值：
- en: '[PRE61]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We just concatenated some escaped octal values to get a nice and welcoming ASCII
    string assigned to the variable `x`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚连接了一些转义的八进制值，以便得到一个漂亮且友好的 ASCII 字符串，并将其分配给变量`x`。
- en: The positional parameters ($* and $")
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置参数（$* 和 $"）
- en: 'The first (`$*`) represents all the positional parameters as a single string
    and the second (`$"`) represents all the positional parameters as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个（`$*`）表示所有位置参数作为一个单独的字符串，第二个（`$"`）表示所有位置参数，如下所示：
- en: '[PRE62]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now, let''s test it:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试它：
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As we can see in the first case, the parameters are passed as single words,
    but beware, `$*` must be quoted to avoid weird side effects of the expansion.
    `$@` passes each parameter as a quoted string without any interpretation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一个案例中看到的，参数作为单个单词传递，但要小心，`$*` 必须加引号，以避免扩展时出现奇怪的副作用。`$@` 将每个参数作为带引号的字符串传递，不做任何解释。
- en: The exit status ($?)
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 退出状态（$?）
- en: 'We already saw this representing the exit status of a command, function, and
    script:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到它表示命令、函数和脚本的退出状态：
- en: '[PRE64]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The process ID ($$)
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程 ID（$$）
- en: 'This holds the **Process ID** (**PID**) of the script that appears in the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这个持有**进程 ID**（**PID**），它在以下内容中出现：
- en: '[PRE65]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s execute it:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行它：
- en: '[PRE66]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Grouping the command (command1 ; command2 ; commandn)
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将命令分组（command1 ; command2 ; commandn）
- en: 'Grouping the commands into parenthesis have them executed in a subshell, and
    this has a subtle but outstanding implication: whatever you do in the subshell
    will not be reachable from the calling shell, so if you execute a subshell from
    a script with commands inside, what you will do in the subshell will not be available
    to the calling script:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将命令括在括号中会让它们在子 shell 中执行，这具有一个微妙但显著的含义：在子 shell 中所做的任何事情都无法从调用的 shell 中访问，因此，如果你从一个脚本执行一个包含命令的子
    shell，那么在子 shell 中所做的事情将无法传递到调用脚本：
- en: '[PRE67]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now, let''s execute the code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行代码：
- en: '[PRE68]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'It comes quite straightforward if we recall what we read in the first chapters:
    the subshell inherits the environment of the calling shell from the script, and
    so, it can access the value of the `x` variable, but it cannot inject back anything.
    So, after having multiplied the value of `x` for itself and reassigning it to
    the variable, we could print the result, `100`, in the subshell. But once we exited
    it, we were left with the original value of `x `and `10`. The value of `x` never
    changed in the main script; it changed only into the subshell. As we will see
    later in this book, `()` is also used to initialize an array:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾一下我们在第一章中读到的内容，这就变得很简单了：子shell继承了来自脚本的调用shell的环境，因此它可以访问变量`x`的值，但不能将任何内容注入回去。因此，在将`x`的值乘以自身并重新分配给变量后，我们可以在子shell中打印结果`100`。但一旦退出，我们将保留原始值`x`和`10`。变量`x`在主脚本中从未更改；它仅在子shell中更改。正如我们将在本书的后面看到的那样，`()`也用于初始化数组：
- en: '[PRE69]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The brace expansion can come handy to address multiple items at once:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号扩展可以方便地处理多个项目：
- en: '[PRE70]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In this case, we expanded `*` in files starting with whatever characters, and
    then ending with a dot, followed either by a single integer or a `txt` postfix.
    But we can actually apply a command to a list of files having the globbing taking
    effect:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们展开了以任意字符开头并以点结束，后面跟着单个整数或`txt`后缀的文件的`*`。但实际上，我们可以对列表中的文件应用命令，使其生效：
- en: '[PRE71]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Or simply, we can do as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 或者简单地，我们可以这样做：
- en: '[PRE72]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'But be careful; use no spaces inside the braces unless you escape or quote
    them; otherwise you could face weird issues:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但要小心，在大括号内不要使用空格，除非您转义或引用它们；否则您可能会遇到奇怪的问题：
- en: '[PRE73]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The extended brace expansion, available from Bash 3, is an easy way to create
    iterators:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展的大括号扩展，从Bash 3开始，是创建迭代器的简便方法：
- en: '[PRE74]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Or create something fancier, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 或者创建更复杂的东西，如下所示：
- en: '[PRE75]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The curly brackets are widely used to create the so-called anonymous functions,
    which have an interesting property: the code inside these kinds of functions are
    visible to the rest of the script. There is another way of grouping commands,
    but with some interesting differences:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号广泛用于创建所谓的匿名函数，这些函数具有一个有趣的属性：这些函数内部的代码对脚本的其余部分可见。还有一种组合命令的方式，但有一些有趣的区别：
- en: The commands are executed in the same shell, no subshell spawned
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令在同一个shell中执行，不会生成子shell
- en: Because of this, all the variables instanced inside the brackets are available
    from the calling shell, that is, from the calling script
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这个原因，所有在括号内实例化的变量都可以从调用shell中访问，也就是从调用脚本中。
- en: Braces are reserved words and must be separated from the elements enclosed using
    spaces or a metacharacter
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大括号是保留字，必须用空格或元字符与括号内的元素分开
- en: A newline or `;` is required at the end of the commands list
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令列表末尾需要换行符或`;`
- en: 'Here is an example of how to use the curly brackets:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用大括号的示例：
- en: '[PRE76]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, let''s run it:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来运行它：
- en: '[PRE77]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As you can see, we did not have to call the anonymous function to execute it
    differently from a normal function. We did not use the local scope for the variable
    since it is not allowed, and it will throw an error. We will see more about functions
    and scopes in a while.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们无需调用匿名函数来执行它与普通函数不同。我们没有使用本地作用域来存储变量，因为这是不允许的，这将引发错误。我们稍后将详细了解函数和作用域。
- en: Braces support I/O redirection for the code enclosed into it.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号支持代码的I/O重定向。
- en: Braces ({})
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大括号（{}）
- en: 'Again, braces have another meaning: using braces with `xargs -i` (replace string)
    can be a placeholder for names:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，大括号有另一种含义：与`xargs -i`（替换字符串）一起使用大括号可以作为名称的占位符：
- en: '[PRE78]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The full path ({} \;)
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整路径（{} \;）
- en: 'Used with `find -exec`, this holds the full path to the file located by find.
    It is not a shell builtin, and the semicolon at the end of the command sequence
    must be escaped to avoid shell interpretation:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与`find -exec`一起使用，这会保存find定位的文件的完整路径。它不是一个shell内建命令，并且必须转义命令序列末尾的分号，以避免shell解释：
- en: '[PRE79]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Expression ([])
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式（[]）
- en: This tests the expression between brackets. It is the shell builtin test and
    not the command called `/usr/bin/[`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这测试方括号之间的表达式。这是shell内建的测试，而不是称为`/usr/bin/[`的命令。
- en: '[[ -f copy.txt ]] && echo "file found'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[[ -f copy.txt ]] && echo "文件找到'
- en: Expression ([[]])
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式（[[]]）
- en: Again, this tests expressions between brackets, but in a more flexible way.
    We have already seen this in the previous chapters.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 再次测试方括号之间的表达式，但以更灵活的方式。我们在前几章中已经看到了这一点。
- en: The array index ([])
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组索引（[]）
- en: 'This points us to the object located into the array at the index specified
    between the brackets:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这指向数组中位于指定索引位置的对象：
- en: '[PRE80]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: We will see what an array is later on, as of now, just bear in mind that an
    array index starts from `0`, so `1` is the second element into it.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看到数组是什么，现在只需记住数组索引从`0`开始，因此`1`是数组中的第二个元素。
- en: Characters range ([])
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符范围（[]）
- en: 'This defines a range of characters matched in regular expressions:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了正则表达式中匹配字符的范围：
- en: '[PRE81]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: In this case, we matched all the filenames starting with a character in the
    range between `c` and `m`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们匹配了所有以`c`到`m`范围内的字符开头的文件名。
- en: Integer expansion ($[…])
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数扩展（$[…]）
- en: This is an integer expansion, deprecated and substituted by `((…))`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个整数扩展，已被弃用，并被`((…))`替代。
- en: Integer expansion (((..)))
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整数扩展（(((..)))）
- en: This is an integer expansion. We have already seen in the previous chapters
    how to use it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这是整数扩展。我们在前几章已经看到过如何使用它。
- en: DEMO
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示
- en: We saw this at the beginning of this book, and we know they are used for redirections. You
    will find more details on how to use it in the examples provided.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书开头已经看过这个，它们用于重定向。你将在提供的示例中找到更多如何使用它的细节。
- en: The here document (<<)
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: here文档（<<）
- en: 'A here document is a form of redirection that forces the shell to read the
    input from the subsequent block of characters up to a user-defined delimiter,
    and then it uses this bunch of characters as a standard input for a command or
    a file descriptor. As we can see in the next example, the argument for the `cat`
    command is not provided on the command line or asked to the user, but it is written
    into the script between the two `DELIMITER` words:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: here文档是一种重定向形式，它强制Shell从随后的字符块中读取输入，直到用户定义的分隔符，然后将这一串字符作为命令或文件描述符的标准输入。如我们在下一个例子中所见，`cat`命令的参数既没有在命令行提供，也没有询问用户，而是写入脚本中，位于两个`DELIMITER`词之间：
- en: '[PRE82]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, let''s run it:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行它：
- en: '[PRE83]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The delimiter at the right of `<<` can be whatever string you want as long
    as it matches with the last line: everything between the two delimiters will be
    used as standard input for, in our example, `cat`. Be aware that the delimiter
    is not subject to any command substitution, arithmetical, or pathname expansion.
    But if the delimiter is not quoted, then the lines between the delimiters are
    subject to the arithmetic and file expansions and the command substitution.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<`右侧的分隔符可以是你想要的任何字符串，只要它与最后一行匹配：在两个分隔符之间的所有内容将作为标准输入传递给我们的例子中的`cat`命令。请注意，分隔符不受任何命令替换、算术运算或路径名扩展的影响。但是如果分隔符没有被引用，则分隔符之间的行将受到算术和文件扩展以及命令替换的影响。'
- en: 'A nice touch is to add `–` at the right side of `<<`so that the trailing tab
    characters get stripped from the input, and this makes it possible to create indented
    here documents:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不错的做法是在`<<`的右侧添加`–`，这样可以去掉输入中的尾随制表符，这使得创建带缩进的here文档成为可能：
- en: '[PRE84]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You will now get this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在会得到这个：
- en: '[PRE85]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'If you swap `<<` with `<`, you will get an unindented input:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`<<`换成`<`，你将得到没有缩进的输入：
- en: '[PRE86]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The here string (<<<)
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这里字符串（<<<）
- en: 'The *here* string is a simple version of the *here* document, and it consists
    of a single line where the delimiter is expanded to feed the command:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*here*字符串是*here*文档的简化版本，它由一行组成，分隔符扩展后将命令传入：'
- en: '[PRE87]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The output is here:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 输出在这里：
- en: '[PRE88]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The ASCII comparison operators (<) and (>)
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASCII 比较运算符 (<) 和 (>)
- en: This is an ASCII comparison between strings. We already saw how to use these
    in the previous chapter.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对字符串的ASCII比较。我们在前一章已经看到了如何使用这些运算符。
- en: Delimiters (\< and \>)
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分隔符（\< 和 \>）
- en: 'Are delimiters are used to identify a word in a regular expression. Let''s
    create a file:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 分隔符用于在正则表达式中标识一个单词。让我们创建一个文件：
- en: '[PRE89]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, we will `grep` with the word delimiter set to `bar` with the `-o` option,
    which will output only the fragment that matched and not all the lines containing
    it:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用单词分隔符设置为`bar`，并使用`-o`选项进行`grep`，这将只输出匹配的片段，而不是包含它的所有行：
- en: '[PRE90]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This is correct. There is only one single word called `bar`; the others are
    composite words, and we can double check this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是正确的。只有一个名为`bar`的单词，其他的是复合单词，我们可以再次确认这一点：
- en: '[PRE91]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: If we do not look for the word named `bar`, but only for the matches of a three
    character string bar, we see that we can match it three times in the file.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不查找名为`bar`的单词，而只查找三个字符的字符串bar的匹配项，我们会发现它在文件中匹配了三次。
- en: The pipe character (|)
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道符号（|）
- en: 'The pipe is a classic example of inter process communication: it passes the
    `stdout` of a process to the `stdin` of another process:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是进程间通信的经典示例：它将一个进程的`stdout`传递给另一个进程的`stdin`：
- en: '[PRE92]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In this example, we just listed the content of the current directory and fed
    the output as the `stdin` of the `wc` utility, which counted how many lines there
    were in data just fed in. The command after the pipe runs in a subshell, so it
    will not be able to return any modified value to the parent process; and if one
    of the commands in the pipe aborts somehow, this leads to the so-called broken
    pipe and the execution of the pipe stops.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们仅列出了当前目录的内容，并将输出作为`stdin`传递给`wc`工具，后者统计了输入数据的行数。管道后的命令在子Shell中运行，因此无法将任何修改后的值返回给父进程；如果管道中的某个命令因故中止，这就会导致所谓的破损管道，管道执行停止。
- en: The force redirection (>|)
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制重定向 (>|)
- en: 'This forces redirection even if a `noclobber` option is set for the shell.
    Clobbering means the act of overwriting the content of a file, and this is something
    we have already seen with the redirection, but let''s have a look at this example:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 即使为Shell设置了`noclobber`选项，这也强制执行重定向。Clobbering是指覆盖文件内容的行为，这点我们在重定向时已经看到了，不过让我们看一下这个例子：
- en: '[PRE93]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Everything goes as expected. We redirected the output of the echo, and on the
    second run, we overwrote the content of the file. But let''s now set the `noclobber`
    option for the shell:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都按预期进行。我们重定向了`echo`的输出，并且在第二次运行时，覆盖了文件的内容。但现在让我们为Shell设置`noclobber`选项：
- en: '[PRE94]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We will try to overwrite the content of the file:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试覆盖文件的内容：
- en: '[PRE95]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'No way, we are prevented from the accidental overwriting by the `noclobber`
    option set for the shell:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 没办法，我们被`noclobber`选项所阻止，防止意外覆盖文件：
- en: '[PRE96]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In fact, the content of the file is still the same, but now, it is this:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，文件的内容仍然相同，但现在是这样的：
- en: '[PRE97]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'We forced the redirection and now the content of the file has changed:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强制了重定向，现在文件的内容已经改变：
- en: '[PRE98]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Let's revert the `noclobber` option.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们恢复`noclobber`选项。
- en: 'Have a look at `man bash` for some interesting options that you can set with
    the `set -o` option to alter the Bash behavior. For instance, take a look at this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一下`man bash`，它列出了很多有趣的选项，你可以使用`set -o`选项来改变Bash的行为。例如，看看这个：
- en: '`+B` disables the brace expansion'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+B`禁用花括号扩展'
- en: '`-f` disables the file name expansion, also known as globbing.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`禁用文件名扩展，也叫做通配符匹配。'
- en: '`-i` runs a script in the interactive mode'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i`以交互模式运行脚本'
- en: '`-n` reads the commands in a script but does not execute them; it is a classical
    dry run mode for syntax check'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-n`读取脚本中的命令但不执行它们；它是经典的干跑模式，用于语法检查'
- en: The `-o` posix makes everything a POSIX compliant
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-o`使得一切符合POSIX规范'
- en: The `-p` script runs as SUID
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`脚本以SUID身份运行'
- en: The `-r` script runs with a restricted shell
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`脚本在受限的Shell中运行'
- en: '`-s` the commands are read from the `stdin`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-s`命令从`stdin`读取'
- en: The `-v` commands are printed to `stdout` before their execution
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`命令在执行前会打印到`stdout`'
- en: '`-x` is similar to `-v`, but the commands get expanded'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-x`类似于`-v`，但命令会展开'
- en: The logical OR (||)
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑或运算符（||）
- en: We have already understood them, so have a look at the previous pages.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经理解了它们，所以可以查看前面的页面。
- en: DEMO
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示
- en: 'This sends a process into the background. Look at this:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将一个进程发送到后台。看这个：
- en: '[PRE99]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'It will hold the prompt for 5 seconds only if you put sleep in the background:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将sleep放在后台，它只会暂停5秒钟，之后返回提示符：
- en: '[PRE100]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The shell will give you back control immediately, since the sleep process will
    not get any more input from the terminal, leaving the command line available to
    the user. One of the benefits of this is that while you are limited to a single
    foreground process at time. Since during its execution, you will not be able to
    enter any other commands with background processes, you can spawn as many as you
    wish, given the system resources.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Shell会立即把控制权交还给你，因为sleep进程不会再从终端获取输入，命令行对用户保持可用。这样做的好处之一是，虽然你每次只能运行一个前台进程，但在执行期间，你无法输入其他命令与后台进程交互，因此，你可以根据系统资源的限制，启动任意数量的后台进程。
- en: 'You can manually force a foreground process to go to the background by pressing *Ctrl*
    + *Z *and then `fg`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过按下*Ctrl* + *Z*，然后输入`fg`，手动将前台进程切换到后台：
- en: '[PRE101]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Logical AND
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑与运算符
- en: This is the logical AND, and it returns `true` in a test if both the conditions
    are true.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这是逻辑与运算符，它会在测试中返回`true`，前提是两个条件都为真。
- en: The dash character (-)
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破折号字符(-)
- en: 'The dash is the option character, and usually, it denotes an optional parameter
    on a command line:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 破折号是选项字符，通常表示命令行中的可选参数：
- en: '[PRE102]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'It is also used in parameter substitution as the prefix for the default parameter,
    and it is also used to redirect from/to stdin/stdout:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 它还用作参数替换中的前缀，用于默认参数，并且也用于从stdin/stdout重定向：
- en: '[PRE103]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Or, it can do this:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它可以执行如下操作：
- en: '[PRE104]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: What we did is get the file name on the `stdout` using the command substitution,
    have it read from the `stdin` with the `-`, then the result of the `tar` operation
    redirected to the `stdout` to create the zipped file.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的操作是通过命令替换获取文件名并输出到`stdout`，通过`-`从`stdin`读取，然后将`tar`操作的结果重定向到`stdout`以创建压缩文件。
- en: 'We can also use the dash to go back to our previous directory as held in the
    environmental `$OLDPWD` variable:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用破折号返回到之前的目录，这个目录存储在环境变量`$OLDPWD`中：
- en: '[PRE105]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Finally, in an arithmetic operations context, the dash means minus, so we can
    subtract a number from another.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在算术运算上下文中，破折号表示减法，因此我们可以从一个数字中减去另一个数字。
- en: The double dash (--)
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双破折号（--）
- en: 'The double dash usually stands for long options for a command. For instance,
    in the next example, we use the short option called `-a` and the long option called
    `--all` to enable the same behavior for ls; the long option being usually a more
    human readable form of the shorter one. While the short option starts with a single
    dash, the long option starts with a double dash:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 双破折号通常代表命令的长选项。例如，在下一个示例中，我们使用名为`-a`的短选项和名为`--all`的长选项来启用相同的行为；长选项通常是短选项的更易读形式。短选项以单破折号开始，而长选项以双破折号开始：
- en: '[PRE106]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: It is also used, as we saw a few pages ago, with the set command to set Bash
    options.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 它也用于我们在几页前看到的`set`命令，以设置Bash选项。
- en: Operator =
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符 =
- en: 'It can be an assignment operator:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以是赋值运算符：
- en: '[PRE107]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'It can also be a string comparison operator:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以是字符串比较运算符：
- en: '[PRE108]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Operator +
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符 +
- en: 'This can be used as an operator in an arithmetic context to add a number to
    another one. In a regular expression scenario, it matches one or more of the previous
    regular expressions:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在算术运算上下文中，它可以用作操作符，将一个数字加到另一个数字上。在正则表达式场景中，它匹配一个或多个之前的正则表达式：
- en: '[PRE109]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The plus character is also used by some built-ins to enable some options in
    the parameter substitution context to mark the alternate value that a variable
    expands to:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 加号字符也被一些内建命令用于在参数替换上下文中启用某些选项，以标记变量扩展的替代值：
- en: '[PRE110]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: If `x` is set, it will be use the value of `20` otherwise a null string.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了`x`，它将使用值`20`，否则使用空字符串。
- en: The modulo operator (%)
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取模运算符（%）
- en: 'It is the arithmetic operator for modulo, the remainder of a division. The
    modulo operator is also used as the operator for pattern matching in a parameter
    substitution context:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这是取模的算术运算符，表示除法的余数。取模运算符也用作参数替换上下文中的模式匹配运算符：
- en: '[PRE111]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Operator ~
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符 ~
- en: 'This holds the same value of the environment variable called `$HOME`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示环境变量`$HOME`的相同值：
- en: '[PRE112]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Operator ~+
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符 ~+
- en: This is the current working directory whose value is held by the env variable
    named  `$PWD`.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当前工作目录，其值由名为`$PWD`的环境变量保存。
- en: Operator ~-
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符 ~-
- en: This is the previous working directory whose value is held by the env variable
    named `$OLDPWD`.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前的工作目录，其值由名为`$OLDPWD`的环境变量保存。
- en: Operator ~=
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '操作符 ~= '
- en: This is the matching operator for regular expressions inside double brackets.
    It has been introduced in Bash 3.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这是双括号内正则表达式的匹配操作符。它是在Bash 3中引入的。
- en: Operator ^
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符 ^
- en: In regular expressions it matches the given pattern starting from the beginning
    of the line. We saw some examples in the previous pages.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，它匹配从行首开始的给定模式。我们在前面的页面中看到了一些例子。
- en: The control characters (^ and ^^)
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制字符（^ 和 ^^）
- en: Introduced in Bash 4, they deal with the uppercase conversion in a parameter
    substitution context.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在Bash 4中引入的，它们用于在参数替换上下文中进行大写转换。
- en: 'Apart from the special characters that we saw so far, there is a combination
    of keys. They are usually called control characters that are not actually used
    in a script, but ease your interaction with the terminal. They are a combination
    of two characters, *Ctrl *and another one, pressed together; but they can also
    be written in escaped hexadecimal or octal notation:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们目前看到的特殊字符外，还有一个键组合，通常称为控制字符。它们并不直接在脚本中使用，而是便于你与终端的交互。它们是由两个字符组合而成，通常是*Ctrl*和另一个字符一起按下；但它们也可以以转义的十六进制或八进制表示：
- en: '*Ctrl*+*A*:  This moves the cursor at the beginning of a string of characters
    on the command line.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*A*：此操作将光标移动到命令行字符串的开头。'
- en: '*Ctrl*+B: This is a backspace, but it does not erase anything.'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*B*：这是退格键，但不会删除任何内容。'
- en: '*Ctrl*+C: This breaks out of a foreground job, terminating it.'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*C*：此操作会中断前台作业，并终止它。'
- en: '![](img/00006.jpeg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00006.jpeg)'
- en: '*Ctrl*+*D*: This exits on a shell. If the user is in a terminal window and
    typing, it erases the character the cursor is on. If there is nothing in the window,
    it gets closed.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*D*：此操作会退出shell。如果用户在终端窗口中并且正在输入，它会删除光标所在的字符。如果窗口为空，它将关闭窗口。'
- en: '*Ctrl*+*E*: This moves the cursor at the end of a string of characters on the
    command line.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*E*：此操作将光标移动到命令行中字符串的末尾。'
- en: '*Ctrl*+*F*: This moves the cursor forward of one position on the command line.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*F*：此操作将光标向前移动一个位置。'
- en: '*Ctrl*+*G*: In a terminal window, this could raise a beep.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*G*：在终端窗口中，这可能会发出一个蜂鸣声。'
- en: '*Ctrl*+*H*: This backspaces and deletes the character under the cursor while 
    backspacing, also known as **rubout**.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*H*：这是退格键，会删除光标下的字符，称为**rubout**。'
- en: '*Ctrl*+*I*: This is a horizontal tab.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*I*：这是水平制表符。'
- en: '*Ctrl*+*J*: This is the newline and it can also be expressed as the `\012`
    octal and the `\x0a` hexadecimal.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*J*：这是换行符，它也可以表示为`\012`八进制和`\x0a`十六进制。'
- en: '*Ctrl*+*K*: This is a vertical tab. In a terminal window, it deletes all the
    characters from under the cursor to the end of the line.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*K*：这是一个垂直制表符。在终端窗口中，它会删除光标下方到当前行末的所有字符。'
- en: '*Ctrl*+*L*: This is the formfeed, and it clears the screen from all the content.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*L*：这是换页符，它会清除屏幕上的所有内容。'
- en: '*Ctrl*+*M*: This is the carriage return.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*M*：这是回车符。'
- en: '*Ctrl*+*N*: This  deletes a line called back from the history on the command
    line.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*N*：此操作会从命令行历史中删除一行。'
- en: '*Ctrl*+*O*: Given on the command line, it brings you to a new line executing
    the current command on CLI .'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*O*：在命令行中输入时，它会带你到新的一行，并执行当前的命令。'
- en: '*Ctrl*+*P*: This  restores the last command from the history on the command
    line.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*P*：此操作会从命令行历史中恢复上一个命令。'
- en: '*Ctrl*+*Q*: This  resumes `stdin` in a terminal window.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*Q*：这是在终端窗口中恢复`stdin`的快捷键。'
- en: '*Ctrl*+*R*: This searches for text in the history, backwards.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*R*：此操作会在历史记录中向后搜索文本。'
- en: '*Ctrl*+*S*: This suspends `stdin` in a terminal window, resumed by *Ctrl*+*Q.*'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*S*：此操作会暂停终端窗口中的`stdin`，通过*Ctrl*+*Q*恢复。'
- en: '*Ctrl*+*T*: This swaps the character under the cursor with the preceding one
    on the command line.'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*T*：此操作会交换光标下的字符与前一个字符的位置。'
- en: '*Ctrl*+*U*: This deletes all characters between the cursor position and at
    the beginning of the command line. In some configurations, it deletes all the
    characters on the command line.'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*U*：此操作会删除光标位置与命令行开头之间的所有字符。在某些配置中，它会删除命令行上的所有字符。'
- en: '*Ctrl*+*V*: This is used mostly in editors, and it allows to enter control
    characters while inserting text.'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*V*：此操作主要在编辑器中使用，它允许在插入文本时输入控制字符。'
- en: '*Ctrl*+*W*: In a terminal or X term, it deletes characters backwards from under
    the cursor to the first whitespace; in some configurations, it deletes until the
    first non alphanumeric character is reached.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*W*：在终端或X终端中，它会删除从光标位置向后直到第一个空格的所有字符；在某些配置中，它会删除到第一个非字母数字字符为止。'
- en: '*Ctrl*+*X*: You will find it in quite a number of word processors, as a way
    to cut and paste text from the editor to the clipboard.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*X*：你会在许多文字处理软件中找到它，它用于将文本从编辑器剪切并粘贴到剪贴板。'
- en: '*Ctrl*+*Y*: This pastes the text erased with *Ctrl*+*U *or *Ctrl*+*W *back.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*Y*：此操作会将用*Ctrl*+*U*或*Ctrl*+*W*删除的文本粘贴回来。'
- en: '*Ctrl*+*Z*: This pauses a job that is in the foreground.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Ctrl*+*Z*：此操作会暂停正在前台运行的任务。'
- en: Whitespace: This is often used as a field separator. It is sometimes required
    in some context and forbidden in others, as we saw in some of the examples available
    in the previous chapters.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空格：通常用作字段分隔符。在某些情况下，它是必须的，而在其他情况下则是禁止的，就像我们在前几章的示例中看到的那样。
- en: Quoting and escaping
  id: totrans-423
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用和转义
- en: We've already seen how important quoting and escaping is in Bash, and this is
    due to the fact that some characters are not just what they look like, but they
    hold some special meaning for the shell, which interprets them whenever it meets
    them. But sometimes, we want these characters for just what they are; we want
    to keep whitespaces in a string and not split it up in words, or we just want
    to see if there is a `*` file name. Or we want to `echo` a double quote and not
    start a quote. So, we quote and escape to preserve what we see from what the shell
    could think it is.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在 Bash 中，引用和转义有多么重要，这归因于某些字符不仅仅是它们看起来的样子，而是对 shell 来说具有特殊意义，shell 会在遇到这些字符时进行解释。但有时候，我们希望这些字符仅仅是它们本来的样子；我们希望在字符串中保留空格，而不是将其分割成单词，或者我们只是想查看是否存在一个
    `*` 文件名。或者我们希望 `echo` 一个双引号而不是开始一个引用。因此，我们通过引用和转义来保持我们所看到的内容，避免 shell 对其进行解释。
- en: The backslash (\)
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反斜杠 (`\`)
- en: 'The backslash is the character we use to escape all the others. Great. What
    does it mean? Simply put, each character preceded by a backslash keeps its literal
    value or meaning. The backslash does not apply to an entire string, but just to
    its following character, and it is widely used to escape spaces in file names:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠是我们用来转义所有其他字符的字符。太好了。这意味着什么呢？简而言之，反斜杠前缀的每个字符都保持其字面值或含义。反斜杠并不是作用于整个字符串，而只是作用于其后面的字符，它被广泛用于转义文件名中的空格：
- en: '[PRE113]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Well, not exactly the result we wanted, but it is what we should have expected:
    the whitespace has been interpreted by the shell as a separator, so `mkdir` created
    as many directories as the words given as arguments. We need to have `mkdir` to
    parse a string complete with whitespaces and not a series of words split by spaces:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，结果并不是我们想要的，但它是我们应该预期的：空白字符被 shell 解释为分隔符，因此 `mkdir` 创建了与作为参数传入的单词数量相同的目录。我们需要让
    `mkdir` 解析一个包含空格的完整字符串，而不是一系列由空格分割的单词：
- en: '[PRE114]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Here we go, we finally have a directory whose name is filled with spaces.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们终于创建了一个名字中包含空格的目录。
- en: 'You can also see the backslash used in scripts or on the command line when
    your instructions are becoming a bit too long. You can see them when you want
    to go on a new line without triggering a carriage return, which would execute
    your incomplete command line:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在脚本或命令行中看到反斜杠的使用，当你的指令变得有些过长时。你会看到它们在你想换行而不触发回车时使用，这样就不会执行不完整的命令行：
- en: '[PRE115]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Double quotes ("")
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 双引号 (`""`)
- en: '**Double quotes** are the so-called weak quoting, since they prevent the interpretation
    by the shell of all metacharacters except for `$`, `"`, `''`, and `\`. This means
    a few things; the most important is that you can reference a variable value even
    if it is quoted:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '**双引号** 被称为弱引用，因为它们防止 shell 解释所有元字符，除了 `$`、`"`、`''` 和 `\`。这意味着一些事情；最重要的是，你可以引用变量值，即使它已经被引用：'
- en: '[PRE116]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'This also means that you can use backslash to escape `$` to print the literal
    `$a` string:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着你可以使用反斜杠来转义 `$`，以打印字面量的 `$a` 字符串：
- en: '[PRE117]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: So, to use one of the preceding interpreted characters, you have to escape it
    with a backslash.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要使用前面解释过的字符之一，你必须用反斜杠对其进行转义。
- en: 'Also, double quotes preserve whitespaces, so we can rewrite the command we
    saw earlier:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，双引号保留空格，所以我们可以重新编写之前看到的命令：
- en: '`mkdir this\ is\ a\ directory\ with\ spaces\ in\ the\ name` as `mkdir "this
    is a directory with spaces in the name".`'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkdir this\ is\ a\ directory\ with\ spaces\ in\ the\ name` 相当于 `mkdir "this
    is a directory with spaces in the name"`。'
- en: So, what if you want to prevent any interpretations at all? You have to rely
    on a strong quoting.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你想完全防止任何解释呢？你必须依赖强引用。
- en: Single quotes (')
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单引号 (`'`)
- en: 'Single quotes enable a strong quoting so that none of the metacharacters we
    saw before, such as `$`, `"`, `''`, and `\` , are interpreted; and everything
    quoted this way is taken literally except for the single quote itself, which keeps
    its function of the metacharacter. This means that you cannot use it at all since
    the usual way of taking the literal value of a character. Using a backslash does
    not work since inside the single quote, as the backslash itself loses its meta
    effect. One notable effect of strong quoting is that you cannot reference the
    value of a variable any longer:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号使得引用变得强力，这样我们之前看到的所有元字符，如 `$`、`"`、`'` 和 `\` 都不会被解释；而以这种方式引用的所有内容都按字面意思处理，除了单引号本身，它仍然保持作为元字符的功能。这意味着你根本无法使用它，因为通常我们通过这种方式获取字符的字面值。使用反斜杠是无效的，因为在单引号内，反斜杠本身失去了其元字符效果。强引用的一个显著效果是，你不能再引用变量的值：
- en: '[PRE118]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'That being said, we still have some characters with special meanings even after
    being escaped; here are some of them:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，即使在被转义后，我们仍然有一些字符带有特殊含义；以下是其中的一些：
- en: '`\a` is the alert'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\a` 是警告'
- en: '`\b` is the backspace'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\b` 是退格'
- en: '`\n` is the newline'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\n` 是换行符'
- en: '`\r` is the return'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\r` 是回车'
- en: '`\t` is the tab'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\t` 是制表符'
- en: '`\v` is the vertical tab'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`\v` 是垂直制表符'
- en: Summary
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now that we understand how to deal safely with variables and special characters,
    it is time to move toward something more useful in our everyday programming. In
    the next chapter, we will have a close look at the case construct, arrays, and
    functions; and this will allow us to create our first fully-fledged command-line
    parser.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何安全地处理变量和特殊字符，接下来是时候朝着我们日常编程中更有用的内容迈进。在下一章，我们将详细探讨案例结构、数组和函数；这些将帮助我们创建第一个完整的命令行解析器。
