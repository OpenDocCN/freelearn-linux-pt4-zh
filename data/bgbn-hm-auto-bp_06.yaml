- en: Chapter 6. Baby Room Sentinel
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 宝宝房间哨兵
- en: In this chapter, we're going to show a possible implementation of a baby room
    sentinel capable of monitoring the room by detecting whether our baby is crying
    or if the baby is breathing during sleep. Also, as a special feature, the system
    will be able to measure the baby's temperature with a contactless temperature
    sensor.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示一个可能的宝宝房间哨兵实现，它可以通过检测宝宝是否在哭泣或宝宝在睡觉时是否在呼吸来监控房间。另外，作为一个特别功能，该系统还能够通过非接触式温度传感器测量宝宝的体温。
- en: We'll see several kinds of sensor, such as pressure, sound, and temperature.
    Also, regarding the temperature sensors, we'll see an interesting infrared version
    that is useful to measure surface temperature without touching it. Additionally,
    we'll provide our prototype of a nice, tiny LCD screen in order to see what's
    going on in the baby's room.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到几种不同的传感器，如压力传感器、声音传感器和温度传感器。另外，关于温度传感器，我们还将看到一个有趣的红外版本，它可以在不接触物体的情况下测量表面温度。此外，我们还将展示一个小巧精致的LCD屏幕原型，以便观察宝宝房间的情况。
- en: The basics of functioning
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能基础
- en: When we have a baby, it's quite normal to buy different devices to check when
    the baby cries or has a fever, or if the baby is still breathing during sleep.
    So, in this chapter, we'll try to implement several smart sensors to detect these
    states of danger using our BeagleBone Black and some special sensors.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有了宝宝后，购买各种设备来检测宝宝是否在哭泣、发烧，或者在睡觉时是否仍在呼吸是很常见的。因此，在本章中，我们将尝试使用我们的BeagleBone
    Black和一些特殊传感器来实现几种智能传感器，以检测这些危险状态。
- en: Tip
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Warning! *Let me remind that this project is a prototype and it cannot be used
    as a personal safety application!* It's simply a study of a possible implementation
    of a baby room sentinel device.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 警告！*请让我提醒您，这个项目只是一个原型，不能作为个人安全应用使用！* 它仅仅是一个关于可能实现的宝宝房间哨兵设备的研究。
- en: '*Neither the author of this book nor Packt Publishing recommends or endorses
    that this product be used alone or as a component in any personal safety applications.*
    The reader is warned about the fact that these sensors and controls do not include
    the self-checking redundant circuitry needed for such use.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书作者和Packt出版社都不建议或支持将此产品单独使用或作为任何个人安全应用的组件。* 读者需要注意，这些传感器和控制器不包括用于此类用途的自检冗余电路。'
- en: '*Neither the author of this book nor Packt Publishing will be held liable for
    unauthorized use of this prototype. The users can use this device at their own
    risk!*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书作者和Packt出版社对未经授权使用此原型不承担任何责任。用户使用此设备需自担风险！*'
- en: 'To detect when the baby is crying, we can use a sound detector, as we did in
    the previous chapter; but this time, we should elaborate the input signal a bit
    more in order to effectively detect whether the baby is really crying or not.
    By looking at the following screenshot, we can see a simple 40 seconds plot of
    an audio signal of a crying baby (sample time is *Ts=0.01 s=10ms*):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测宝宝是否在哭泣，我们可以使用声音检测器，就像我们在上一章中做的那样；但这一次，我们应该稍微处理一下输入信号，以便有效地检测宝宝是否真的在哭泣。通过查看以下截图，我们可以看到一个简单的40秒的哭泣宝宝音频信号图（采样时间为*Ts=0.01
    s=10ms*）：
- en: '![The basics of functioning](img/B00255_06_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![功能基础](img/B00255_06_01.jpg)'
- en: In red is the raw audio signal, while in yellow is the average of that signal
    over a 5 second window over the current time, that is, the yellow signal is the
    average value of all collected audio samples in the last 5 seconds.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 红色部分是原始音频信号，黄色部分则是当前时刻5秒窗口内该信号的平均值，也就是说，黄色信号是过去5秒内所有采集到的音频样本的平均值。
- en: As already stated, the sampling time *Ts* is *10ms*, which is not suitable for
    an audio recording but is enough for our purposes. In fact, we can see that by
    using the average value represented by the yellow line, we can detect if the baby
    is crying by just using a suitable threshold.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，采样时间*Ts*为*10ms*，这对于音频录制来说并不适用，但足以满足我们的需求。事实上，我们可以看到，通过使用黄色线表示的平均值，我们只需使用合适的阈值，就能检测到宝宝是否在哭泣。
- en: 'Regarding the breathing, the problem is quite similar; in fact, we can suppose
    that, more or less, normal breathing during sleep may vary from 12 to 16 breaths
    per minute, that is, a frequency range from 0.26 Hz to 0.2 Hz. However, this time
    the average level of the signal is not useful, but we can use its amplitude in
    a suitable timing window instead. To better explain the concept, consider the
    following screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 关于呼吸，问题类似；事实上，我们可以假设，正常的睡眠呼吸频率大约在每分钟12到16次之间，也就是0.26 Hz到0.2 Hz的频率范围。然而，这次信号的平均水平没有用处，我们可以在一个合适的时间窗口内使用其幅度来替代。为了更好地解释这个概念，请看下面的截图：
- en: '![The basics of functioning](img/B00255_06_02.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![功能原理](img/B00255_06_02.jpg)'
- en: The red color is the raw pressure signal, while the yellow color is the average
    of that signal over a 5 second window up to the current time. As stated previously,
    the yellow signal is just the average value of all collected audio samples in
    the last 5 seconds (sampling time is still *Ts=10 ms*). The blue color is the
    amplitude of the pressure signal computed as the difference between the maximum
    and the minimum value found in the considered temporal window, that is, this time,
    we find the **maximum value** (**Vmax**) and the **minimum value** (**Vmin**)
    of the collected audio samples in the last 5 seconds each time, and we compute
    the difference between Vmax and Vmin.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 红色表示原始压力信号，而黄色表示该信号在当前时间之前5秒窗口内的平均值。如前所述，黄色信号仅是过去5秒内所有采集音频样本的平均值（采样时间仍为*Ts=10
    ms*）。蓝色表示压力信号的幅度，它是通过计算所考虑时间窗口内最大值和最小值之间的差异得出的，即这次，我们每次都会计算过去5秒内采集音频样本的**最大值**（**Vmax**）和**最小值**（**Vmin**），并计算Vmax与Vmin之间的差值。
- en: In the first 8 seconds of the preceding plot, the output is near to 0 since
    there is nothing on the sensor. Then, around *T = 8* seconds, a baby has been
    put on the sensor, so it starts to return higher values, as expected. In this
    situation, both the average and the amplitude of the input signal have grown and
    they reach (more or less) some stable values. However, the important thing to
    highlight is when the baby stops breathing (Don't worry! No baby stopped breathing
    during this test! It's just a simulation.). When the baby stops breathing (this
    happened near T = **38** seconds), the pressure sensor still detects something,
    and both the average and the amplitude decrease; but it's the pressure's amplitude
    that does the biggest jump! As you can see in the preceding screenshot, while
    the average moves from **700** to **450**, the amplitude moves from **700** to
    **10**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面图表的前8秒钟，输出接近0，因为传感器上没有任何物体。然后，约在*T = 8*秒时，一个宝宝被放置到传感器上，传感器开始返回较高的值，正如预期的那样。在这种情况下，输入信号的平均值和幅度都增加，并且达到了（或多或少）一些稳定值。然而，重要的是要强调的是，当宝宝停止呼吸时（不用担心！在这个测试中没有宝宝停止呼吸！这只是一个模拟）。当宝宝停止呼吸时（大约发生在T
    = **38**秒附近），压力传感器仍然探测到某些信号，且平均值和幅度都下降了；但最明显的变化是压力的幅度发生了最大的跳跃！正如你在上面的截图中看到的，当平均值从**700**降到**450**时，幅度从**700**降到**10**。
- en: 'For our prototype, we can use the pressure amplitude to detect the baby''s
    breath, and the pressure average to detect if a baby is present or not. The user
    should notice that both average and amplitude calculations can be done at the
    same time by using a C function like the following one:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的原型，我们可以使用压力幅度来检测宝宝的呼吸，而使用压力平均值来检测是否有宝宝在场。用户应注意，平均值和幅度的计算可以通过使用如下所示的C函数同时进行：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `extract()`function gets the `arr` array holding the pressure data and,
    by using a single `for` loop, it can do both calculations in parallel.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`extract()`函数获取包含压力数据的`arr`数组，并通过使用一个单一的`for`循环，可以并行执行这两个计算。'
- en: 'Regarding the pressure sensor, we have to take into account that it cannot
    work well if it is not properly put into a box with a special mechanism suitable
    to detect breath. In the following screenshot, I show a possible implementation
    of such a box:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于压力传感器，我们必须考虑到如果没有正确地将其放入一个具有特殊机制的盒子中，它无法正常工作，而该机制适用于检测呼吸。在下面的截图中，我展示了一个可能的这种盒子的实现：
- en: '![The basics of functioning](img/B00255_06_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![功能原理](img/B00255_06_03.jpg)'
- en: The box should be put under the baby near the back, and attention should be
    paid to ensure that the upper side is in the right position to capture the movement
    of the lungs. The top of the box (moving surface) can move up and down, thanks
    to the springs, and it can detect pressure due to the movement of the baby's lungs
    with the pin that impinges on the pressure sensor, conveying the pressure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子应放在婴儿背部附近，注意确保上面的位置正确，以捕捉肺部的运动。盒子的顶部（移动表面）可以上下移动，得益于弹簧，它可以通过婴儿肺部运动时的压力感应器探测到压力，并通过针脚传递压力。
- en: Now, the last thing to take care of is the digital thermometer to measure the
    body temperature level. For this purpose, we can use a normal temperature sensor,
    but since we're talking about babies, we'd like to use a contactless temperature
    sensor. These special sensors are capable to measure an object's temperature without
    touching it by using the infrared rays that a surface emits and that are in the
    *field-of-view* of the sensor. So, when there is nothing in front of the sensor,
    we can detect the environmental temperature, but when we approach a surface, we
    can detect the temperature of that surface without actually touching it!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后需要处理的是用于测量体温的数字温度计。为此，我们可以使用普通的温度传感器，但由于我们讨论的是婴儿，我们希望使用非接触式温度传感器。这些特殊的传感器能够通过使用物体表面发出的红外线，并且这些红外线位于传感器的*视野范围*内，从而在不接触物体的情况下测量物体的温度。所以，当传感器前面没有物体时，我们可以检测到环境温度，但当靠近一个表面时，我们可以在不接触它的情况下检测该表面的温度！
- en: 'The following screenshot shows a suitable zone to aim the sensor at in order
    to measure the baby''s temperature:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了一个合适的区域，用于对准传感器以测量婴儿的体温：
- en: '![The basics of functioning](img/B00255_06_04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![功能基础](img/B00255_06_04.jpg)'
- en: Setting up the hardware
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置硬件
- en: In this project, we are going to use two analog sensors, a digital sensor, and
    a tiny LCD to implement a little GUI. The analog sensors are connected to two
    different ADCs, while the digital sensor (the contactless temperature sensor)
    uses an I²C bus to communicate with the BeagleBone Black. Lastly, the tiny LCD
    is connected to our BeagleBone Black board by an SPI bus and some GPIOs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将使用两个模拟传感器、一个数字传感器和一个小型LCD来实现一个简单的GUI。模拟传感器连接到两个不同的ADC，而数字传感器（即非接触式温度传感器）通过I²C总线与BeagleBone
    Black通信。最后，小型LCD通过SPI总线和一些GPIO连接到我们的BeagleBone Black板。
- en: Regarding the alarm devices to alert the parents, we can use a normal buzzer
    or a more sophisticated SMS gateway, or both. But in any case, the connections
    of these devices can be retrieved from the preceding chapters, so, due to lack
    of space, I'm not going to add any of them in this chapter. The reader can try
    to implement both the hardware and software by themselves as an exercise.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于用来提醒父母的报警设备，我们可以使用普通的蜂鸣器，或者更先进的短信网关，甚至两者结合。但无论如何，这些设备的连接方式可以参考前面的章节，因此由于篇幅限制，本章不再添加相关内容。读者可以尝试自行实现硬件和软件作为练习。
- en: Setting up the contactless temperature sensor
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置非接触式温度传感器
- en: 'The contactless temperature sensor used in this prototype is shown in the following
    screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本原型中使用的非接触式温度传感器如下面的截图所示：
- en: '![Setting up the contactless temperature sensor](img/B00255_06_05.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![设置非接触式温度传感器](img/B00255_06_05.jpg)'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The devices can be purchased from [http://www.cosino.io/product/contactless-temperature-sensor](http://www.cosino.io/product/contactless-temperature-sensor),
    or found by surfing the Internet.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备可以从[http://www.cosino.io/product/contactless-temperature-sensor](http://www.cosino.io/product/contactless-temperature-sensor)购买，或者通过互联网查找。
- en: The user guide of this device is available at [https://www.sparkfun.com/datasheets/Sensors/Temperature/SEN-09570-datasheet-3901090614M005.pdf](https://www.sparkfun.com/datasheets/Sensors/Temperature/SEN-09570-datasheet-3901090614M005.pdf).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备的用户手册可以在[https://www.sparkfun.com/datasheets/Sensors/Temperature/SEN-09570-datasheet-3901090614M005.pdf](https://www.sparkfun.com/datasheets/Sensors/Temperature/SEN-09570-datasheet-3901090614M005.pdf)找到。
- en: 'This device is really interesting since it''s capable of measuring the temperature
    of an object without touching it! In reality, it is an infrared thermometer with
    a 17-bit resolution in wide temperature ranges: –40°C to 85°C for ambient temperature
    and –70°C to 382.2°C for an object''s temperature.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这款设备非常有趣，因为它能够在不接触物体的情况下测量物体的温度！实际上，它是一个红外线温度计，具有17位分辨率，覆盖广泛的温度范围：环境温度为–40°C至85°C，物体温度为–70°C至382.2°C。
- en: The measured value is the average temperature of all objects in the *field-of-view*
    of the sensor, so it's quite obvious that we can use it to measure the environmental
    temperature as well as body temperature. We simply need to place the sensor near
    our body, and there we have it!.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 测量的值是传感器视野内所有物体的平均温度，因此显然我们可以用它来测量环境温度以及人体温度。只需将传感器靠近身体，结果就出来了！
- en: Another important feature of this sensor is that it is a digital device, that
    is, data can be retrieved by using a digital connection, which is immune to disturbances
    from the environment, even over (relatively) long distances. So, we can consider
    to put it on a handpiece for more practical usage.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 该传感器的另一个重要特点是它是数字设备，也就是说，可以通过数字连接获取数据，这种连接对环境干扰免疫，甚至可以在（相对）较长的距离上使用。因此，我们可以考虑将其安装在手持设备上以实现更方便的使用。
- en: 'The bus available for this device is the I²C bus, and the necessary connections
    are reported in the following table:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设备使用的总线是I²C总线，所需的连接在下表中给出：
- en: '| Pin | Temperature sensor pin |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 | 温度传感器引脚 |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| P9.4 - **VCC** | 3 - **VDD** |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| P9.4 - **VCC** | 3 - **VDD** |'
- en: '| P9.17 - **SCL** | 1 - **SCL** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| P9.17 - **SCL** | 1 - **SCL** |'
- en: '| P9.18 - **SDA** | 2 - **SDA** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| P9.18 - **SDA** | 2 - **SDA** |'
- en: '| P9.2 - **GND** | 3 - **Vss** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| P9.2 - **GND** | 3 - **Vss** |'
- en: 'For completeness, the device''s pins mapping is shown in the following diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，设备的引脚映射显示在下图中：
- en: '![Setting up the contactless temperature sensor](img/B00255_06_06.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![设置无接触温度传感器](img/B00255_06_06.jpg)'
- en: 'Now, if everything has been properly connected, we can activate the I²C bus
    with the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果一切连接正确，我们可以使用以下命令激活I²C总线：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, by using the `i2cdetect` command, we should get something as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过使用`i2cdetect`命令，我们应该能看到类似以下的输出：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we can see that a device at address `0x5a` has answered.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个地址为`0x5a`的设备已做出响应。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that you may get a different address. In this case, all the following commands
    must be modified accordingly.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可能会获得不同的地址。在这种情况下，所有后续命令必须相应地进行修改。
- en: 'By looking at the datasheet, we discover that the temperature can be retrieved
    by reading at the device location `0x07`. So, by using the `i2cget` command, we
    can do the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看数据表，我们发现温度可以通过读取设备位置`0x07`来获取。因此，使用`i2cget`命令，我们可以执行以下操作：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output value can now be converted in **degrees Celsius** (**°C**) by multiplying
    it by 0.02 after converting it in a decimal value. So, we can use the following
    command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以通过将其转换为十进制后，再乘以0.02，来将输出值转换为**摄氏度**（**°C**）。因此，我们可以使用以下命令：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To better understand what we do with the preceding command, let me explain
    it by using a list of equivalent (and more readable) commands starting with the
    following one where, by using `i2cget`, we get the data from the sensor and store
    it in the `v_hex` variable:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解我们在前面的命令中所做的事情，下面我将通过一系列等效（且更易读）的命令来解释，从而展示如何通过使用`i2cget`从传感器获取数据，并将其存储到`v_hex`变量中：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we convert the hexadecimal value to a decimal one and store it in the
    `v_dec` variable by using the `bc` command as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`bc`命令将十六进制值转换为十进制，并将其存储在`v_dec`变量中，如下所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the end, we simply multiply the decimal value held in the `v_dec` variable
    by 0.02 to get the temperature in **degrees Kelvin** (**°K**). Then, we subtract
    the value 273.15 to get it in °C:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需将`v_dec`变量中保存的十进制值乘以0.02，就可以得到**开尔文温度**（**°K**）。然后，再减去273.15就能得到摄氏度（°C）：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, to measure body temperature, we simply need to aim the sensor at our head,
    near the temple, and execute the following command. I get the following output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要测量体温，我们只需将传感器对准我们的头部，靠近太阳穴，并执行以下命令。我的输出如下：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Great, I'm not ill!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我没有生病！
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reader can take a look at the book *BeagleBone Essentials*, *Packt Publishing*,
    written by the author of this book, in order to get more information regarding
    how to activate and use the I²C buses available on the system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可以参考《BeagleBone Essentials》一书，该书由本书的作者撰写，出版商为*Packt Publishing*，以获得更多关于如何激活和使用系统中可用的I²C总线的信息。
- en: Setting up the pressure sensor
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置压力传感器
- en: 'A pressure sensor is shown in the following image:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是压力传感器的示意图：
- en: '![Setting up the pressure sensor](img/B00255_06_07.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![设置压力传感器](img/B00255_06_07.jpg)'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The devices can be purchased from [http://www.cosino.io/product/pressure-sensor](http://www.cosino.io/product/pressure-sensor),
    or by surfing the Internet.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备可以从[http://www.cosino.io/product/pressure-sensor](http://www.cosino.io/product/pressure-sensor)购买，或者通过互联网搜索购买。
- en: The user guide of this device is available at [https://www.pololu.com/file/download/fsr_datasheet.pdf?file_id=0J383](https://www.pololu.com/file/download/fsr_datasheet.pdf?file_id=0J383).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备的用户手册可在[https://www.pololu.com/file/download/fsr_datasheet.pdf?file_id=0J383](https://www.pololu.com/file/download/fsr_datasheet.pdf?file_id=0J383)获得。
- en: This device can detect (and measure) a force acting on its active surface. In
    simple words, it can report pressure intensity by varying its internal resistance.
    From the datasheet, we can see that this resistance may vary from over 1 MΩ, when
    no force is present, to few hundred Ohms when a force is applied.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备可以检测（并测量）作用在其表面上的力。简单来说，它可以通过变化其内部电阻来报告压力强度。从数据手册中可以看到，当没有施加力时，该电阻可能超过1 MΩ，而当施加力时，则可能下降到几百欧姆。
- en: 'By remembering that the BeagleBone Black''s ADC inputs must be limited to 1.8V,
    we can use the circuitry shown in the following diagram to safely read from this
    sensor (see [Chapter 2](ch02.html "Chapter 2. Ultrasonic Parking Assistant"),
    *Ultrasonic Parking Assistant*):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过记住BeagleBone Black的ADC输入必须限制在1.8V，我们可以使用以下电路安全地读取此传感器的数据（请参阅[第2章](ch02.html
    "第2章 超声波停车助手")，*超声波停车助手*）：
- en: '![Setting up the pressure sensor](img/B00255_06_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![设置压力传感器](img/B00255_06_08.jpg)'
- en: In the preceding diagram, *R=6.8 KΩ* and **Rp** are the pressure sensor's internal
    resistors, which are represented by a variable resistor.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，*R=6.8 KΩ* 和 **Rp** 是压力传感器的内部电阻，它们由可变电阻表示。
- en: Tip
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Note that the preceding circuitry not only connects the sensor to the BeagleBone
    Black''s ADC input pin, but also prevents the input voltage on that pin from going
    lower than the critical value of 1.8V! The V[ADCin] voltage is given by the following
    formula:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述电路不仅将传感器连接到BeagleBone Black的ADC输入引脚，还防止该引脚的输入电压低于临界值1.8V！V[ADCin]电压由以下公式给出：
- en: '*V[ADCin] = R / (R + Rp + R) * Vcc = R / (2R + Rp) * Vcc*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*V[ADCin] = R / (R + Rp + R) * Vcc = R / (2R + Rp) * Vcc*'
- en: Now, we know that *Vcc* is 3.3V, so, even in case that the *Rp* value drops
    to 0 Ω, the *V[ADCin]* is equal to Vcc/2, that is, 1.65V, which is a safe value
    for the BeagleBone Black's ADCs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道*Vcc*是3.3V，所以即使*Rp*值降到0 Ω，*V[ADCin]*也等于Vcc/2，即1.65V，这是BeagleBone Black的ADC安全值。
- en: This sensor must be connected to the BeagleBone Black at the *AIN1* input pin,
    which is labeled *P9.40*, while the other end must be connected to the resistor
    R, as shown in the preceding circuitry diagram.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该传感器必须连接到BeagleBone Black的*AIN1*输入引脚，该引脚标记为*P9.40*，另一端则必须连接到电阻R，如前述电路图所示。
- en: 'Now, to check all connections, we can enable the BeagleBone Black''s ADCs by
    using the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了检查所有连接，我们可以使用以下命令启用BeagleBone Black的ADC：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'These settings can be done by using the `bin/load_firmware.sh` script in the
    book''s example code repository, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用书中的示例代码仓库中的`bin/load_firmware.sh`脚本来完成这些设置，具体如下：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we can read the pressure on the sensor with the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下命令读取传感器上的压力：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding value is due to the fact that there is nothing on the sensor;
    but if we simply try to put a finger on it and then reread the sensor, we get
    the following result:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述值是因为传感器上没有任何物体；但是，如果我们只是尝试用手指触碰它，然后重新读取传感器，我们会得到以下结果：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: So, the higher the pressure on the sensor, the higher the returned value.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，传感器上的压力越高，返回的值也越高。
- en: Setting up the sound detector
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置声音检测器
- en: 'The sound detector is the same as the one used in [Chapter 5](ch05.html "Chapter 5. WhatsApp
    Laundry Room Monitor"), *WhatsApp Laundry Room Monitor*, so you can take a look
    at the *Setting up the hardware* section in the same chapter to see how to set
    up and test this device. However, for the sake of completeness, some basic information
    about it is provided again, and it''s shown in the following image:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 声音检测器与[第5章](ch05.html "第5章 WhatsApp 洗衣房监控")中使用的相同，即*WhatsApp 洗衣房监控*，因此你可以查看同一章节中的*硬件设置*部分，了解如何设置和测试该设备。不过，为了完整性，关于它的一些基本信息再次提供，并且展示在下面的图像中：
- en: '![Setting up the sound detector](img/B00255_06_09.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![设置声音检测器](img/B00255_06_09.jpg)'
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The devices can be purchased from [http://www.cosino.io/product/sound-detector](http://www.cosino.io/product/sound-detector),
    or by surfing the Internet.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备可以从 [http://www.cosino.io/product/sound-detector](http://www.cosino.io/product/sound-detector)
    购买，或通过互联网浏览获得。
- en: The board is based on the amplifier LMV324, with the datasheet available at
    [http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/LMV324.pdf](http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/LMV324.pdf),
    while the board's schematic is available at [http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/sound-detector.pdf](http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/sound-detector.pdf).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该板基于放大器 LMV324，数据手册可在 [http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/LMV324.pdf](http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/LMV324.pdf)
    上找到，板的原理图可在 [http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/sound-detector.pdf](http://dlnmh9ip6v2uc.cloudfront.net/datasheets/Sensors/Sound/sound-detector.pdf)
    上找到。
- en: 'The connections are in the following table:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 连接信息如下表所示：
- en: '| Pin | Sound sensor |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 | 声音传感器 |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| P9.4 - VCC | VCC |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| P9.4 - VCC | VCC |'
- en: '| P9.39 - AIN0 | R @ENVELOPE |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| P9.39 - AIN0 | R @ENVELOPE |'
- en: '| P9.3 - GND | GND |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| P9.3 - GND | GND |'
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that the ADCs input must be limited to 1.8V, so we must scale the sensor's
    output voltage by a factor of two, as described in the previous chapter.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，ADC 输入必须限制在 1.8V，因此我们必须将传感器的输出电压缩小两倍，正如前一章所述。
- en: 'Now, to check all connections, we can use the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要检查所有连接，我们可以使用以下命令：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you try to speak while you rerun the command, you should get a higher value,
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在重新运行命令时试图发声，你应该会得到更高的值，如下所示：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, the higher the environmental sound, the higher the returned value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，环境声音越大，返回的值就越高。
- en: Connecting the tiny LCD
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接微型 LCD
- en: 'The tiny LCD used in this chapter is shown in the following image:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用的微型 LCD 如下图所示：
- en: '![Connecting the tiny LCD](img/B00255_06_10.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![连接微型 LCD](img/B00255_06_10.jpg)'
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The device can be purchased from [http://www.cosino.io/product/color-tft-lcd-1-8-160x128](http://www.cosino.io/product/color-tft-lcd-1-8-160x128),
    or by surfing the Internet.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该设备可以从 [http://www.cosino.io/product/color-tft-lcd-1-8-160x128](http://www.cosino.io/product/color-tft-lcd-1-8-160x128)
    购买，或通过互联网浏览获取。
- en: The LCD is based on the ST7735R chip, which has its datasheet at [https://www.adafruit.com/datasheets/ST7735R_V0.2.pdf](
    https://www.adafruit.com/datasheets/ST7735R_V0.2.pdf).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该 LCD 基于 ST7735R 芯片，数据手册可以在 [https://www.adafruit.com/datasheets/ST7735R_V0.2.pdf](https://www.adafruit.com/datasheets/ST7735R_V0.2.pdf)
    上找到。
- en: 'As stated previously, to connect the LCD, we must use an SPI bus and some GPIOs
    available in the BeagleBone Black''s expansion connectors. The following table
    shows the electrical connections between the BeagleBone Black''s pins and the
    LCD pins:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，要连接 LCD，我们必须使用 SPI 总线和 BeagleBone Black 扩展连接器中可用的一些 GPIO。下表显示了 BeagleBone
    Black 引脚与 LCD 引脚之间的电气连接：
- en: '| Pin | LCD pin |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 | LCD 引脚 |'
- en: '| --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| P9.4 - Vcc | 9 - Vcc |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| P9.4 - Vcc | 9 - Vcc |'
- en: '| P9.29 - MISO | Not connected |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| P9.29 - MISO | 未连接 |'
- en: '| P9.30 - MOSI | 4 - MOSI |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| P9.30 - MOSI | 4 - MOSI |'
- en: '| P9.31 - SCLK | 3 - SCK |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| P9.31 - SCLK | 3 - SCK |'
- en: '| P9.28 - SS0 | 5 - TFT_CS |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| P9.28 - SS0 | 5 - TFT_CS |'
- en: '| P9.25 | 7 – D/C |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| P9.25 | 7 - D/C |'
- en: '| P9.27 | 8 - RESET |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| P9.27 | 8 - RESET |'
- en: '| P8.19 | 1 - LITE |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| P8.19 | 1 - LITE |'
- en: '| P9.2 - GND | 10 - GND |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| P9.2 - GND | 10 - GND |'
- en: 'To enable the device, we can use a driver that should already be available
    on your system. To verify it, just use the following command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用设备，我们可以使用一个驱动程序，该驱动程序应该已经在系统中可用。要验证它，只需使用以下命令：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In my kernel configuration, the driver is statically linked into the kernel,
    but it''s okay to have it as a module. In this case, the output should be something
    like the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的内核配置中，驱动程序是静态链接到内核中的，但将其作为模块也没问题。在这种情况下，输出应类似于以下输出：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After checking the driver, we also need a proper DTS file to set up the kernel.
    Instead of writing a new one from scratch, I got a suitable DTS file from the
    following URL by using the `wget` command:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 检查驱动程序后，我们还需要一个合适的 DTS 文件来设置内核。为了避免从头开始编写，我通过 `wget` 命令从以下 URL 获取了一个合适的 DTS
    文件：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After the download, we need only to compile the preceding DTS file by using
    the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下载后，我们只需要使用以下命令编译前面的 DTS 文件：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we can enable the LCD by using the usual `echo` command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用常规的 `echo` 命令启用 LCD：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'If we get the following error then we have to disable the HDMI support:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遇到以下错误，则需要禁用 HDMI 支持：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'This can be done by editing the u-boot settings in the `/boot/uboot/uEnv.txt`
    file and then enabling the following line by uncommenting it:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过编辑 `/boot/uboot/uEnv.txt` 文件中的 u-boot 设置，然后启用以下行，方法是取消注释：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note that on some BeagleBone Black versions, you may find the `uEnv.txt` file
    under the `/boot` directory instead, and the u-boot setting to modify it is as
    follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在某些 BeagleBone Black 版本中，`uEnv.txt` 文件可能位于 `/boot` 目录下，修改它的 u-boot 设置如下：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Then, we only have to reboot the system. Now, if everything is done correctly,
    we should be able to execute the preceding command without errors.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需重启系统。如果一切正确，我们应该能够无错误地执行前述命令。
- en: If everything works well, the BeagleBone Black should enable a colored framebuffer
    device 32 x 26 characters wide represented in the user space by the **/dev/fb0**
    device.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，BeagleBone Black 应该启用一个彩色帧缓冲设备，宽度为 32 x 26 字符，并通过 **/dev/fb0** 设备在用户空间中表示。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reader can take a look at the book *BeagleBone Essentials*, *Packt Publishing*,
    written by the author of this book, in order to get more information regarding
    how to activate and use the SPI buses available on the system, how to recompile
    a kernel driver, and to have a brief description of the DTS file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可以查看本书作者所写的《*BeagleBone Essentials*》，*Packt Publishing*，以获取更多关于如何激活和使用系统上可用的
    SPI 总线、如何重新编译内核驱动程序以及 DTS 文件简要描述的信息。
- en: 'As a final note, the reader should remember that we can print strings on the
    LCD by using the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，读者应记得，我们可以通过以下命令在 LCD 上打印字符串：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the `/dev/tty0` device is the one connected to the terminal running on
    the `/dev/fb0` framebuffer.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`/dev/tty0` 设备是连接到在 `/dev/fb0` 帧缓冲上运行的终端的设备。
- en: The final picture
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终图片
- en: 'The following image shows the prototype I made to implement this project and
    test the software:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片展示了我为实施这个项目并测试软件所制作的原型：
- en: '![The final picture](img/B00255_06_11.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![最终图片](img/B00255_06_11.jpg)'
- en: Note that the contactless temperature sensor has been connected to the board
    by using a flat cable in order to easily move it to measure the temperature of
    different objects.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，非接触式温度传感器已经通过平带电缆连接到板上，方便将其移动到不同的物体上进行温度测量。
- en: Setting up the software
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置软件
- en: In this project, we're going to show a trick to exchange data between two processes
    in a very simple manner. At the beginning of the chapter, it was mentioned that
    the ADCs must be sampled at 100Hz, but we don't need to be so fast to render a
    simple interface on the external LCD. In fact, a reasonable updating frequency
    for the user interface can be 1Hz (once per second.) So, to keep the code simple,
    we implement our device by using two different processes running at different
    frequencies that exchange data with each other instead of using a single process.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将展示一个在两进程之间交换数据的简单方法。在本章开始时提到，ADC 必须以 100Hz 的频率进行采样，但我们并不需要这么快就能在外部
    LCD 上呈现一个简单的界面。实际上，用户界面的合理更新频率可以是 1Hz（每秒一次）。因此，为了保持代码简洁，我们通过使用两个不同频率运行的进程来实现我们的设备，它们相互交换数据，而不是使用单一进程。
- en: Simply speaking, if we realize a program called `adc` that reads the data from
    the ADCs at 100Hz and then prints its output on the `stdout` stream (standard
    output) at 1Hz, we can redirect such output to another program called `lcd.sh`
    that reads the data from its `stdin` stream (standard input) at 1Hz and then draws
    the user interface accordingly.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，如果我们实现一个名为 `adc` 的程序，它以 100Hz 的频率从 ADC 读取数据，并以 1Hz 的频率将输出打印到 `stdout` 流（标准输出），我们可以将此输出重定向到另一个名为
    `lcd.sh` 的程序，它以 1Hz 的频率从 `stdin` 流（标准输入）读取数据，并相应地绘制用户界面。
- en: 'The data flow is unidirectional. Program `adc` reads data from the ADC and,
    after its elaboration stage, sends its output to `lcd.sh` that manages the LCD.
    This special functioning is very well represented by a Unix *pipe* as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流是单向的。程序 `adc` 从 ADC 读取数据，并在经过处理阶段后，将其输出发送到 `lcd.sh`，该程序管理 LCD。这个特殊的功能可以通过
    Unix 的 *管道* 很好地表示，如下所示：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The reader should also notice that the timing for the interface is generated
    by the `adc` program simply printing its output at well-defined intervals, without
    any other timing mechanisms, into the `lcd.sh` program. So, let's see how we can
    do that.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 读者还应注意，接口的定时是由 `adc` 程序生成的，它只是以预定的间隔打印输出，没有任何其他定时机制，直接输出到 `lcd.sh` 程序。所以，让我们看看如何做到这一点。
- en: The ADC manager
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADC 管理器
- en: As stated previously, to correctly manage and analyze the ADC's input signals,
    we need a low jitter and fine-grained sampling time. It has already been mentioned
    that having *Ts=10 ms* as the sampling time would be enough for our purposes,
    so let's see how we can get it!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，要正确管理和分析 ADC 的输入信号，我们需要低 `jitter` 和细粒度的采样时间。已经提到，使用 *Ts=10 ms* 作为采样时间对于我们的目的足够了，那么让我们看看如何实现它！
- en: 'In [Chapter 5](ch05.html "Chapter 5. WhatsApp Laundry Room Monitor"), *WhatsApp
    Laundry Room Monitor*, we used a simple Bash script to read from the ADC; but
    for that prototype, the signal frequency was so low that the implemented solution
    was really reliable. Now we have to do something more elaborate. This time, we''re
    going to use a C program to read data from the ADCs, as shown in the following
    code snippet:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章 WhatsApp 洗衣房监视器")《WhatsApp 洗衣房监视器》中，我们使用了一个简单的 Bash 脚本从
    ADC 读取数据；但是对于那个原型，信号频率如此之低，以至于实现的解决方案非常可靠。现在，我们需要做一些更复杂的事情。这次，我们将使用 C 程序从 ADC
    读取数据，如以下代码片段所示：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code can be found in the `chapter_06/adc_simple.c` file in the
    book's example code repository.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可以在书籍示例代码库中的 `chapter_06/adc_simple.c` 文件中找到。
- en: The code can be compiled directly on the BeagleBone Black by using the `make`
    command.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以通过 `make` 命令直接在 BeagleBone Black 上编译。
- en: The code functioning is simple. First, we get the current time with the `clock_gettime()`
    function. Then, we read the data from the ADC by accessing it from the `sysfs`
    interface. And, at the end, we compute the amount of time to sleep for before
    reaching the new active period.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的功能很简单。首先，我们使用 `clock_gettime()` 函数获取当前时间。然后，通过 `sysfs` 接口读取来自 ADC 的数据。最后，我们计算出在到达新的活动周期前需要休眠的时间。
- en: 'By running the preceding code, we get the following output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码后，我们得到以下输出：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As we notice from the preceding output, the program is quite precise; but if
    we use a simple `awk` script to compute the minimum, maximum, and average `jitter`
    value over 1,000 samples, we discover that the program is not so precise:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从前面的输出中看到的，程序相当精确；但是，如果我们使用一个简单的 `awk` 脚本来计算 1,000 个样本中的最小值、最大值和平均 `jitter`
    值，我们会发现程序并不是那么精确：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `awk` script file `jitter.awk` can be found in the `chapter_06/jitter.awk`
    file in the book's example code repository.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`awk` 脚本文件 `jitter.awk` 可以在书籍示例代码库中的 `chapter_06/jitter.awk` 文件中找到。'
- en: 'The average and the minimum values are acceptable, but the maximum one is really
    high. Moreover, sometimes the following may happen:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 平均值和最小值是可以接受的，但最大值确实很高。此外，有时可能会发生以下情况：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This error happens when the delay computed in the following lines becomes negative:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当以下行中计算出的延迟变为负值时，会发生此错误：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the system is too slow in scheduling the process at the beginning of the
    period, it may happen that we do not have enough time to complete our task! This
    is due to the fact that we are not using a real-time system and we have no guarantees
    of correct scheduling.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统在周期开始时调度进程太慢，可能会发生我们没有足够的时间完成任务！这是因为我们没有使用实时系统，并且没有保证正确调度。
- en: 'However, we can try to resolve this problem with some tricks. The Linux kernel
    is not real time, but it has some facilities that may help us in realizing an
    acceptable compromise. In fact, the system allows us to use different schedulers
    to manage the processes running on the BeagleBone Black. In particular, we can
    use the `chrt` command to manipulate the real-time schedule attributes of a process
    and then to set the **FIFO scheduler** that may help us to reduce the `jitter`
    value and the scheduling delay error. If we rerun the preceding test using the
    `chrt` command as follows, we get a different result:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以尝试通过一些技巧来解决这个问题。Linux 内核并非实时系统，但它有一些可以帮助我们实现可接受折衷的功能。实际上，系统允许我们使用不同的调度器来管理
    BeagleBone Black 上运行的进程。特别是，我们可以使用 `chrt` 命令来操作进程的实时调度属性，然后设置 **FIFO 调度器**，这可能有助于减少
    `jitter` 值和调度延迟错误。如果我们使用 `chrt` 命令重新运行前面的测试，如下所示，我们将获得不同的结果：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Also, the scheduling delay error disappears!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，调度延迟错误消失了！
- en: Tip
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that even using the `chrt` command, the Linux kernel is not real time anyway,
    so nobody can guarantee that everything will go well forever! To make the system
    reliable, we have to add some recovery code in case something goes wrong.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使使用 `chrt` 命令，Linux 内核仍然不是实时的，因此没有人能保证一切会永远顺利！为了使系统可靠，我们需要添加一些恢复代码，以防出现问题。
- en: 'Considering what was just explained, a possible implementation of the ADC manager
    is reported in the following code snippet:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到刚才所解释的，以下代码片段展示了可能的ADC管理器实现：
- en: '[PRE31]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code can be found in the `chapter_06/adc.c` file in the book's
    example code repository.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 完整代码可以在书籍的示例代码库中的`chapter_06/adc.c`文件找到。
- en: The `setlinebuf()` function is needed to force an output at each printed line,
    while the `sched_setscheduler()` function is used to enable the FIFO scheduler
    (as the `chrt` command does). The code is quite similar to before except the fact
    that we use the `extract()` function (mentioned at the beginning of this chapter)
    to calculate the average, minimum, and maximum values of the input data as requested.
    Note that the program prints its output once per second, thanks to the `ticks`
    variable.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`setlinebuf()`函数用于强制在每一行输出时刷新，而`sched_setscheduler()`函数则用于启用FIFO调度器（就像`chrt`命令一样）。这段代码与之前的代码非常相似，唯一不同的是我们使用了`extract()`函数（在本章开头提到过）来计算输入数据的平均值、最小值和最大值。请注意，程序每秒打印一次输出，这要归功于`ticks`变量。'
- en: 'If executed, the program will then print several lines, one per second, reporting
    the pressure average value, the pressure signal amplitude, and the sound average
    value, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行该程序，它将每秒打印几行，报告压力的平均值、压力信号的幅度以及声音的平均值，内容如下：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: All this data is taken as inputs by the `lcd.sh` process described in the following
    section.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数据都作为输入由`lcd.sh`进程获取，该进程将在下一节中描述。
- en: Note
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the BeagleBone Black's ADCs have a continuous mode function that can
    be used to reach a higher sampling rate, but I didn't use it in this project due
    to the fact that it's not strictly needed nor supported on all kernels.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，BeagleBone Black的ADC具有连续模式功能，可以用来提高采样率，但由于该功能在所有内核中并非严格必要且并非所有内核都支持，因此我在这个项目中没有使用它。
- en: The curious reader can get further information about this topic at [http://processors.wiki.ti.com/index.php/AM335x_ADC_Driver's_Guide](http://processors.wiki.ti.com/index.php/AM335x_ADC_Driver's_Guide).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 好奇的读者可以通过[http://processors.wiki.ti.com/index.php/AM335x_ADC_Driver's_Guide](http://processors.wiki.ti.com/index.php/AM335x_ADC_Driver's_Guide)获取更多关于此主题的信息。
- en: The LCD manager
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LCD管理器
- en: The program that manages the LCD is a simple Bash script that uses some tricks
    to realize a fancy rendering of the collected data.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 管理LCD的程序是一个简单的Bash脚本，它使用一些技巧来实现对采集数据的精美渲染。
- en: 'As stated previously, this program runs each second, thanks to the ADC manager
    that sends its output periodically to the `lcd.sh` program. A simple functioning
    of this program can be represented by the following meta-code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，该程序每秒运行一次，感谢ADC管理器定期将其输出发送到`lcd.sh`程序。该程序的简单功能可以通过以下元代码表示：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That's all! The other complexities are only related to how we wish to implement
    the user interface.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！其他复杂性仅与我们希望如何实现用户界面相关。
- en: 'Regarding this issue, I decided to use a really simple solution: some terminal
    **escape sequences** to manage the colors, and the `figlet` program to *draw*
    big fonts. Escape sequences are used to easily print some characters on the screen
    with specified colors by using the `echo` command, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个问题，我决定使用一个非常简单的解决方案：一些终端**转义序列**来管理颜色，以及`figlet`程序来*绘制*大字体。转义序列通过`echo`命令轻松地在屏幕上打印带有指定颜色的字符，示例如下：
- en: '[PRE34]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `\e[31m` sequence sets the red color, while the `\e[39m` sequence resets
    the default one.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`\e[31m`序列设置红色，而`\e[39m`序列将颜色重置为默认值。'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For further information regarding these sequences, a good starting point is
    available at [https://en.wikipedia.org/wiki/ANSI_escape_code](https://en.wikipedia.org/wiki/ANSI_escape_code).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解有关这些序列的更多信息，一个很好的起点是[https://en.wikipedia.org/wiki/ANSI_escape_code](https://en.wikipedia.org/wiki/ANSI_escape_code)。
- en: 'The `figlet` program is a tool that can be used to simulate printing big fonts
    on a terminal, a kind of ASCII art. To install it, we can use the following command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`figlet`程序是一个可以在终端模拟打印大字体的工具，一种ASCII艺术。要安装它，可以使用以下命令：'
- en: '[PRE35]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, its usage is very simple, as shown in the following example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用方法非常简单，如以下示例所示：
- en: '[PRE36]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For our user interface implementation, I used some special option arguments
    that I'm not going to explain here due to lack of space, but a curious reader
    can take a look at man pages of `figlet` for further information.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的用户界面实现，我使用了一些特殊的选项参数，由于篇幅限制，我不打算在这里解释，但有兴趣的读者可以查看`figlet`的man页面了解更多信息。
- en: 'After this brief introduction, it''s time to show a snippet of the main code
    of the `lcd.sh` program:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段简短的介绍之后，接下来是展示 `lcd.sh` 程序的主要代码片段：
- en: '[PRE37]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code can be found in the `chapter_06/lcd.sh` file in the book's
    example code repository.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在书籍示例代码库中的 `chapter_06/lcd.sh` 文件找到。
- en: From the beginning of the `while` loop until the `read` statement, we simply
    collect the data. Then, the code following the `Draw the GUI` comment is just
    to render the user interface. Note that the line with the `read` command will
    wait until an input line arrives from the `stdin` stream, that is, from the `adc`
    program.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `while` 循环的开始到 `read` 语句，我们只是收集数据。然后，`Draw the GUI` 注释之后的代码只是为了渲染用户界面。请注意，带有
    `read` 命令的那一行会等待直到来自 `stdin` 流的输入行到达，也就是来自 `adc` 程序的输入。
- en: 'To test it via `SSH` in a normal terminal of our host system, simulating the
    LCD, we can execute the following command to reduce the size of the terminal''s
    windows to 32x26 characters, which is the size of the terminal on LCD:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 `SSH` 在我们主机系统的普通终端上测试它，并模拟 LCD，我们可以执行以下命令，将终端窗口的大小缩小为 32x26 个字符，这是 LCD 上终端的大小：
- en: '[PRE38]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that the preceding command is just another escape sequence.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上面的命令只是另一个转义序列。
- en: 'Then, we can execute the program, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照如下方式执行程序：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as shown in the following screenshot:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下面的截图所示：
- en: '![The LCD manager](img/B00255_06_12.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![LCD 管理器](img/B00255_06_12.jpg)'
- en: Final test
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终测试
- en: 'To test the prototype, I used some tricks to simulate the baby: I got the crying
    sound on the Internet and simply reproduced it with an audio player. Regarding
    the breath, I used doll, manually pressurizing its chest in time with my breathing.
    I admit it''s not the best test, but my children are too big to help me in these
    experiments!'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试原型，我使用了一些技巧来模拟婴儿：我在互联网上找到了哭声，并用音频播放器简单地播放出来。至于呼吸，我用一个娃娃，手动按压其胸部，配合我的呼吸。我承认这不是最好的测试方法，但我的孩子们太大了，无法帮我做这些实验！
- en: 'To set up all peripherals and drivers, we can use `SYSINIT.sh`, as in the following
    command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置所有外设和驱动程序，我们可以使用 `SYSINIT.sh`，如以下命令所示：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This command can be found in the `chapter_06/SYSINIT.sh` file in the book's
    example code repository.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令可以在书籍示例代码库中的 `chapter_06/SYSINIT.sh` 文件找到。
- en: 'Then, I executed both the `adc` and `lcd.sh` programs by using the following
    command line in order to send all outputs to the terminal that runs on the tiny
    LCD:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我使用以下命令行执行了 `adc` 和 `lcd.sh` 程序，以便将所有输出发送到运行在小型 LCD 上的终端：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Tip
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that on the first framebuffer device, we have at least one terminal defined
    by default, which is referred to by the `/dev/tty0` device.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一个帧缓冲设备上，默认至少定义了一个终端，通过 `/dev/tty0` 设备引用它。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discovered a more reliable and precise way to get access
    to the BeagleBone Black's ADCs and learned how we can get access to an I²C device
    by using a raw access to the bus. This was done in order to be able to manage
    a pressure sensor and a contactless temperature sensor. Also, we discovered how
    to connect a tiny LCD via the SPI bus to our BeagleBone Black board to add a little
    user interface.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们发现了一种更可靠、更精确的方式来访问 BeagleBone Black 的 ADC，并学习了如何通过直接访问总线来访问 I²C 设备。这样做是为了能够管理压力传感器和无接触温度传感器。此外，我们还发现了如何通过
    SPI 总线将一个小型 LCD 连接到我们的 BeagleBone Black 主板，以便添加一些用户界面。
- en: In the next chapter, we'll try to implement a plant monitor to measure what
    happens to our beloved plants! Also, we will discover how we can periodically
    take some pictures and then publish them on a Facebook account.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将尝试实现一个植物监测器，来测量我们心爱的植物发生了什么！此外，我们还将发现如何定期拍摄一些照片，然后将其发布到 Facebook 账户上。
